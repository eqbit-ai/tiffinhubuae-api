
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model TiffinSkip
 * 
 */
export type TiffinSkip = $Result.DefaultSelection<Prisma.$TiffinSkipPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Ingredient
 * 
 */
export type Ingredient = $Result.DefaultSelection<Prisma.$IngredientPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model Wastage
 * 
 */
export type Wastage = $Result.DefaultSelection<Prisma.$WastagePayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model PaymentHistory
 * 
 */
export type PaymentHistory = $Result.DefaultSelection<Prisma.$PaymentHistoryPayload>
/**
 * Model PaymentLink
 * 
 */
export type PaymentLink = $Result.DefaultSelection<Prisma.$PaymentLinkPayload>
/**
 * Model ConsumptionLog
 * 
 */
export type ConsumptionLog = $Result.DefaultSelection<Prisma.$ConsumptionLogPayload>
/**
 * Model MealRating
 * 
 */
export type MealRating = $Result.DefaultSelection<Prisma.$MealRatingPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model FamilyGroup
 * 
 */
export type FamilyGroup = $Result.DefaultSelection<Prisma.$FamilyGroupPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model DeliveryBatch
 * 
 */
export type DeliveryBatch = $Result.DefaultSelection<Prisma.$DeliveryBatchPayload>
/**
 * Model DeliveryItem
 * 
 */
export type DeliveryItem = $Result.DefaultSelection<Prisma.$DeliveryItemPayload>
/**
 * Model Container
 * 
 */
export type Container = $Result.DefaultSelection<Prisma.$ContainerPayload>
/**
 * Model ContainerLog
 * 
 */
export type ContainerLog = $Result.DefaultSelection<Prisma.$ContainerLogPayload>
/**
 * Model Kitchen
 * 
 */
export type Kitchen = $Result.DefaultSelection<Prisma.$KitchenPayload>
/**
 * Model PrepItem
 * 
 */
export type PrepItem = $Result.DefaultSelection<Prisma.$PrepItemPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs>;

  /**
   * `prisma.tiffinSkip`: Exposes CRUD operations for the **TiffinSkip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TiffinSkips
    * const tiffinSkips = await prisma.tiffinSkip.findMany()
    * ```
    */
  get tiffinSkip(): Prisma.TiffinSkipDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.wastage`: Exposes CRUD operations for the **Wastage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wastages
    * const wastages = await prisma.wastage.findMany()
    * ```
    */
  get wastage(): Prisma.WastageDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.paymentHistory`: Exposes CRUD operations for the **PaymentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentHistories
    * const paymentHistories = await prisma.paymentHistory.findMany()
    * ```
    */
  get paymentHistory(): Prisma.PaymentHistoryDelegate<ExtArgs>;

  /**
   * `prisma.paymentLink`: Exposes CRUD operations for the **PaymentLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentLinks
    * const paymentLinks = await prisma.paymentLink.findMany()
    * ```
    */
  get paymentLink(): Prisma.PaymentLinkDelegate<ExtArgs>;

  /**
   * `prisma.consumptionLog`: Exposes CRUD operations for the **ConsumptionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsumptionLogs
    * const consumptionLogs = await prisma.consumptionLog.findMany()
    * ```
    */
  get consumptionLog(): Prisma.ConsumptionLogDelegate<ExtArgs>;

  /**
   * `prisma.mealRating`: Exposes CRUD operations for the **MealRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MealRatings
    * const mealRatings = await prisma.mealRating.findMany()
    * ```
    */
  get mealRating(): Prisma.MealRatingDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.familyGroup`: Exposes CRUD operations for the **FamilyGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyGroups
    * const familyGroups = await prisma.familyGroup.findMany()
    * ```
    */
  get familyGroup(): Prisma.FamilyGroupDelegate<ExtArgs>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs>;

  /**
   * `prisma.deliveryBatch`: Exposes CRUD operations for the **DeliveryBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryBatches
    * const deliveryBatches = await prisma.deliveryBatch.findMany()
    * ```
    */
  get deliveryBatch(): Prisma.DeliveryBatchDelegate<ExtArgs>;

  /**
   * `prisma.deliveryItem`: Exposes CRUD operations for the **DeliveryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryItems
    * const deliveryItems = await prisma.deliveryItem.findMany()
    * ```
    */
  get deliveryItem(): Prisma.DeliveryItemDelegate<ExtArgs>;

  /**
   * `prisma.container`: Exposes CRUD operations for the **Container** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Containers
    * const containers = await prisma.container.findMany()
    * ```
    */
  get container(): Prisma.ContainerDelegate<ExtArgs>;

  /**
   * `prisma.containerLog`: Exposes CRUD operations for the **ContainerLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContainerLogs
    * const containerLogs = await prisma.containerLog.findMany()
    * ```
    */
  get containerLog(): Prisma.ContainerLogDelegate<ExtArgs>;

  /**
   * `prisma.kitchen`: Exposes CRUD operations for the **Kitchen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kitchens
    * const kitchens = await prisma.kitchen.findMany()
    * ```
    */
  get kitchen(): Prisma.KitchenDelegate<ExtArgs>;

  /**
   * `prisma.prepItem`: Exposes CRUD operations for the **PrepItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrepItems
    * const prepItems = await prisma.prepItem.findMany()
    * ```
    */
  get prepItem(): Prisma.PrepItemDelegate<ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    Order: 'Order',
    MenuItem: 'MenuItem',
    TiffinSkip: 'TiffinSkip',
    Notification: 'Notification',
    ActivityLog: 'ActivityLog',
    Ingredient: 'Ingredient',
    Recipe: 'Recipe',
    Supplier: 'Supplier',
    Purchase: 'Purchase',
    Wastage: 'Wastage',
    SupportTicket: 'SupportTicket',
    Subscription: 'Subscription',
    PaymentHistory: 'PaymentHistory',
    PaymentLink: 'PaymentLink',
    ConsumptionLog: 'ConsumptionLog',
    MealRating: 'MealRating',
    Invoice: 'Invoice',
    Referral: 'Referral',
    FamilyGroup: 'FamilyGroup',
    Driver: 'Driver',
    DeliveryBatch: 'DeliveryBatch',
    DeliveryItem: 'DeliveryItem',
    Container: 'Container',
    ContainerLog: 'ContainerLog',
    Kitchen: 'Kitchen',
    PrepItem: 'PrepItem',
    ChatMessage: 'ChatMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "customer" | "order" | "menuItem" | "tiffinSkip" | "notification" | "activityLog" | "ingredient" | "recipe" | "supplier" | "purchase" | "wastage" | "supportTicket" | "subscription" | "paymentHistory" | "paymentLink" | "consumptionLog" | "mealRating" | "invoice" | "referral" | "familyGroup" | "driver" | "deliveryBatch" | "deliveryItem" | "container" | "containerLog" | "kitchen" | "prepItem" | "chatMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      TiffinSkip: {
        payload: Prisma.$TiffinSkipPayload<ExtArgs>
        fields: Prisma.TiffinSkipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TiffinSkipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TiffinSkipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          findFirst: {
            args: Prisma.TiffinSkipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TiffinSkipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          findMany: {
            args: Prisma.TiffinSkipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>[]
          }
          create: {
            args: Prisma.TiffinSkipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          createMany: {
            args: Prisma.TiffinSkipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TiffinSkipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>[]
          }
          delete: {
            args: Prisma.TiffinSkipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          update: {
            args: Prisma.TiffinSkipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          deleteMany: {
            args: Prisma.TiffinSkipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TiffinSkipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TiffinSkipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiffinSkipPayload>
          }
          aggregate: {
            args: Prisma.TiffinSkipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiffinSkip>
          }
          groupBy: {
            args: Prisma.TiffinSkipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiffinSkipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TiffinSkipCountArgs<ExtArgs>
            result: $Utils.Optional<TiffinSkipCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Ingredient: {
        payload: Prisma.$IngredientPayload<ExtArgs>
        fields: Prisma.IngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findFirst: {
            args: Prisma.IngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findMany: {
            args: Prisma.IngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
          }
          create: {
            args: Prisma.IngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          createMany: {
            args: Prisma.IngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
          }
          delete: {
            args: Prisma.IngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          update: {
            args: Prisma.IngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          deleteMany: {
            args: Prisma.IngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          aggregate: {
            args: Prisma.IngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngredient>
          }
          groupBy: {
            args: Prisma.IngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientCountArgs<ExtArgs>
            result: $Utils.Optional<IngredientCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      Wastage: {
        payload: Prisma.$WastagePayload<ExtArgs>
        fields: Prisma.WastageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WastageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WastageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          findFirst: {
            args: Prisma.WastageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WastageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          findMany: {
            args: Prisma.WastageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>[]
          }
          create: {
            args: Prisma.WastageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          createMany: {
            args: Prisma.WastageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WastageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>[]
          }
          delete: {
            args: Prisma.WastageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          update: {
            args: Prisma.WastageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          deleteMany: {
            args: Prisma.WastageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WastageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WastageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WastagePayload>
          }
          aggregate: {
            args: Prisma.WastageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWastage>
          }
          groupBy: {
            args: Prisma.WastageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WastageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WastageCountArgs<ExtArgs>
            result: $Utils.Optional<WastageCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PaymentHistory: {
        payload: Prisma.$PaymentHistoryPayload<ExtArgs>
        fields: Prisma.PaymentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          findFirst: {
            args: Prisma.PaymentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          findMany: {
            args: Prisma.PaymentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>[]
          }
          create: {
            args: Prisma.PaymentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          createMany: {
            args: Prisma.PaymentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>[]
          }
          delete: {
            args: Prisma.PaymentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          update: {
            args: Prisma.PaymentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PaymentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentHistoryPayload>
          }
          aggregate: {
            args: Prisma.PaymentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentHistory>
          }
          groupBy: {
            args: Prisma.PaymentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentHistoryCountAggregateOutputType> | number
          }
        }
      }
      PaymentLink: {
        payload: Prisma.$PaymentLinkPayload<ExtArgs>
        fields: Prisma.PaymentLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          findFirst: {
            args: Prisma.PaymentLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          findMany: {
            args: Prisma.PaymentLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>[]
          }
          create: {
            args: Prisma.PaymentLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          createMany: {
            args: Prisma.PaymentLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>[]
          }
          delete: {
            args: Prisma.PaymentLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          update: {
            args: Prisma.PaymentLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          deleteMany: {
            args: Prisma.PaymentLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentLinkPayload>
          }
          aggregate: {
            args: Prisma.PaymentLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentLink>
          }
          groupBy: {
            args: Prisma.PaymentLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentLinkCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentLinkCountAggregateOutputType> | number
          }
        }
      }
      ConsumptionLog: {
        payload: Prisma.$ConsumptionLogPayload<ExtArgs>
        fields: Prisma.ConsumptionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsumptionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsumptionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          findFirst: {
            args: Prisma.ConsumptionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsumptionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          findMany: {
            args: Prisma.ConsumptionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>[]
          }
          create: {
            args: Prisma.ConsumptionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          createMany: {
            args: Prisma.ConsumptionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsumptionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>[]
          }
          delete: {
            args: Prisma.ConsumptionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          update: {
            args: Prisma.ConsumptionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          deleteMany: {
            args: Prisma.ConsumptionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsumptionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsumptionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsumptionLogPayload>
          }
          aggregate: {
            args: Prisma.ConsumptionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsumptionLog>
          }
          groupBy: {
            args: Prisma.ConsumptionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsumptionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsumptionLogCountArgs<ExtArgs>
            result: $Utils.Optional<ConsumptionLogCountAggregateOutputType> | number
          }
        }
      }
      MealRating: {
        payload: Prisma.$MealRatingPayload<ExtArgs>
        fields: Prisma.MealRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          findFirst: {
            args: Prisma.MealRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          findMany: {
            args: Prisma.MealRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>[]
          }
          create: {
            args: Prisma.MealRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          createMany: {
            args: Prisma.MealRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>[]
          }
          delete: {
            args: Prisma.MealRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          update: {
            args: Prisma.MealRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          deleteMany: {
            args: Prisma.MealRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MealRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealRatingPayload>
          }
          aggregate: {
            args: Prisma.MealRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMealRating>
          }
          groupBy: {
            args: Prisma.MealRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealRatingCountArgs<ExtArgs>
            result: $Utils.Optional<MealRatingCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      FamilyGroup: {
        payload: Prisma.$FamilyGroupPayload<ExtArgs>
        fields: Prisma.FamilyGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          findFirst: {
            args: Prisma.FamilyGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          findMany: {
            args: Prisma.FamilyGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>[]
          }
          create: {
            args: Prisma.FamilyGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          createMany: {
            args: Prisma.FamilyGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamilyGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>[]
          }
          delete: {
            args: Prisma.FamilyGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          update: {
            args: Prisma.FamilyGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          deleteMany: {
            args: Prisma.FamilyGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyGroupPayload>
          }
          aggregate: {
            args: Prisma.FamilyGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyGroup>
          }
          groupBy: {
            args: Prisma.FamilyGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyGroupCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyGroupCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      DeliveryBatch: {
        payload: Prisma.$DeliveryBatchPayload<ExtArgs>
        fields: Prisma.DeliveryBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          findFirst: {
            args: Prisma.DeliveryBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          findMany: {
            args: Prisma.DeliveryBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>[]
          }
          create: {
            args: Prisma.DeliveryBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          createMany: {
            args: Prisma.DeliveryBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>[]
          }
          delete: {
            args: Prisma.DeliveryBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          update: {
            args: Prisma.DeliveryBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryBatchPayload>
          }
          aggregate: {
            args: Prisma.DeliveryBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryBatch>
          }
          groupBy: {
            args: Prisma.DeliveryBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryBatchCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryBatchCountAggregateOutputType> | number
          }
        }
      }
      DeliveryItem: {
        payload: Prisma.$DeliveryItemPayload<ExtArgs>
        fields: Prisma.DeliveryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          findFirst: {
            args: Prisma.DeliveryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          findMany: {
            args: Prisma.DeliveryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>[]
          }
          create: {
            args: Prisma.DeliveryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          createMany: {
            args: Prisma.DeliveryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>[]
          }
          delete: {
            args: Prisma.DeliveryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          update: {
            args: Prisma.DeliveryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryItemPayload>
          }
          aggregate: {
            args: Prisma.DeliveryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryItem>
          }
          groupBy: {
            args: Prisma.DeliveryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryItemCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryItemCountAggregateOutputType> | number
          }
        }
      }
      Container: {
        payload: Prisma.$ContainerPayload<ExtArgs>
        fields: Prisma.ContainerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findFirst: {
            args: Prisma.ContainerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          findMany: {
            args: Prisma.ContainerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          create: {
            args: Prisma.ContainerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          createMany: {
            args: Prisma.ContainerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>[]
          }
          delete: {
            args: Prisma.ContainerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          update: {
            args: Prisma.ContainerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          deleteMany: {
            args: Prisma.ContainerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContainerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerPayload>
          }
          aggregate: {
            args: Prisma.ContainerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainer>
          }
          groupBy: {
            args: Prisma.ContainerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerCountAggregateOutputType> | number
          }
        }
      }
      ContainerLog: {
        payload: Prisma.$ContainerLogPayload<ExtArgs>
        fields: Prisma.ContainerLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContainerLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContainerLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          findFirst: {
            args: Prisma.ContainerLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContainerLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          findMany: {
            args: Prisma.ContainerLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>[]
          }
          create: {
            args: Prisma.ContainerLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          createMany: {
            args: Prisma.ContainerLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContainerLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>[]
          }
          delete: {
            args: Prisma.ContainerLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          update: {
            args: Prisma.ContainerLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          deleteMany: {
            args: Prisma.ContainerLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContainerLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContainerLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContainerLogPayload>
          }
          aggregate: {
            args: Prisma.ContainerLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContainerLog>
          }
          groupBy: {
            args: Prisma.ContainerLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContainerLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContainerLogCountArgs<ExtArgs>
            result: $Utils.Optional<ContainerLogCountAggregateOutputType> | number
          }
        }
      }
      Kitchen: {
        payload: Prisma.$KitchenPayload<ExtArgs>
        fields: Prisma.KitchenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitchenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitchenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findFirst: {
            args: Prisma.KitchenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitchenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findMany: {
            args: Prisma.KitchenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          create: {
            args: Prisma.KitchenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          createMany: {
            args: Prisma.KitchenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitchenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          delete: {
            args: Prisma.KitchenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          update: {
            args: Prisma.KitchenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          deleteMany: {
            args: Prisma.KitchenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitchenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KitchenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          aggregate: {
            args: Prisma.KitchenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitchen>
          }
          groupBy: {
            args: Prisma.KitchenGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitchenGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitchenCountArgs<ExtArgs>
            result: $Utils.Optional<KitchenCountAggregateOutputType> | number
          }
        }
      }
      PrepItem: {
        payload: Prisma.$PrepItemPayload<ExtArgs>
        fields: Prisma.PrepItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrepItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrepItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          findFirst: {
            args: Prisma.PrepItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrepItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          findMany: {
            args: Prisma.PrepItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>[]
          }
          create: {
            args: Prisma.PrepItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          createMany: {
            args: Prisma.PrepItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrepItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>[]
          }
          delete: {
            args: Prisma.PrepItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          update: {
            args: Prisma.PrepItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          deleteMany: {
            args: Prisma.PrepItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrepItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrepItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrepItemPayload>
          }
          aggregate: {
            args: Prisma.PrepItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrepItem>
          }
          groupBy: {
            args: Prisma.PrepItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrepItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrepItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrepItemCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    customers: number
    orders: number
    menuItems: number
    tiffinSkips: number
    ingredients: number
    recipes: number
    suppliers: number
    purchases: number
    wastages: number
    activityLogs: number
    paymentLinks: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | UserCountOutputTypeCountCustomersArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    menuItems?: boolean | UserCountOutputTypeCountMenuItemsArgs
    tiffinSkips?: boolean | UserCountOutputTypeCountTiffinSkipsArgs
    ingredients?: boolean | UserCountOutputTypeCountIngredientsArgs
    recipes?: boolean | UserCountOutputTypeCountRecipesArgs
    suppliers?: boolean | UserCountOutputTypeCountSuppliersArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    wastages?: boolean | UserCountOutputTypeCountWastagesArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    paymentLinks?: boolean | UserCountOutputTypeCountPaymentLinksArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTiffinSkipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiffinSkipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WastageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentLinkWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    tiffinSkips: number
    paymentLinks: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    tiffinSkips?: boolean | CustomerCountOutputTypeCountTiffinSkipsArgs
    paymentLinks?: boolean | CustomerCountOutputTypeCountPaymentLinksArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTiffinSkipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiffinSkipWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentLinkWhereInput
  }


  /**
   * Count Type IngredientCountOutputType
   */

  export type IngredientCountOutputType = {
    wastages: number
  }

  export type IngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wastages?: boolean | IngredientCountOutputTypeCountWastagesArgs
  }

  // Custom InputTypes
  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     */
    select?: IngredientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountWastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WastageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    fee_percentage: number | null
    whatsapp_sent_count: number | null
    whatsapp_limit: number | null
  }

  export type UserSumAggregateOutputType = {
    fee_percentage: number | null
    whatsapp_sent_count: number | null
    whatsapp_limit: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    role: string | null
    phone: string | null
    business_name: string | null
    logo_url: string | null
    subscription_status: string | null
    plan_type: string | null
    subscription_source: string | null
    trial_ends_at: Date | null
    trial_cancelled_at: Date | null
    subscription_ends_at: Date | null
    current_period_end: Date | null
    next_billing_date: Date | null
    cancel_at_period_end: boolean | null
    cancellation_reason: string | null
    cancelled_at: Date | null
    is_paid: boolean | null
    last_payment_status: string | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    stripe_connect_account_id: string | null
    payment_account_connected: boolean | null
    payment_verification_status: string | null
    fee_consent_accepted: boolean | null
    fee_percentage: number | null
    whatsapp_sent_count: number | null
    whatsapp_limit: number | null
    whatsapp_notifications_enabled: boolean | null
    whatsapp_number: string | null
    currency: string | null
    language: string | null
    seasonal_mode: string | null
    seasonal_mode_start: string | null
    seasonal_mode_end: string | null
    ramadan_lunch_time: string | null
    ramadan_dinner_time: string | null
    ramadan_suhoor_time: string | null
    ramadan_iftar_time: string | null
    is_super_admin: boolean | null
    special_access_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    full_name: string | null
    role: string | null
    phone: string | null
    business_name: string | null
    logo_url: string | null
    subscription_status: string | null
    plan_type: string | null
    subscription_source: string | null
    trial_ends_at: Date | null
    trial_cancelled_at: Date | null
    subscription_ends_at: Date | null
    current_period_end: Date | null
    next_billing_date: Date | null
    cancel_at_period_end: boolean | null
    cancellation_reason: string | null
    cancelled_at: Date | null
    is_paid: boolean | null
    last_payment_status: string | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    stripe_connect_account_id: string | null
    payment_account_connected: boolean | null
    payment_verification_status: string | null
    fee_consent_accepted: boolean | null
    fee_percentage: number | null
    whatsapp_sent_count: number | null
    whatsapp_limit: number | null
    whatsapp_notifications_enabled: boolean | null
    whatsapp_number: string | null
    currency: string | null
    language: string | null
    seasonal_mode: string | null
    seasonal_mode_start: string | null
    seasonal_mode_end: string | null
    ramadan_lunch_time: string | null
    ramadan_dinner_time: string | null
    ramadan_suhoor_time: string | null
    ramadan_iftar_time: string | null
    is_super_admin: boolean | null
    special_access_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    full_name: number
    role: number
    phone: number
    business_name: number
    logo_url: number
    subscription_status: number
    plan_type: number
    subscription_source: number
    trial_ends_at: number
    trial_cancelled_at: number
    subscription_ends_at: number
    current_period_end: number
    next_billing_date: number
    cancel_at_period_end: number
    cancellation_reason: number
    cancelled_at: number
    is_paid: number
    last_payment_status: number
    stripe_customer_id: number
    stripe_subscription_id: number
    stripe_connect_account_id: number
    payment_account_connected: number
    payment_verification_status: number
    fee_consent_accepted: number
    fee_percentage: number
    whatsapp_sent_count: number
    whatsapp_limit: number
    whatsapp_notifications_enabled: number
    whatsapp_number: number
    currency: number
    language: number
    seasonal_mode: number
    seasonal_mode_start: number
    seasonal_mode_end: number
    ramadan_lunch_time: number
    ramadan_dinner_time: number
    ramadan_suhoor_time: number
    ramadan_iftar_time: number
    is_super_admin: number
    special_access_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    fee_percentage?: true
    whatsapp_sent_count?: true
    whatsapp_limit?: true
  }

  export type UserSumAggregateInputType = {
    fee_percentage?: true
    whatsapp_sent_count?: true
    whatsapp_limit?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    role?: true
    phone?: true
    business_name?: true
    logo_url?: true
    subscription_status?: true
    plan_type?: true
    subscription_source?: true
    trial_ends_at?: true
    trial_cancelled_at?: true
    subscription_ends_at?: true
    current_period_end?: true
    next_billing_date?: true
    cancel_at_period_end?: true
    cancellation_reason?: true
    cancelled_at?: true
    is_paid?: true
    last_payment_status?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    stripe_connect_account_id?: true
    payment_account_connected?: true
    payment_verification_status?: true
    fee_consent_accepted?: true
    fee_percentage?: true
    whatsapp_sent_count?: true
    whatsapp_limit?: true
    whatsapp_notifications_enabled?: true
    whatsapp_number?: true
    currency?: true
    language?: true
    seasonal_mode?: true
    seasonal_mode_start?: true
    seasonal_mode_end?: true
    ramadan_lunch_time?: true
    ramadan_dinner_time?: true
    ramadan_suhoor_time?: true
    ramadan_iftar_time?: true
    is_super_admin?: true
    special_access_type?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    role?: true
    phone?: true
    business_name?: true
    logo_url?: true
    subscription_status?: true
    plan_type?: true
    subscription_source?: true
    trial_ends_at?: true
    trial_cancelled_at?: true
    subscription_ends_at?: true
    current_period_end?: true
    next_billing_date?: true
    cancel_at_period_end?: true
    cancellation_reason?: true
    cancelled_at?: true
    is_paid?: true
    last_payment_status?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    stripe_connect_account_id?: true
    payment_account_connected?: true
    payment_verification_status?: true
    fee_consent_accepted?: true
    fee_percentage?: true
    whatsapp_sent_count?: true
    whatsapp_limit?: true
    whatsapp_notifications_enabled?: true
    whatsapp_number?: true
    currency?: true
    language?: true
    seasonal_mode?: true
    seasonal_mode_start?: true
    seasonal_mode_end?: true
    ramadan_lunch_time?: true
    ramadan_dinner_time?: true
    ramadan_suhoor_time?: true
    ramadan_iftar_time?: true
    is_super_admin?: true
    special_access_type?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    full_name?: true
    role?: true
    phone?: true
    business_name?: true
    logo_url?: true
    subscription_status?: true
    plan_type?: true
    subscription_source?: true
    trial_ends_at?: true
    trial_cancelled_at?: true
    subscription_ends_at?: true
    current_period_end?: true
    next_billing_date?: true
    cancel_at_period_end?: true
    cancellation_reason?: true
    cancelled_at?: true
    is_paid?: true
    last_payment_status?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    stripe_connect_account_id?: true
    payment_account_connected?: true
    payment_verification_status?: true
    fee_consent_accepted?: true
    fee_percentage?: true
    whatsapp_sent_count?: true
    whatsapp_limit?: true
    whatsapp_notifications_enabled?: true
    whatsapp_number?: true
    currency?: true
    language?: true
    seasonal_mode?: true
    seasonal_mode_start?: true
    seasonal_mode_end?: true
    ramadan_lunch_time?: true
    ramadan_dinner_time?: true
    ramadan_suhoor_time?: true
    ramadan_iftar_time?: true
    is_super_admin?: true
    special_access_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    full_name: string | null
    role: string
    phone: string | null
    business_name: string | null
    logo_url: string | null
    subscription_status: string | null
    plan_type: string | null
    subscription_source: string | null
    trial_ends_at: Date | null
    trial_cancelled_at: Date | null
    subscription_ends_at: Date | null
    current_period_end: Date | null
    next_billing_date: Date | null
    cancel_at_period_end: boolean | null
    cancellation_reason: string | null
    cancelled_at: Date | null
    is_paid: boolean
    last_payment_status: string | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    stripe_connect_account_id: string | null
    payment_account_connected: boolean | null
    payment_verification_status: string | null
    fee_consent_accepted: boolean | null
    fee_percentage: number | null
    whatsapp_sent_count: number
    whatsapp_limit: number
    whatsapp_notifications_enabled: boolean | null
    whatsapp_number: string | null
    currency: string | null
    language: string | null
    seasonal_mode: string | null
    seasonal_mode_start: string | null
    seasonal_mode_end: string | null
    ramadan_lunch_time: string | null
    ramadan_dinner_time: string | null
    ramadan_suhoor_time: string | null
    ramadan_iftar_time: string | null
    is_super_admin: boolean
    special_access_type: string | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    role?: boolean
    phone?: boolean
    business_name?: boolean
    logo_url?: boolean
    subscription_status?: boolean
    plan_type?: boolean
    subscription_source?: boolean
    trial_ends_at?: boolean
    trial_cancelled_at?: boolean
    subscription_ends_at?: boolean
    current_period_end?: boolean
    next_billing_date?: boolean
    cancel_at_period_end?: boolean
    cancellation_reason?: boolean
    cancelled_at?: boolean
    is_paid?: boolean
    last_payment_status?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    stripe_connect_account_id?: boolean
    payment_account_connected?: boolean
    payment_verification_status?: boolean
    fee_consent_accepted?: boolean
    fee_percentage?: boolean
    whatsapp_sent_count?: boolean
    whatsapp_limit?: boolean
    whatsapp_notifications_enabled?: boolean
    whatsapp_number?: boolean
    currency?: boolean
    language?: boolean
    seasonal_mode?: boolean
    seasonal_mode_start?: boolean
    seasonal_mode_end?: boolean
    ramadan_lunch_time?: boolean
    ramadan_dinner_time?: boolean
    ramadan_suhoor_time?: boolean
    ramadan_iftar_time?: boolean
    is_super_admin?: boolean
    special_access_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    customers?: boolean | User$customersArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    menuItems?: boolean | User$menuItemsArgs<ExtArgs>
    tiffinSkips?: boolean | User$tiffinSkipsArgs<ExtArgs>
    ingredients?: boolean | User$ingredientsArgs<ExtArgs>
    recipes?: boolean | User$recipesArgs<ExtArgs>
    suppliers?: boolean | User$suppliersArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    wastages?: boolean | User$wastagesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    paymentLinks?: boolean | User$paymentLinksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    role?: boolean
    phone?: boolean
    business_name?: boolean
    logo_url?: boolean
    subscription_status?: boolean
    plan_type?: boolean
    subscription_source?: boolean
    trial_ends_at?: boolean
    trial_cancelled_at?: boolean
    subscription_ends_at?: boolean
    current_period_end?: boolean
    next_billing_date?: boolean
    cancel_at_period_end?: boolean
    cancellation_reason?: boolean
    cancelled_at?: boolean
    is_paid?: boolean
    last_payment_status?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    stripe_connect_account_id?: boolean
    payment_account_connected?: boolean
    payment_verification_status?: boolean
    fee_consent_accepted?: boolean
    fee_percentage?: boolean
    whatsapp_sent_count?: boolean
    whatsapp_limit?: boolean
    whatsapp_notifications_enabled?: boolean
    whatsapp_number?: boolean
    currency?: boolean
    language?: boolean
    seasonal_mode?: boolean
    seasonal_mode_start?: boolean
    seasonal_mode_end?: boolean
    ramadan_lunch_time?: boolean
    ramadan_dinner_time?: boolean
    ramadan_suhoor_time?: boolean
    ramadan_iftar_time?: boolean
    is_super_admin?: boolean
    special_access_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    full_name?: boolean
    role?: boolean
    phone?: boolean
    business_name?: boolean
    logo_url?: boolean
    subscription_status?: boolean
    plan_type?: boolean
    subscription_source?: boolean
    trial_ends_at?: boolean
    trial_cancelled_at?: boolean
    subscription_ends_at?: boolean
    current_period_end?: boolean
    next_billing_date?: boolean
    cancel_at_period_end?: boolean
    cancellation_reason?: boolean
    cancelled_at?: boolean
    is_paid?: boolean
    last_payment_status?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    stripe_connect_account_id?: boolean
    payment_account_connected?: boolean
    payment_verification_status?: boolean
    fee_consent_accepted?: boolean
    fee_percentage?: boolean
    whatsapp_sent_count?: boolean
    whatsapp_limit?: boolean
    whatsapp_notifications_enabled?: boolean
    whatsapp_number?: boolean
    currency?: boolean
    language?: boolean
    seasonal_mode?: boolean
    seasonal_mode_start?: boolean
    seasonal_mode_end?: boolean
    ramadan_lunch_time?: boolean
    ramadan_dinner_time?: boolean
    ramadan_suhoor_time?: boolean
    ramadan_iftar_time?: boolean
    is_super_admin?: boolean
    special_access_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | User$customersArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    menuItems?: boolean | User$menuItemsArgs<ExtArgs>
    tiffinSkips?: boolean | User$tiffinSkipsArgs<ExtArgs>
    ingredients?: boolean | User$ingredientsArgs<ExtArgs>
    recipes?: boolean | User$recipesArgs<ExtArgs>
    suppliers?: boolean | User$suppliersArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    wastages?: boolean | User$wastagesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    paymentLinks?: boolean | User$paymentLinksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
      tiffinSkips: Prisma.$TiffinSkipPayload<ExtArgs>[]
      ingredients: Prisma.$IngredientPayload<ExtArgs>[]
      recipes: Prisma.$RecipePayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      wastages: Prisma.$WastagePayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      paymentLinks: Prisma.$PaymentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      full_name: string | null
      role: string
      phone: string | null
      business_name: string | null
      logo_url: string | null
      subscription_status: string | null
      plan_type: string | null
      subscription_source: string | null
      trial_ends_at: Date | null
      trial_cancelled_at: Date | null
      subscription_ends_at: Date | null
      current_period_end: Date | null
      next_billing_date: Date | null
      cancel_at_period_end: boolean | null
      cancellation_reason: string | null
      cancelled_at: Date | null
      is_paid: boolean
      last_payment_status: string | null
      stripe_customer_id: string | null
      stripe_subscription_id: string | null
      stripe_connect_account_id: string | null
      payment_account_connected: boolean | null
      payment_verification_status: string | null
      fee_consent_accepted: boolean | null
      fee_percentage: number | null
      whatsapp_sent_count: number
      whatsapp_limit: number
      whatsapp_notifications_enabled: boolean | null
      whatsapp_number: string | null
      currency: string | null
      language: string | null
      seasonal_mode: string | null
      seasonal_mode_start: string | null
      seasonal_mode_end: string | null
      ramadan_lunch_time: string | null
      ramadan_dinner_time: string | null
      ramadan_suhoor_time: string | null
      ramadan_iftar_time: string | null
      is_super_admin: boolean
      special_access_type: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends User$customersArgs<ExtArgs> = {}>(args?: Subset<T, User$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    menuItems<T extends User$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany"> | Null>
    tiffinSkips<T extends User$tiffinSkipsArgs<ExtArgs> = {}>(args?: Subset<T, User$tiffinSkipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findMany"> | Null>
    ingredients<T extends User$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, User$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findMany"> | Null>
    recipes<T extends User$recipesArgs<ExtArgs> = {}>(args?: Subset<T, User$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany"> | Null>
    suppliers<T extends User$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, User$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    wastages<T extends User$wastagesArgs<ExtArgs> = {}>(args?: Subset<T, User$wastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    paymentLinks<T extends User$paymentLinksArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly business_name: FieldRef<"User", 'String'>
    readonly logo_url: FieldRef<"User", 'String'>
    readonly subscription_status: FieldRef<"User", 'String'>
    readonly plan_type: FieldRef<"User", 'String'>
    readonly subscription_source: FieldRef<"User", 'String'>
    readonly trial_ends_at: FieldRef<"User", 'DateTime'>
    readonly trial_cancelled_at: FieldRef<"User", 'DateTime'>
    readonly subscription_ends_at: FieldRef<"User", 'DateTime'>
    readonly current_period_end: FieldRef<"User", 'DateTime'>
    readonly next_billing_date: FieldRef<"User", 'DateTime'>
    readonly cancel_at_period_end: FieldRef<"User", 'Boolean'>
    readonly cancellation_reason: FieldRef<"User", 'String'>
    readonly cancelled_at: FieldRef<"User", 'DateTime'>
    readonly is_paid: FieldRef<"User", 'Boolean'>
    readonly last_payment_status: FieldRef<"User", 'String'>
    readonly stripe_customer_id: FieldRef<"User", 'String'>
    readonly stripe_subscription_id: FieldRef<"User", 'String'>
    readonly stripe_connect_account_id: FieldRef<"User", 'String'>
    readonly payment_account_connected: FieldRef<"User", 'Boolean'>
    readonly payment_verification_status: FieldRef<"User", 'String'>
    readonly fee_consent_accepted: FieldRef<"User", 'Boolean'>
    readonly fee_percentage: FieldRef<"User", 'Float'>
    readonly whatsapp_sent_count: FieldRef<"User", 'Int'>
    readonly whatsapp_limit: FieldRef<"User", 'Int'>
    readonly whatsapp_notifications_enabled: FieldRef<"User", 'Boolean'>
    readonly whatsapp_number: FieldRef<"User", 'String'>
    readonly currency: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'String'>
    readonly seasonal_mode: FieldRef<"User", 'String'>
    readonly seasonal_mode_start: FieldRef<"User", 'String'>
    readonly seasonal_mode_end: FieldRef<"User", 'String'>
    readonly ramadan_lunch_time: FieldRef<"User", 'String'>
    readonly ramadan_dinner_time: FieldRef<"User", 'String'>
    readonly ramadan_suhoor_time: FieldRef<"User", 'String'>
    readonly ramadan_iftar_time: FieldRef<"User", 'String'>
    readonly is_super_admin: FieldRef<"User", 'Boolean'>
    readonly special_access_type: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.customers
   */
  export type User$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.menuItems
   */
  export type User$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * User.tiffinSkips
   */
  export type User$tiffinSkipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    where?: TiffinSkipWhereInput
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    cursor?: TiffinSkipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TiffinSkipScalarFieldEnum | TiffinSkipScalarFieldEnum[]
  }

  /**
   * User.ingredients
   */
  export type User$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    cursor?: IngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }

  /**
   * User.recipes
   */
  export type User$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * User.suppliers
   */
  export type User$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * User.wastages
   */
  export type User$wastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    where?: WastageWhereInput
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    cursor?: WastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WastageScalarFieldEnum | WastageScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.paymentLinks
   */
  export type User$paymentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    where?: PaymentLinkWhereInput
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    cursor?: PaymentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentLinkScalarFieldEnum | PaymentLinkScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    payment_amount: number | null
    last_payment_amount: number | null
    paid_days: number | null
    delivered_days: number | null
    days_remaining: number | null
    meals_delivered: number | null
    tiffin_balance: number | null
    roti_quantity: number | null
    total_pause_days: number | null
  }

  export type CustomerSumAggregateOutputType = {
    payment_amount: number | null
    last_payment_amount: number | null
    paid_days: number | null
    delivered_days: number | null
    days_remaining: number | null
    meals_delivered: number | null
    tiffin_balance: number | null
    roti_quantity: number | null
    total_pause_days: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    full_name: string | null
    phone_number: string | null
    address: string | null
    area: string | null
    meal_type: string | null
    payment_amount: number | null
    payment_status: string | null
    due_date: Date | null
    last_payment_date: Date | null
    last_payment_amount: number | null
    active: boolean | null
    status: string | null
    inactive_reason: string | null
    start_date: Date | null
    end_date: Date | null
    paid_days: number | null
    delivered_days: number | null
    days_remaining: number | null
    meals_delivered: number | null
    tiffin_balance: number | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    dietary_preference: string | null
    skip_weekends: boolean | null
    pause_start: Date | null
    pause_end: Date | null
    pause_start_date: string | null
    pause_resume_date: string | null
    original_end_date: string | null
    total_pause_days: number | null
    notification_sent: boolean | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    notes: string | null
    is_trial: boolean | null
    trial_end_date: Date | null
    trial_converted: boolean | null
    is_paused: boolean | null
    is_deleted: boolean | null
    deleted_at: Date | null
    portal_token: string | null
    referral_code: string | null
    referred_by: string | null
    family_group_id: string | null
    kitchen_id: string | null
    registration_source: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    full_name: string | null
    phone_number: string | null
    address: string | null
    area: string | null
    meal_type: string | null
    payment_amount: number | null
    payment_status: string | null
    due_date: Date | null
    last_payment_date: Date | null
    last_payment_amount: number | null
    active: boolean | null
    status: string | null
    inactive_reason: string | null
    start_date: Date | null
    end_date: Date | null
    paid_days: number | null
    delivered_days: number | null
    days_remaining: number | null
    meals_delivered: number | null
    tiffin_balance: number | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    dietary_preference: string | null
    skip_weekends: boolean | null
    pause_start: Date | null
    pause_end: Date | null
    pause_start_date: string | null
    pause_resume_date: string | null
    original_end_date: string | null
    total_pause_days: number | null
    notification_sent: boolean | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    notes: string | null
    is_trial: boolean | null
    trial_end_date: Date | null
    trial_converted: boolean | null
    is_paused: boolean | null
    is_deleted: boolean | null
    deleted_at: Date | null
    portal_token: string | null
    referral_code: string | null
    referred_by: string | null
    family_group_id: string | null
    kitchen_id: string | null
    registration_source: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    full_name: number
    phone_number: number
    address: number
    area: number
    meal_type: number
    payment_amount: number
    payment_status: number
    due_date: number
    last_payment_date: number
    last_payment_amount: number
    active: number
    status: number
    inactive_reason: number
    start_date: number
    end_date: number
    paid_days: number
    delivered_days: number
    days_remaining: number
    meals_delivered: number
    tiffin_balance: number
    roti_quantity: number
    rice_type: number
    special_notes: number
    dietary_preference: number
    skip_weekends: number
    pause_start: number
    pause_end: number
    pause_start_date: number
    pause_resume_date: number
    original_end_date: number
    total_pause_days: number
    pause_history: number
    notification_sent: number
    reminder_before_sent: number
    reminder_after_sent: number
    notes: number
    is_trial: number
    trial_end_date: number
    trial_converted: number
    is_paused: number
    is_deleted: number
    deleted_at: number
    portal_token: number
    referral_code: number
    referred_by: number
    family_group_id: number
    kitchen_id: number
    registration_source: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    payment_amount?: true
    last_payment_amount?: true
    paid_days?: true
    delivered_days?: true
    days_remaining?: true
    meals_delivered?: true
    tiffin_balance?: true
    roti_quantity?: true
    total_pause_days?: true
  }

  export type CustomerSumAggregateInputType = {
    payment_amount?: true
    last_payment_amount?: true
    paid_days?: true
    delivered_days?: true
    days_remaining?: true
    meals_delivered?: true
    tiffin_balance?: true
    roti_quantity?: true
    total_pause_days?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    address?: true
    area?: true
    meal_type?: true
    payment_amount?: true
    payment_status?: true
    due_date?: true
    last_payment_date?: true
    last_payment_amount?: true
    active?: true
    status?: true
    inactive_reason?: true
    start_date?: true
    end_date?: true
    paid_days?: true
    delivered_days?: true
    days_remaining?: true
    meals_delivered?: true
    tiffin_balance?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    dietary_preference?: true
    skip_weekends?: true
    pause_start?: true
    pause_end?: true
    pause_start_date?: true
    pause_resume_date?: true
    original_end_date?: true
    total_pause_days?: true
    notification_sent?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    notes?: true
    is_trial?: true
    trial_end_date?: true
    trial_converted?: true
    is_paused?: true
    is_deleted?: true
    deleted_at?: true
    portal_token?: true
    referral_code?: true
    referred_by?: true
    family_group_id?: true
    kitchen_id?: true
    registration_source?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    address?: true
    area?: true
    meal_type?: true
    payment_amount?: true
    payment_status?: true
    due_date?: true
    last_payment_date?: true
    last_payment_amount?: true
    active?: true
    status?: true
    inactive_reason?: true
    start_date?: true
    end_date?: true
    paid_days?: true
    delivered_days?: true
    days_remaining?: true
    meals_delivered?: true
    tiffin_balance?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    dietary_preference?: true
    skip_weekends?: true
    pause_start?: true
    pause_end?: true
    pause_start_date?: true
    pause_resume_date?: true
    original_end_date?: true
    total_pause_days?: true
    notification_sent?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    notes?: true
    is_trial?: true
    trial_end_date?: true
    trial_converted?: true
    is_paused?: true
    is_deleted?: true
    deleted_at?: true
    portal_token?: true
    referral_code?: true
    referred_by?: true
    family_group_id?: true
    kitchen_id?: true
    registration_source?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    full_name?: true
    phone_number?: true
    address?: true
    area?: true
    meal_type?: true
    payment_amount?: true
    payment_status?: true
    due_date?: true
    last_payment_date?: true
    last_payment_amount?: true
    active?: true
    status?: true
    inactive_reason?: true
    start_date?: true
    end_date?: true
    paid_days?: true
    delivered_days?: true
    days_remaining?: true
    meals_delivered?: true
    tiffin_balance?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    dietary_preference?: true
    skip_weekends?: true
    pause_start?: true
    pause_end?: true
    pause_start_date?: true
    pause_resume_date?: true
    original_end_date?: true
    total_pause_days?: true
    pause_history?: true
    notification_sent?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    notes?: true
    is_trial?: true
    trial_end_date?: true
    trial_converted?: true
    is_paused?: true
    is_deleted?: true
    deleted_at?: true
    portal_token?: true
    referral_code?: true
    referred_by?: true
    family_group_id?: true
    kitchen_id?: true
    registration_source?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    full_name: string
    phone_number: string | null
    address: string | null
    area: string | null
    meal_type: string | null
    payment_amount: number | null
    payment_status: string | null
    due_date: Date | null
    last_payment_date: Date | null
    last_payment_amount: number | null
    active: boolean
    status: string | null
    inactive_reason: string | null
    start_date: Date | null
    end_date: Date | null
    paid_days: number | null
    delivered_days: number | null
    days_remaining: number | null
    meals_delivered: number | null
    tiffin_balance: number | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    dietary_preference: string | null
    skip_weekends: boolean | null
    pause_start: Date | null
    pause_end: Date | null
    pause_start_date: string | null
    pause_resume_date: string | null
    original_end_date: string | null
    total_pause_days: number | null
    pause_history: JsonValue | null
    notification_sent: boolean | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    notes: string | null
    is_trial: boolean | null
    trial_end_date: Date | null
    trial_converted: boolean | null
    is_paused: boolean | null
    is_deleted: boolean
    deleted_at: Date | null
    portal_token: string | null
    referral_code: string | null
    referred_by: string | null
    family_group_id: string | null
    kitchen_id: string | null
    registration_source: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    address?: boolean
    area?: boolean
    meal_type?: boolean
    payment_amount?: boolean
    payment_status?: boolean
    due_date?: boolean
    last_payment_date?: boolean
    last_payment_amount?: boolean
    active?: boolean
    status?: boolean
    inactive_reason?: boolean
    start_date?: boolean
    end_date?: boolean
    paid_days?: boolean
    delivered_days?: boolean
    days_remaining?: boolean
    meals_delivered?: boolean
    tiffin_balance?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    dietary_preference?: boolean
    skip_weekends?: boolean
    pause_start?: boolean
    pause_end?: boolean
    pause_start_date?: boolean
    pause_resume_date?: boolean
    original_end_date?: boolean
    total_pause_days?: boolean
    pause_history?: boolean
    notification_sent?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    notes?: boolean
    is_trial?: boolean
    trial_end_date?: boolean
    trial_converted?: boolean
    is_paused?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    portal_token?: boolean
    referral_code?: boolean
    referred_by?: boolean
    family_group_id?: boolean
    kitchen_id?: boolean
    registration_source?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    tiffinSkips?: boolean | Customer$tiffinSkipsArgs<ExtArgs>
    paymentLinks?: boolean | Customer$paymentLinksArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    address?: boolean
    area?: boolean
    meal_type?: boolean
    payment_amount?: boolean
    payment_status?: boolean
    due_date?: boolean
    last_payment_date?: boolean
    last_payment_amount?: boolean
    active?: boolean
    status?: boolean
    inactive_reason?: boolean
    start_date?: boolean
    end_date?: boolean
    paid_days?: boolean
    delivered_days?: boolean
    days_remaining?: boolean
    meals_delivered?: boolean
    tiffin_balance?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    dietary_preference?: boolean
    skip_weekends?: boolean
    pause_start?: boolean
    pause_end?: boolean
    pause_start_date?: boolean
    pause_resume_date?: boolean
    original_end_date?: boolean
    total_pause_days?: boolean
    pause_history?: boolean
    notification_sent?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    notes?: boolean
    is_trial?: boolean
    trial_end_date?: boolean
    trial_converted?: boolean
    is_paused?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    portal_token?: boolean
    referral_code?: boolean
    referred_by?: boolean
    family_group_id?: boolean
    kitchen_id?: boolean
    registration_source?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    full_name?: boolean
    phone_number?: boolean
    address?: boolean
    area?: boolean
    meal_type?: boolean
    payment_amount?: boolean
    payment_status?: boolean
    due_date?: boolean
    last_payment_date?: boolean
    last_payment_amount?: boolean
    active?: boolean
    status?: boolean
    inactive_reason?: boolean
    start_date?: boolean
    end_date?: boolean
    paid_days?: boolean
    delivered_days?: boolean
    days_remaining?: boolean
    meals_delivered?: boolean
    tiffin_balance?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    dietary_preference?: boolean
    skip_weekends?: boolean
    pause_start?: boolean
    pause_end?: boolean
    pause_start_date?: boolean
    pause_resume_date?: boolean
    original_end_date?: boolean
    total_pause_days?: boolean
    pause_history?: boolean
    notification_sent?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    notes?: boolean
    is_trial?: boolean
    trial_end_date?: boolean
    trial_converted?: boolean
    is_paused?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    portal_token?: boolean
    referral_code?: boolean
    referred_by?: boolean
    family_group_id?: boolean
    kitchen_id?: boolean
    registration_source?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    tiffinSkips?: boolean | Customer$tiffinSkipsArgs<ExtArgs>
    paymentLinks?: boolean | Customer$paymentLinksArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      tiffinSkips: Prisma.$TiffinSkipPayload<ExtArgs>[]
      paymentLinks: Prisma.$PaymentLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      full_name: string
      phone_number: string | null
      address: string | null
      area: string | null
      meal_type: string | null
      payment_amount: number | null
      payment_status: string | null
      due_date: Date | null
      last_payment_date: Date | null
      last_payment_amount: number | null
      active: boolean
      status: string | null
      inactive_reason: string | null
      start_date: Date | null
      end_date: Date | null
      paid_days: number | null
      delivered_days: number | null
      days_remaining: number | null
      meals_delivered: number | null
      tiffin_balance: number | null
      roti_quantity: number | null
      rice_type: string | null
      special_notes: string | null
      dietary_preference: string | null
      skip_weekends: boolean | null
      pause_start: Date | null
      pause_end: Date | null
      pause_start_date: string | null
      pause_resume_date: string | null
      original_end_date: string | null
      total_pause_days: number | null
      pause_history: Prisma.JsonValue | null
      notification_sent: boolean | null
      reminder_before_sent: boolean | null
      reminder_after_sent: boolean | null
      notes: string | null
      is_trial: boolean | null
      trial_end_date: Date | null
      trial_converted: boolean | null
      is_paused: boolean | null
      is_deleted: boolean
      deleted_at: Date | null
      portal_token: string | null
      referral_code: string | null
      referred_by: string | null
      family_group_id: string | null
      kitchen_id: string | null
      registration_source: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    tiffinSkips<T extends Customer$tiffinSkipsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$tiffinSkipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findMany"> | Null>
    paymentLinks<T extends Customer$paymentLinksArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly full_name: FieldRef<"Customer", 'String'>
    readonly phone_number: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly area: FieldRef<"Customer", 'String'>
    readonly meal_type: FieldRef<"Customer", 'String'>
    readonly payment_amount: FieldRef<"Customer", 'Float'>
    readonly payment_status: FieldRef<"Customer", 'String'>
    readonly due_date: FieldRef<"Customer", 'DateTime'>
    readonly last_payment_date: FieldRef<"Customer", 'DateTime'>
    readonly last_payment_amount: FieldRef<"Customer", 'Float'>
    readonly active: FieldRef<"Customer", 'Boolean'>
    readonly status: FieldRef<"Customer", 'String'>
    readonly inactive_reason: FieldRef<"Customer", 'String'>
    readonly start_date: FieldRef<"Customer", 'DateTime'>
    readonly end_date: FieldRef<"Customer", 'DateTime'>
    readonly paid_days: FieldRef<"Customer", 'Int'>
    readonly delivered_days: FieldRef<"Customer", 'Int'>
    readonly days_remaining: FieldRef<"Customer", 'Int'>
    readonly meals_delivered: FieldRef<"Customer", 'Int'>
    readonly tiffin_balance: FieldRef<"Customer", 'Int'>
    readonly roti_quantity: FieldRef<"Customer", 'Int'>
    readonly rice_type: FieldRef<"Customer", 'String'>
    readonly special_notes: FieldRef<"Customer", 'String'>
    readonly dietary_preference: FieldRef<"Customer", 'String'>
    readonly skip_weekends: FieldRef<"Customer", 'Boolean'>
    readonly pause_start: FieldRef<"Customer", 'DateTime'>
    readonly pause_end: FieldRef<"Customer", 'DateTime'>
    readonly pause_start_date: FieldRef<"Customer", 'String'>
    readonly pause_resume_date: FieldRef<"Customer", 'String'>
    readonly original_end_date: FieldRef<"Customer", 'String'>
    readonly total_pause_days: FieldRef<"Customer", 'Int'>
    readonly pause_history: FieldRef<"Customer", 'Json'>
    readonly notification_sent: FieldRef<"Customer", 'Boolean'>
    readonly reminder_before_sent: FieldRef<"Customer", 'Boolean'>
    readonly reminder_after_sent: FieldRef<"Customer", 'Boolean'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly is_trial: FieldRef<"Customer", 'Boolean'>
    readonly trial_end_date: FieldRef<"Customer", 'DateTime'>
    readonly trial_converted: FieldRef<"Customer", 'Boolean'>
    readonly is_paused: FieldRef<"Customer", 'Boolean'>
    readonly is_deleted: FieldRef<"Customer", 'Boolean'>
    readonly deleted_at: FieldRef<"Customer", 'DateTime'>
    readonly portal_token: FieldRef<"Customer", 'String'>
    readonly referral_code: FieldRef<"Customer", 'String'>
    readonly referred_by: FieldRef<"Customer", 'String'>
    readonly family_group_id: FieldRef<"Customer", 'String'>
    readonly kitchen_id: FieldRef<"Customer", 'String'>
    readonly registration_source: FieldRef<"Customer", 'String'>
    readonly created_by: FieldRef<"Customer", 'String'>
    readonly created_at: FieldRef<"Customer", 'DateTime'>
    readonly updated_at: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.tiffinSkips
   */
  export type Customer$tiffinSkipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    where?: TiffinSkipWhereInput
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    cursor?: TiffinSkipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TiffinSkipScalarFieldEnum | TiffinSkipScalarFieldEnum[]
  }

  /**
   * Customer.paymentLinks
   */
  export type Customer$paymentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    where?: PaymentLinkWhereInput
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    cursor?: PaymentLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentLinkScalarFieldEnum | PaymentLinkScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    meal_type: string | null
    delivery_date: string | null
    order_date: string | null
    delivery_status: string | null
    status: string | null
    out_for_delivery_time: string | null
    delivery_photo: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    meal_type: string | null
    delivery_date: string | null
    order_date: string | null
    delivery_status: string | null
    status: string | null
    out_for_delivery_time: string | null
    delivery_photo: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    meal_type: number
    delivery_date: number
    order_date: number
    delivery_status: number
    status: number
    out_for_delivery_time: number
    delivery_photo: number
    notes: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    meal_type?: true
    delivery_date?: true
    order_date?: true
    delivery_status?: true
    status?: true
    out_for_delivery_time?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    meal_type?: true
    delivery_date?: true
    order_date?: true
    delivery_status?: true
    status?: true
    out_for_delivery_time?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    meal_type?: true
    delivery_date?: true
    order_date?: true
    delivery_status?: true
    status?: true
    out_for_delivery_time?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string | null
    meal_type: string | null
    delivery_date: string | null
    order_date: string | null
    delivery_status: string | null
    status: string
    out_for_delivery_time: string | null
    delivery_photo: string | null
    notes: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    meal_type?: boolean
    delivery_date?: boolean
    order_date?: boolean
    delivery_status?: boolean
    status?: boolean
    out_for_delivery_time?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    customerRef?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    meal_type?: boolean
    delivery_date?: boolean
    order_date?: boolean
    delivery_status?: boolean
    status?: boolean
    out_for_delivery_time?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    customerRef?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    meal_type?: boolean
    delivery_date?: boolean
    order_date?: boolean
    delivery_status?: boolean
    status?: boolean
    out_for_delivery_time?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    customerRef?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    customerRef?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      customerRef: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string | null
      meal_type: string | null
      delivery_date: string | null
      order_date: string | null
      delivery_status: string | null
      status: string
      out_for_delivery_time: string | null
      delivery_photo: string | null
      notes: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customerRef<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly customer_id: FieldRef<"Order", 'String'>
    readonly customer_name: FieldRef<"Order", 'String'>
    readonly meal_type: FieldRef<"Order", 'String'>
    readonly delivery_date: FieldRef<"Order", 'String'>
    readonly order_date: FieldRef<"Order", 'String'>
    readonly delivery_status: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly out_for_delivery_time: FieldRef<"Order", 'String'>
    readonly delivery_photo: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly created_by: FieldRef<"Order", 'String'>
    readonly created_at: FieldRef<"Order", 'DateTime'>
    readonly updated_at: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    price: number | null
  }

  export type MenuItemSumAggregateOutputType = {
    price: number | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    category: string | null
    image_url: string | null
    meal_type: string | null
    is_active: boolean | null
    day_of_week: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    category: string | null
    image_url: string | null
    meal_type: string | null
    is_active: boolean | null
    day_of_week: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    category: number
    image_url: number
    meal_type: number
    is_active: number
    day_of_week: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    price?: true
  }

  export type MenuItemSumAggregateInputType = {
    price?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    image_url?: true
    meal_type?: true
    is_active?: true
    day_of_week?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    image_url?: true
    meal_type?: true
    is_active?: true
    day_of_week?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    image_url?: true
    meal_type?: true
    is_active?: true
    day_of_week?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number | null
    category: string | null
    image_url: string | null
    meal_type: string | null
    is_active: boolean
    day_of_week: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    image_url?: boolean
    meal_type?: boolean
    is_active?: boolean
    day_of_week?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    image_url?: boolean
    meal_type?: boolean
    is_active?: boolean
    day_of_week?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    image_url?: boolean
    meal_type?: boolean
    is_active?: boolean
    day_of_week?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number | null
      category: string | null
      image_url: string | null
      meal_type: string | null
      is_active: boolean
      day_of_week: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */ 
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'String'>
    readonly name: FieldRef<"MenuItem", 'String'>
    readonly description: FieldRef<"MenuItem", 'String'>
    readonly price: FieldRef<"MenuItem", 'Float'>
    readonly category: FieldRef<"MenuItem", 'String'>
    readonly image_url: FieldRef<"MenuItem", 'String'>
    readonly meal_type: FieldRef<"MenuItem", 'String'>
    readonly is_active: FieldRef<"MenuItem", 'Boolean'>
    readonly day_of_week: FieldRef<"MenuItem", 'String'>
    readonly created_by: FieldRef<"MenuItem", 'String'>
    readonly created_at: FieldRef<"MenuItem", 'DateTime'>
    readonly updated_at: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model TiffinSkip
   */

  export type AggregateTiffinSkip = {
    _count: TiffinSkipCountAggregateOutputType | null
    _min: TiffinSkipMinAggregateOutputType | null
    _max: TiffinSkipMaxAggregateOutputType | null
  }

  export type TiffinSkipMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    skip_date: string | null
    meal_type: string | null
    reason: string | null
    status: string | null
    carry_forward_applied: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TiffinSkipMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    skip_date: string | null
    meal_type: string | null
    reason: string | null
    status: string | null
    carry_forward_applied: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TiffinSkipCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    skip_date: number
    meal_type: number
    reason: number
    status: number
    carry_forward_applied: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TiffinSkipMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    skip_date?: true
    meal_type?: true
    reason?: true
    status?: true
    carry_forward_applied?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TiffinSkipMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    skip_date?: true
    meal_type?: true
    reason?: true
    status?: true
    carry_forward_applied?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TiffinSkipCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    skip_date?: true
    meal_type?: true
    reason?: true
    status?: true
    carry_forward_applied?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TiffinSkipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiffinSkip to aggregate.
     */
    where?: TiffinSkipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiffinSkips to fetch.
     */
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TiffinSkipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiffinSkips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiffinSkips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TiffinSkips
    **/
    _count?: true | TiffinSkipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiffinSkipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiffinSkipMaxAggregateInputType
  }

  export type GetTiffinSkipAggregateType<T extends TiffinSkipAggregateArgs> = {
        [P in keyof T & keyof AggregateTiffinSkip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiffinSkip[P]>
      : GetScalarType<T[P], AggregateTiffinSkip[P]>
  }




  export type TiffinSkipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiffinSkipWhereInput
    orderBy?: TiffinSkipOrderByWithAggregationInput | TiffinSkipOrderByWithAggregationInput[]
    by: TiffinSkipScalarFieldEnum[] | TiffinSkipScalarFieldEnum
    having?: TiffinSkipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiffinSkipCountAggregateInputType | true
    _min?: TiffinSkipMinAggregateInputType
    _max?: TiffinSkipMaxAggregateInputType
  }

  export type TiffinSkipGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string | null
    skip_date: string
    meal_type: string | null
    reason: string | null
    status: string
    carry_forward_applied: boolean
    created_by: string
    created_at: Date
    updated_at: Date
    _count: TiffinSkipCountAggregateOutputType | null
    _min: TiffinSkipMinAggregateOutputType | null
    _max: TiffinSkipMaxAggregateOutputType | null
  }

  type GetTiffinSkipGroupByPayload<T extends TiffinSkipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiffinSkipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiffinSkipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiffinSkipGroupByOutputType[P]>
            : GetScalarType<T[P], TiffinSkipGroupByOutputType[P]>
        }
      >
    >


  export type TiffinSkipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    skip_date?: boolean
    meal_type?: boolean
    reason?: boolean
    status?: boolean
    carry_forward_applied?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiffinSkip"]>

  export type TiffinSkipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    skip_date?: boolean
    meal_type?: boolean
    reason?: boolean
    status?: boolean
    carry_forward_applied?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiffinSkip"]>

  export type TiffinSkipSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    skip_date?: boolean
    meal_type?: boolean
    reason?: boolean
    status?: boolean
    carry_forward_applied?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TiffinSkipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TiffinSkipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TiffinSkipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TiffinSkip"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string | null
      skip_date: string
      meal_type: string | null
      reason: string | null
      status: string
      carry_forward_applied: boolean
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tiffinSkip"]>
    composites: {}
  }

  type TiffinSkipGetPayload<S extends boolean | null | undefined | TiffinSkipDefaultArgs> = $Result.GetResult<Prisma.$TiffinSkipPayload, S>

  type TiffinSkipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TiffinSkipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TiffinSkipCountAggregateInputType | true
    }

  export interface TiffinSkipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TiffinSkip'], meta: { name: 'TiffinSkip' } }
    /**
     * Find zero or one TiffinSkip that matches the filter.
     * @param {TiffinSkipFindUniqueArgs} args - Arguments to find a TiffinSkip
     * @example
     * // Get one TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TiffinSkipFindUniqueArgs>(args: SelectSubset<T, TiffinSkipFindUniqueArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TiffinSkip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TiffinSkipFindUniqueOrThrowArgs} args - Arguments to find a TiffinSkip
     * @example
     * // Get one TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TiffinSkipFindUniqueOrThrowArgs>(args: SelectSubset<T, TiffinSkipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TiffinSkip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipFindFirstArgs} args - Arguments to find a TiffinSkip
     * @example
     * // Get one TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TiffinSkipFindFirstArgs>(args?: SelectSubset<T, TiffinSkipFindFirstArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TiffinSkip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipFindFirstOrThrowArgs} args - Arguments to find a TiffinSkip
     * @example
     * // Get one TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TiffinSkipFindFirstOrThrowArgs>(args?: SelectSubset<T, TiffinSkipFindFirstOrThrowArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TiffinSkips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TiffinSkips
     * const tiffinSkips = await prisma.tiffinSkip.findMany()
     * 
     * // Get first 10 TiffinSkips
     * const tiffinSkips = await prisma.tiffinSkip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tiffinSkipWithIdOnly = await prisma.tiffinSkip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TiffinSkipFindManyArgs>(args?: SelectSubset<T, TiffinSkipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TiffinSkip.
     * @param {TiffinSkipCreateArgs} args - Arguments to create a TiffinSkip.
     * @example
     * // Create one TiffinSkip
     * const TiffinSkip = await prisma.tiffinSkip.create({
     *   data: {
     *     // ... data to create a TiffinSkip
     *   }
     * })
     * 
     */
    create<T extends TiffinSkipCreateArgs>(args: SelectSubset<T, TiffinSkipCreateArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TiffinSkips.
     * @param {TiffinSkipCreateManyArgs} args - Arguments to create many TiffinSkips.
     * @example
     * // Create many TiffinSkips
     * const tiffinSkip = await prisma.tiffinSkip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TiffinSkipCreateManyArgs>(args?: SelectSubset<T, TiffinSkipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TiffinSkips and returns the data saved in the database.
     * @param {TiffinSkipCreateManyAndReturnArgs} args - Arguments to create many TiffinSkips.
     * @example
     * // Create many TiffinSkips
     * const tiffinSkip = await prisma.tiffinSkip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TiffinSkips and only return the `id`
     * const tiffinSkipWithIdOnly = await prisma.tiffinSkip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TiffinSkipCreateManyAndReturnArgs>(args?: SelectSubset<T, TiffinSkipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TiffinSkip.
     * @param {TiffinSkipDeleteArgs} args - Arguments to delete one TiffinSkip.
     * @example
     * // Delete one TiffinSkip
     * const TiffinSkip = await prisma.tiffinSkip.delete({
     *   where: {
     *     // ... filter to delete one TiffinSkip
     *   }
     * })
     * 
     */
    delete<T extends TiffinSkipDeleteArgs>(args: SelectSubset<T, TiffinSkipDeleteArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TiffinSkip.
     * @param {TiffinSkipUpdateArgs} args - Arguments to update one TiffinSkip.
     * @example
     * // Update one TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TiffinSkipUpdateArgs>(args: SelectSubset<T, TiffinSkipUpdateArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TiffinSkips.
     * @param {TiffinSkipDeleteManyArgs} args - Arguments to filter TiffinSkips to delete.
     * @example
     * // Delete a few TiffinSkips
     * const { count } = await prisma.tiffinSkip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TiffinSkipDeleteManyArgs>(args?: SelectSubset<T, TiffinSkipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TiffinSkips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TiffinSkips
     * const tiffinSkip = await prisma.tiffinSkip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TiffinSkipUpdateManyArgs>(args: SelectSubset<T, TiffinSkipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TiffinSkip.
     * @param {TiffinSkipUpsertArgs} args - Arguments to update or create a TiffinSkip.
     * @example
     * // Update or create a TiffinSkip
     * const tiffinSkip = await prisma.tiffinSkip.upsert({
     *   create: {
     *     // ... data to create a TiffinSkip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TiffinSkip we want to update
     *   }
     * })
     */
    upsert<T extends TiffinSkipUpsertArgs>(args: SelectSubset<T, TiffinSkipUpsertArgs<ExtArgs>>): Prisma__TiffinSkipClient<$Result.GetResult<Prisma.$TiffinSkipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TiffinSkips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipCountArgs} args - Arguments to filter TiffinSkips to count.
     * @example
     * // Count the number of TiffinSkips
     * const count = await prisma.tiffinSkip.count({
     *   where: {
     *     // ... the filter for the TiffinSkips we want to count
     *   }
     * })
    **/
    count<T extends TiffinSkipCountArgs>(
      args?: Subset<T, TiffinSkipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiffinSkipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TiffinSkip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiffinSkipAggregateArgs>(args: Subset<T, TiffinSkipAggregateArgs>): Prisma.PrismaPromise<GetTiffinSkipAggregateType<T>>

    /**
     * Group by TiffinSkip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiffinSkipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TiffinSkipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TiffinSkipGroupByArgs['orderBy'] }
        : { orderBy?: TiffinSkipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TiffinSkipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiffinSkipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TiffinSkip model
   */
  readonly fields: TiffinSkipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TiffinSkip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TiffinSkipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TiffinSkip model
   */ 
  interface TiffinSkipFieldRefs {
    readonly id: FieldRef<"TiffinSkip", 'String'>
    readonly customer_id: FieldRef<"TiffinSkip", 'String'>
    readonly customer_name: FieldRef<"TiffinSkip", 'String'>
    readonly skip_date: FieldRef<"TiffinSkip", 'String'>
    readonly meal_type: FieldRef<"TiffinSkip", 'String'>
    readonly reason: FieldRef<"TiffinSkip", 'String'>
    readonly status: FieldRef<"TiffinSkip", 'String'>
    readonly carry_forward_applied: FieldRef<"TiffinSkip", 'Boolean'>
    readonly created_by: FieldRef<"TiffinSkip", 'String'>
    readonly created_at: FieldRef<"TiffinSkip", 'DateTime'>
    readonly updated_at: FieldRef<"TiffinSkip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TiffinSkip findUnique
   */
  export type TiffinSkipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter, which TiffinSkip to fetch.
     */
    where: TiffinSkipWhereUniqueInput
  }

  /**
   * TiffinSkip findUniqueOrThrow
   */
  export type TiffinSkipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter, which TiffinSkip to fetch.
     */
    where: TiffinSkipWhereUniqueInput
  }

  /**
   * TiffinSkip findFirst
   */
  export type TiffinSkipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter, which TiffinSkip to fetch.
     */
    where?: TiffinSkipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiffinSkips to fetch.
     */
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiffinSkips.
     */
    cursor?: TiffinSkipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiffinSkips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiffinSkips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiffinSkips.
     */
    distinct?: TiffinSkipScalarFieldEnum | TiffinSkipScalarFieldEnum[]
  }

  /**
   * TiffinSkip findFirstOrThrow
   */
  export type TiffinSkipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter, which TiffinSkip to fetch.
     */
    where?: TiffinSkipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiffinSkips to fetch.
     */
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiffinSkips.
     */
    cursor?: TiffinSkipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiffinSkips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiffinSkips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiffinSkips.
     */
    distinct?: TiffinSkipScalarFieldEnum | TiffinSkipScalarFieldEnum[]
  }

  /**
   * TiffinSkip findMany
   */
  export type TiffinSkipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter, which TiffinSkips to fetch.
     */
    where?: TiffinSkipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiffinSkips to fetch.
     */
    orderBy?: TiffinSkipOrderByWithRelationInput | TiffinSkipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TiffinSkips.
     */
    cursor?: TiffinSkipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiffinSkips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiffinSkips.
     */
    skip?: number
    distinct?: TiffinSkipScalarFieldEnum | TiffinSkipScalarFieldEnum[]
  }

  /**
   * TiffinSkip create
   */
  export type TiffinSkipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * The data needed to create a TiffinSkip.
     */
    data: XOR<TiffinSkipCreateInput, TiffinSkipUncheckedCreateInput>
  }

  /**
   * TiffinSkip createMany
   */
  export type TiffinSkipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TiffinSkips.
     */
    data: TiffinSkipCreateManyInput | TiffinSkipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TiffinSkip createManyAndReturn
   */
  export type TiffinSkipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TiffinSkips.
     */
    data: TiffinSkipCreateManyInput | TiffinSkipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TiffinSkip update
   */
  export type TiffinSkipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * The data needed to update a TiffinSkip.
     */
    data: XOR<TiffinSkipUpdateInput, TiffinSkipUncheckedUpdateInput>
    /**
     * Choose, which TiffinSkip to update.
     */
    where: TiffinSkipWhereUniqueInput
  }

  /**
   * TiffinSkip updateMany
   */
  export type TiffinSkipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TiffinSkips.
     */
    data: XOR<TiffinSkipUpdateManyMutationInput, TiffinSkipUncheckedUpdateManyInput>
    /**
     * Filter which TiffinSkips to update
     */
    where?: TiffinSkipWhereInput
  }

  /**
   * TiffinSkip upsert
   */
  export type TiffinSkipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * The filter to search for the TiffinSkip to update in case it exists.
     */
    where: TiffinSkipWhereUniqueInput
    /**
     * In case the TiffinSkip found by the `where` argument doesn't exist, create a new TiffinSkip with this data.
     */
    create: XOR<TiffinSkipCreateInput, TiffinSkipUncheckedCreateInput>
    /**
     * In case the TiffinSkip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TiffinSkipUpdateInput, TiffinSkipUncheckedUpdateInput>
  }

  /**
   * TiffinSkip delete
   */
  export type TiffinSkipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
    /**
     * Filter which TiffinSkip to delete.
     */
    where: TiffinSkipWhereUniqueInput
  }

  /**
   * TiffinSkip deleteMany
   */
  export type TiffinSkipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiffinSkips to delete
     */
    where?: TiffinSkipWhereInput
  }

  /**
   * TiffinSkip without action
   */
  export type TiffinSkipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiffinSkip
     */
    select?: TiffinSkipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiffinSkipInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    days_left: number | null
    amount_to_collect: number | null
  }

  export type NotificationSumAggregateOutputType = {
    days_left: number | null
    amount_to_collect: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    user_email: string | null
    title: string | null
    message: string | null
    read: boolean | null
    is_read: boolean | null
    type: string | null
    notification_type: string | null
    customer_id: string | null
    customer_name: string | null
    days_left: number | null
    amount_to_collect: number | null
    phone_number: string | null
    email_sent: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    user_email: string | null
    title: string | null
    message: string | null
    read: boolean | null
    is_read: boolean | null
    type: string | null
    notification_type: string | null
    customer_id: string | null
    customer_name: string | null
    days_left: number | null
    amount_to_collect: number | null
    phone_number: string | null
    email_sent: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    user_email: number
    title: number
    message: number
    read: number
    is_read: number
    type: number
    notification_type: number
    customer_id: number
    customer_name: number
    days_left: number
    amount_to_collect: number
    phone_number: number
    email_sent: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    days_left?: true
    amount_to_collect?: true
  }

  export type NotificationSumAggregateInputType = {
    days_left?: true
    amount_to_collect?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    user_email?: true
    title?: true
    message?: true
    read?: true
    is_read?: true
    type?: true
    notification_type?: true
    customer_id?: true
    customer_name?: true
    days_left?: true
    amount_to_collect?: true
    phone_number?: true
    email_sent?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    user_email?: true
    title?: true
    message?: true
    read?: true
    is_read?: true
    type?: true
    notification_type?: true
    customer_id?: true
    customer_name?: true
    days_left?: true
    amount_to_collect?: true
    phone_number?: true
    email_sent?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    user_email?: true
    title?: true
    message?: true
    read?: true
    is_read?: true
    type?: true
    notification_type?: true
    customer_id?: true
    customer_name?: true
    days_left?: true
    amount_to_collect?: true
    phone_number?: true
    email_sent?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    user_email: string
    title: string
    message: string | null
    read: boolean
    is_read: boolean
    type: string | null
    notification_type: string | null
    customer_id: string | null
    customer_name: string | null
    days_left: number | null
    amount_to_collect: number | null
    phone_number: string | null
    email_sent: boolean | null
    created_at: Date
    updated_at: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    is_read?: boolean
    type?: boolean
    notification_type?: boolean
    customer_id?: boolean
    customer_name?: boolean
    days_left?: boolean
    amount_to_collect?: boolean
    phone_number?: boolean
    email_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    is_read?: boolean
    type?: boolean
    notification_type?: boolean
    customer_id?: boolean
    customer_name?: boolean
    days_left?: boolean
    amount_to_collect?: boolean
    phone_number?: boolean
    email_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    user_email?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    is_read?: boolean
    type?: boolean
    notification_type?: boolean
    customer_id?: boolean
    customer_name?: boolean
    days_left?: boolean
    amount_to_collect?: boolean
    phone_number?: boolean
    email_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_email: string
      title: string
      message: string | null
      read: boolean
      is_read: boolean
      type: string | null
      notification_type: string | null
      customer_id: string | null
      customer_name: string | null
      days_left: number | null
      amount_to_collect: number | null
      phone_number: string | null
      email_sent: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly user_email: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly notification_type: FieldRef<"Notification", 'String'>
    readonly customer_id: FieldRef<"Notification", 'String'>
    readonly customer_name: FieldRef<"Notification", 'String'>
    readonly days_left: FieldRef<"Notification", 'Int'>
    readonly amount_to_collect: FieldRef<"Notification", 'Float'>
    readonly phone_number: FieldRef<"Notification", 'String'>
    readonly email_sent: FieldRef<"Notification", 'Boolean'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
    readonly updated_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    user_email: string | null
    user_name: string | null
    action_type: string | null
    entity_type: string | null
    entity_id: string | null
    description: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    user_email: string | null
    user_name: string | null
    action_type: string | null
    entity_type: string | null
    entity_id: string | null
    description: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    user_email: number
    user_name: number
    action_type: number
    entity_type: number
    entity_id: number
    description: number
    metadata: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    description?: true
    created_by?: true
    created_at?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    description?: true
    created_by?: true
    created_at?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    description?: true
    metadata?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    user_email: string
    user_name: string | null
    action_type: string
    entity_type: string | null
    entity_id: string | null
    description: string | null
    metadata: JsonValue | null
    created_by: string
    created_at: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    user_name?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    description?: boolean
    metadata?: boolean
    created_by?: boolean
    created_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    user_name?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    description?: boolean
    metadata?: boolean
    created_by?: boolean
    created_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    user_email?: boolean
    user_name?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    description?: boolean
    metadata?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_email: string
      user_name: string | null
      action_type: string
      entity_type: string | null
      entity_id: string | null
      description: string | null
      metadata: Prisma.JsonValue | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly user_email: FieldRef<"ActivityLog", 'String'>
    readonly user_name: FieldRef<"ActivityLog", 'String'>
    readonly action_type: FieldRef<"ActivityLog", 'String'>
    readonly entity_type: FieldRef<"ActivityLog", 'String'>
    readonly entity_id: FieldRef<"ActivityLog", 'String'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly metadata: FieldRef<"ActivityLog", 'Json'>
    readonly created_by: FieldRef<"ActivityLog", 'String'>
    readonly created_at: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Ingredient
   */

  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientAvgAggregateOutputType = {
    current_stock: number | null
    min_stock_threshold: number | null
    cost_per_unit: number | null
    total_value: number | null
  }

  export type IngredientSumAggregateOutputType = {
    current_stock: number | null
    min_stock_threshold: number | null
    cost_per_unit: number | null
    total_value: number | null
  }

  export type IngredientMinAggregateOutputType = {
    id: string | null
    name: string | null
    unit: string | null
    current_stock: number | null
    min_stock_threshold: number | null
    cost_per_unit: number | null
    total_value: number | null
    is_critical: boolean | null
    last_purchase_date: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    unit: string | null
    current_stock: number | null
    min_stock_threshold: number | null
    cost_per_unit: number | null
    total_value: number | null
    is_critical: boolean | null
    last_purchase_date: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    name: number
    unit: number
    current_stock: number
    min_stock_threshold: number
    cost_per_unit: number
    total_value: number
    is_critical: number
    last_purchase_date: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type IngredientAvgAggregateInputType = {
    current_stock?: true
    min_stock_threshold?: true
    cost_per_unit?: true
    total_value?: true
  }

  export type IngredientSumAggregateInputType = {
    current_stock?: true
    min_stock_threshold?: true
    cost_per_unit?: true
    total_value?: true
  }

  export type IngredientMinAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    current_stock?: true
    min_stock_threshold?: true
    cost_per_unit?: true
    total_value?: true
    is_critical?: true
    last_purchase_date?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    current_stock?: true
    min_stock_threshold?: true
    cost_per_unit?: true
    total_value?: true
    is_critical?: true
    last_purchase_date?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    name?: true
    unit?: true
    current_stock?: true
    min_stock_threshold?: true
    cost_per_unit?: true
    total_value?: true
    is_critical?: true
    last_purchase_date?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type IngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredient to aggregate.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithAggregationInput | IngredientOrderByWithAggregationInput[]
    by: IngredientScalarFieldEnum[] | IngredientScalarFieldEnum
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _avg?: IngredientAvgAggregateInputType
    _sum?: IngredientSumAggregateInputType
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }

  export type IngredientGroupByOutputType = {
    id: string
    name: string
    unit: string | null
    current_stock: number | null
    min_stock_threshold: number | null
    cost_per_unit: number | null
    total_value: number | null
    is_critical: boolean
    last_purchase_date: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: IngredientCountAggregateOutputType | null
    _avg: IngredientAvgAggregateOutputType | null
    _sum: IngredientSumAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock_threshold?: boolean
    cost_per_unit?: boolean
    total_value?: boolean
    is_critical?: boolean
    last_purchase_date?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    wastages?: boolean | Ingredient$wastagesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredient"]>

  export type IngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock_threshold?: boolean
    cost_per_unit?: boolean
    total_value?: boolean
    is_critical?: boolean
    last_purchase_date?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredient"]>

  export type IngredientSelectScalar = {
    id?: boolean
    name?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock_threshold?: boolean
    cost_per_unit?: boolean
    total_value?: boolean
    is_critical?: boolean
    last_purchase_date?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type IngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    wastages?: boolean | Ingredient$wastagesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingredient"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      wastages: Prisma.$WastagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      unit: string | null
      current_stock: number | null
      min_stock_threshold: number | null
      cost_per_unit: number | null
      total_value: number | null
      is_critical: boolean
      last_purchase_date: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ingredient"]>
    composites: {}
  }

  type IngredientGetPayload<S extends boolean | null | undefined | IngredientDefaultArgs> = $Result.GetResult<Prisma.$IngredientPayload, S>

  type IngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngredientCountAggregateInputType | true
    }

  export interface IngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingredient'], meta: { name: 'Ingredient' } }
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngredientFindUniqueArgs>(args: SelectSubset<T, IngredientFindUniqueArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ingredient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, IngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngredientFindFirstArgs>(args?: SelectSubset<T, IngredientFindFirstArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, IngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngredientFindManyArgs>(args?: SelectSubset<T, IngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
     */
    create<T extends IngredientCreateArgs>(args: SelectSubset<T, IngredientCreateArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ingredients.
     * @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
     * @example
     * // Create many Ingredients
     * const ingredient = await prisma.ingredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngredientCreateManyArgs>(args?: SelectSubset<T, IngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ingredients and returns the data saved in the database.
     * @param {IngredientCreateManyAndReturnArgs} args - Arguments to create many Ingredients.
     * @example
     * // Create many Ingredients
     * const ingredient = await prisma.ingredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ingredients and only return the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, IngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
     */
    delete<T extends IngredientDeleteArgs>(args: SelectSubset<T, IngredientDeleteArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngredientUpdateArgs>(args: SelectSubset<T, IngredientUpdateArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngredientDeleteManyArgs>(args?: SelectSubset<T, IngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngredientUpdateManyArgs>(args: SelectSubset<T, IngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
     */
    upsert<T extends IngredientUpsertArgs>(args: SelectSubset<T, IngredientUpsertArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingredient model
   */
  readonly fields: IngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wastages<T extends Ingredient$wastagesArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$wastagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ingredient model
   */ 
  interface IngredientFieldRefs {
    readonly id: FieldRef<"Ingredient", 'String'>
    readonly name: FieldRef<"Ingredient", 'String'>
    readonly unit: FieldRef<"Ingredient", 'String'>
    readonly current_stock: FieldRef<"Ingredient", 'Float'>
    readonly min_stock_threshold: FieldRef<"Ingredient", 'Float'>
    readonly cost_per_unit: FieldRef<"Ingredient", 'Float'>
    readonly total_value: FieldRef<"Ingredient", 'Float'>
    readonly is_critical: FieldRef<"Ingredient", 'Boolean'>
    readonly last_purchase_date: FieldRef<"Ingredient", 'String'>
    readonly created_by: FieldRef<"Ingredient", 'String'>
    readonly created_at: FieldRef<"Ingredient", 'DateTime'>
    readonly updated_at: FieldRef<"Ingredient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ingredient findUnique
   */
  export type IngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient findFirst
   */
  export type IngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }

  /**
   * Ingredient findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }

  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredients to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }

  /**
   * Ingredient create
   */
  export type IngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingredient.
     */
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }

  /**
   * Ingredient createMany
   */
  export type IngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ingredients.
     */
    data: IngredientCreateManyInput | IngredientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ingredient createManyAndReturn
   */
  export type IngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ingredients.
     */
    data: IngredientCreateManyInput | IngredientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingredient.
     */
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     */
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingredients.
     */
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     */
    where?: IngredientWhereInput
  }

  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     */
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     */
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }

  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter which Ingredient to delete.
     */
    where: IngredientWhereUniqueInput
  }

  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredients to delete
     */
    where?: IngredientWhereInput
  }

  /**
   * Ingredient.wastages
   */
  export type Ingredient$wastagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    where?: WastageWhereInput
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    cursor?: WastageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WastageScalarFieldEnum | WastageScalarFieldEnum[]
  }

  /**
   * Ingredient without action
   */
  export type IngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngredientInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    total_cost: number | null
    cost_per_serving: number | null
  }

  export type RecipeSumAggregateOutputType = {
    total_cost: number | null
    cost_per_serving: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    meal_type: string | null
    is_active: boolean | null
    total_cost: number | null
    cost_per_serving: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    meal_type: string | null
    is_active: boolean | null
    total_cost: number | null
    cost_per_serving: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    meal_type: number
    ingredients: number
    is_active: number
    total_cost: number
    cost_per_serving: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    total_cost?: true
    cost_per_serving?: true
  }

  export type RecipeSumAggregateInputType = {
    total_cost?: true
    cost_per_serving?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    meal_type?: true
    is_active?: true
    total_cost?: true
    cost_per_serving?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    meal_type?: true
    is_active?: true
    total_cost?: true
    cost_per_serving?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    meal_type?: true
    ingredients?: true
    is_active?: true
    total_cost?: true
    cost_per_serving?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    meal_type: string | null
    ingredients: JsonValue | null
    is_active: boolean
    total_cost: number | null
    cost_per_serving: number | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    meal_type?: boolean
    ingredients?: boolean
    is_active?: boolean
    total_cost?: boolean
    cost_per_serving?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    meal_type?: boolean
    ingredients?: boolean
    is_active?: boolean
    total_cost?: boolean
    cost_per_serving?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    meal_type?: boolean
    ingredients?: boolean
    is_active?: boolean
    total_cost?: boolean
    cost_per_serving?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      meal_type: string | null
      ingredients: Prisma.JsonValue | null
      is_active: boolean
      total_cost: number | null
      cost_per_serving: number | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly meal_type: FieldRef<"Recipe", 'String'>
    readonly ingredients: FieldRef<"Recipe", 'Json'>
    readonly is_active: FieldRef<"Recipe", 'Boolean'>
    readonly total_cost: FieldRef<"Recipe", 'Float'>
    readonly cost_per_serving: FieldRef<"Recipe", 'Float'>
    readonly created_by: FieldRef<"Recipe", 'String'>
    readonly created_at: FieldRef<"Recipe", 'DateTime'>
    readonly updated_at: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    address: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    email: string | null
    address: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      email: string | null
      address: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly created_by: FieldRef<"Supplier", 'String'>
    readonly created_at: FieldRef<"Supplier", 'DateTime'>
    readonly updated_at: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    quantity: number | null
    cost_per_unit: number | null
    total_cost: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    quantity: number | null
    cost_per_unit: number | null
    total_cost: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    ingredient_id: string | null
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    cost_per_unit: number | null
    total_cost: number | null
    supplier_id: string | null
    supplier_name: string | null
    purchase_date: string | null
    expiry_date: string | null
    bill_image_url: string | null
    notes: string | null
    is_deleted: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    ingredient_id: string | null
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    cost_per_unit: number | null
    total_cost: number | null
    supplier_id: string | null
    supplier_name: string | null
    purchase_date: string | null
    expiry_date: string | null
    bill_image_url: string | null
    notes: string | null
    is_deleted: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    ingredient_id: number
    ingredient_name: number
    quantity: number
    unit: number
    cost_per_unit: number
    total_cost: number
    supplier_id: number
    supplier_name: number
    purchase_date: number
    expiry_date: number
    bill_image_url: number
    notes: number
    is_deleted: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    quantity?: true
    cost_per_unit?: true
    total_cost?: true
  }

  export type PurchaseSumAggregateInputType = {
    quantity?: true
    cost_per_unit?: true
    total_cost?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    cost_per_unit?: true
    total_cost?: true
    supplier_id?: true
    supplier_name?: true
    purchase_date?: true
    expiry_date?: true
    bill_image_url?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    cost_per_unit?: true
    total_cost?: true
    supplier_id?: true
    supplier_name?: true
    purchase_date?: true
    expiry_date?: true
    bill_image_url?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    cost_per_unit?: true
    total_cost?: true
    supplier_id?: true
    supplier_name?: true
    purchase_date?: true
    expiry_date?: true
    bill_image_url?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    ingredient_id: string | null
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    cost_per_unit: number | null
    total_cost: number | null
    supplier_id: string | null
    supplier_name: string | null
    purchase_date: string | null
    expiry_date: string | null
    bill_image_url: string | null
    notes: string | null
    is_deleted: boolean
    created_by: string
    created_at: Date
    updated_at: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    cost_per_unit?: boolean
    total_cost?: boolean
    supplier_id?: boolean
    supplier_name?: boolean
    purchase_date?: boolean
    expiry_date?: boolean
    bill_image_url?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    cost_per_unit?: boolean
    total_cost?: boolean
    supplier_id?: boolean
    supplier_name?: boolean
    purchase_date?: boolean
    expiry_date?: boolean
    bill_image_url?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    cost_per_unit?: boolean
    total_cost?: boolean
    supplier_id?: boolean
    supplier_name?: boolean
    purchase_date?: boolean
    expiry_date?: boolean
    bill_image_url?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ingredient_id: string | null
      ingredient_name: string | null
      quantity: number | null
      unit: string | null
      cost_per_unit: number | null
      total_cost: number | null
      supplier_id: string | null
      supplier_name: string | null
      purchase_date: string | null
      expiry_date: string | null
      bill_image_url: string | null
      notes: string | null
      is_deleted: boolean
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly ingredient_id: FieldRef<"Purchase", 'String'>
    readonly ingredient_name: FieldRef<"Purchase", 'String'>
    readonly quantity: FieldRef<"Purchase", 'Float'>
    readonly unit: FieldRef<"Purchase", 'String'>
    readonly cost_per_unit: FieldRef<"Purchase", 'Float'>
    readonly total_cost: FieldRef<"Purchase", 'Float'>
    readonly supplier_id: FieldRef<"Purchase", 'String'>
    readonly supplier_name: FieldRef<"Purchase", 'String'>
    readonly purchase_date: FieldRef<"Purchase", 'String'>
    readonly expiry_date: FieldRef<"Purchase", 'String'>
    readonly bill_image_url: FieldRef<"Purchase", 'String'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly is_deleted: FieldRef<"Purchase", 'Boolean'>
    readonly created_by: FieldRef<"Purchase", 'String'>
    readonly created_at: FieldRef<"Purchase", 'DateTime'>
    readonly updated_at: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model Wastage
   */

  export type AggregateWastage = {
    _count: WastageCountAggregateOutputType | null
    _avg: WastageAvgAggregateOutputType | null
    _sum: WastageSumAggregateOutputType | null
    _min: WastageMinAggregateOutputType | null
    _max: WastageMaxAggregateOutputType | null
  }

  export type WastageAvgAggregateOutputType = {
    quantity: number | null
    cost_value: number | null
  }

  export type WastageSumAggregateOutputType = {
    quantity: number | null
    cost_value: number | null
  }

  export type WastageMinAggregateOutputType = {
    id: string | null
    ingredient_id: string | null
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    reason: string | null
    cost_value: number | null
    wastage_date: string | null
    notes: string | null
    is_deleted: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WastageMaxAggregateOutputType = {
    id: string | null
    ingredient_id: string | null
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    reason: string | null
    cost_value: number | null
    wastage_date: string | null
    notes: string | null
    is_deleted: boolean | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WastageCountAggregateOutputType = {
    id: number
    ingredient_id: number
    ingredient_name: number
    quantity: number
    unit: number
    reason: number
    cost_value: number
    wastage_date: number
    notes: number
    is_deleted: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WastageAvgAggregateInputType = {
    quantity?: true
    cost_value?: true
  }

  export type WastageSumAggregateInputType = {
    quantity?: true
    cost_value?: true
  }

  export type WastageMinAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    reason?: true
    cost_value?: true
    wastage_date?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type WastageMaxAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    reason?: true
    cost_value?: true
    wastage_date?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type WastageCountAggregateInputType = {
    id?: true
    ingredient_id?: true
    ingredient_name?: true
    quantity?: true
    unit?: true
    reason?: true
    cost_value?: true
    wastage_date?: true
    notes?: true
    is_deleted?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WastageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wastage to aggregate.
     */
    where?: WastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wastages to fetch.
     */
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wastages
    **/
    _count?: true | WastageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WastageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WastageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WastageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WastageMaxAggregateInputType
  }

  export type GetWastageAggregateType<T extends WastageAggregateArgs> = {
        [P in keyof T & keyof AggregateWastage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWastage[P]>
      : GetScalarType<T[P], AggregateWastage[P]>
  }




  export type WastageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WastageWhereInput
    orderBy?: WastageOrderByWithAggregationInput | WastageOrderByWithAggregationInput[]
    by: WastageScalarFieldEnum[] | WastageScalarFieldEnum
    having?: WastageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WastageCountAggregateInputType | true
    _avg?: WastageAvgAggregateInputType
    _sum?: WastageSumAggregateInputType
    _min?: WastageMinAggregateInputType
    _max?: WastageMaxAggregateInputType
  }

  export type WastageGroupByOutputType = {
    id: string
    ingredient_id: string
    ingredient_name: string | null
    quantity: number | null
    unit: string | null
    reason: string | null
    cost_value: number | null
    wastage_date: string | null
    notes: string | null
    is_deleted: boolean
    created_by: string
    created_at: Date
    updated_at: Date
    _count: WastageCountAggregateOutputType | null
    _avg: WastageAvgAggregateOutputType | null
    _sum: WastageSumAggregateOutputType | null
    _min: WastageMinAggregateOutputType | null
    _max: WastageMaxAggregateOutputType | null
  }

  type GetWastageGroupByPayload<T extends WastageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WastageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WastageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WastageGroupByOutputType[P]>
            : GetScalarType<T[P], WastageGroupByOutputType[P]>
        }
      >
    >


  export type WastageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    reason?: boolean
    cost_value?: boolean
    wastage_date?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wastage"]>

  export type WastageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    reason?: boolean
    cost_value?: boolean
    wastage_date?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wastage"]>

  export type WastageSelectScalar = {
    id?: boolean
    ingredient_id?: boolean
    ingredient_name?: boolean
    quantity?: boolean
    unit?: boolean
    reason?: boolean
    cost_value?: boolean
    wastage_date?: boolean
    notes?: boolean
    is_deleted?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type WastageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WastageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WastagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wastage"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ingredient_id: string
      ingredient_name: string | null
      quantity: number | null
      unit: string | null
      reason: string | null
      cost_value: number | null
      wastage_date: string | null
      notes: string | null
      is_deleted: boolean
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["wastage"]>
    composites: {}
  }

  type WastageGetPayload<S extends boolean | null | undefined | WastageDefaultArgs> = $Result.GetResult<Prisma.$WastagePayload, S>

  type WastageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WastageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WastageCountAggregateInputType | true
    }

  export interface WastageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wastage'], meta: { name: 'Wastage' } }
    /**
     * Find zero or one Wastage that matches the filter.
     * @param {WastageFindUniqueArgs} args - Arguments to find a Wastage
     * @example
     * // Get one Wastage
     * const wastage = await prisma.wastage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WastageFindUniqueArgs>(args: SelectSubset<T, WastageFindUniqueArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wastage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WastageFindUniqueOrThrowArgs} args - Arguments to find a Wastage
     * @example
     * // Get one Wastage
     * const wastage = await prisma.wastage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WastageFindUniqueOrThrowArgs>(args: SelectSubset<T, WastageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wastage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageFindFirstArgs} args - Arguments to find a Wastage
     * @example
     * // Get one Wastage
     * const wastage = await prisma.wastage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WastageFindFirstArgs>(args?: SelectSubset<T, WastageFindFirstArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wastage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageFindFirstOrThrowArgs} args - Arguments to find a Wastage
     * @example
     * // Get one Wastage
     * const wastage = await prisma.wastage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WastageFindFirstOrThrowArgs>(args?: SelectSubset<T, WastageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wastages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wastages
     * const wastages = await prisma.wastage.findMany()
     * 
     * // Get first 10 Wastages
     * const wastages = await prisma.wastage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wastageWithIdOnly = await prisma.wastage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WastageFindManyArgs>(args?: SelectSubset<T, WastageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wastage.
     * @param {WastageCreateArgs} args - Arguments to create a Wastage.
     * @example
     * // Create one Wastage
     * const Wastage = await prisma.wastage.create({
     *   data: {
     *     // ... data to create a Wastage
     *   }
     * })
     * 
     */
    create<T extends WastageCreateArgs>(args: SelectSubset<T, WastageCreateArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wastages.
     * @param {WastageCreateManyArgs} args - Arguments to create many Wastages.
     * @example
     * // Create many Wastages
     * const wastage = await prisma.wastage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WastageCreateManyArgs>(args?: SelectSubset<T, WastageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wastages and returns the data saved in the database.
     * @param {WastageCreateManyAndReturnArgs} args - Arguments to create many Wastages.
     * @example
     * // Create many Wastages
     * const wastage = await prisma.wastage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wastages and only return the `id`
     * const wastageWithIdOnly = await prisma.wastage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WastageCreateManyAndReturnArgs>(args?: SelectSubset<T, WastageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wastage.
     * @param {WastageDeleteArgs} args - Arguments to delete one Wastage.
     * @example
     * // Delete one Wastage
     * const Wastage = await prisma.wastage.delete({
     *   where: {
     *     // ... filter to delete one Wastage
     *   }
     * })
     * 
     */
    delete<T extends WastageDeleteArgs>(args: SelectSubset<T, WastageDeleteArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wastage.
     * @param {WastageUpdateArgs} args - Arguments to update one Wastage.
     * @example
     * // Update one Wastage
     * const wastage = await prisma.wastage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WastageUpdateArgs>(args: SelectSubset<T, WastageUpdateArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wastages.
     * @param {WastageDeleteManyArgs} args - Arguments to filter Wastages to delete.
     * @example
     * // Delete a few Wastages
     * const { count } = await prisma.wastage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WastageDeleteManyArgs>(args?: SelectSubset<T, WastageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wastages
     * const wastage = await prisma.wastage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WastageUpdateManyArgs>(args: SelectSubset<T, WastageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wastage.
     * @param {WastageUpsertArgs} args - Arguments to update or create a Wastage.
     * @example
     * // Update or create a Wastage
     * const wastage = await prisma.wastage.upsert({
     *   create: {
     *     // ... data to create a Wastage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wastage we want to update
     *   }
     * })
     */
    upsert<T extends WastageUpsertArgs>(args: SelectSubset<T, WastageUpsertArgs<ExtArgs>>): Prisma__WastageClient<$Result.GetResult<Prisma.$WastagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wastages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageCountArgs} args - Arguments to filter Wastages to count.
     * @example
     * // Count the number of Wastages
     * const count = await prisma.wastage.count({
     *   where: {
     *     // ... the filter for the Wastages we want to count
     *   }
     * })
    **/
    count<T extends WastageCountArgs>(
      args?: Subset<T, WastageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WastageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WastageAggregateArgs>(args: Subset<T, WastageAggregateArgs>): Prisma.PrismaPromise<GetWastageAggregateType<T>>

    /**
     * Group by Wastage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WastageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WastageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WastageGroupByArgs['orderBy'] }
        : { orderBy?: WastageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WastageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWastageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wastage model
   */
  readonly fields: WastageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wastage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WastageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wastage model
   */ 
  interface WastageFieldRefs {
    readonly id: FieldRef<"Wastage", 'String'>
    readonly ingredient_id: FieldRef<"Wastage", 'String'>
    readonly ingredient_name: FieldRef<"Wastage", 'String'>
    readonly quantity: FieldRef<"Wastage", 'Float'>
    readonly unit: FieldRef<"Wastage", 'String'>
    readonly reason: FieldRef<"Wastage", 'String'>
    readonly cost_value: FieldRef<"Wastage", 'Float'>
    readonly wastage_date: FieldRef<"Wastage", 'String'>
    readonly notes: FieldRef<"Wastage", 'String'>
    readonly is_deleted: FieldRef<"Wastage", 'Boolean'>
    readonly created_by: FieldRef<"Wastage", 'String'>
    readonly created_at: FieldRef<"Wastage", 'DateTime'>
    readonly updated_at: FieldRef<"Wastage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wastage findUnique
   */
  export type WastageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter, which Wastage to fetch.
     */
    where: WastageWhereUniqueInput
  }

  /**
   * Wastage findUniqueOrThrow
   */
  export type WastageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter, which Wastage to fetch.
     */
    where: WastageWhereUniqueInput
  }

  /**
   * Wastage findFirst
   */
  export type WastageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter, which Wastage to fetch.
     */
    where?: WastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wastages to fetch.
     */
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wastages.
     */
    cursor?: WastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wastages.
     */
    distinct?: WastageScalarFieldEnum | WastageScalarFieldEnum[]
  }

  /**
   * Wastage findFirstOrThrow
   */
  export type WastageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter, which Wastage to fetch.
     */
    where?: WastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wastages to fetch.
     */
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wastages.
     */
    cursor?: WastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wastages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wastages.
     */
    distinct?: WastageScalarFieldEnum | WastageScalarFieldEnum[]
  }

  /**
   * Wastage findMany
   */
  export type WastageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter, which Wastages to fetch.
     */
    where?: WastageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wastages to fetch.
     */
    orderBy?: WastageOrderByWithRelationInput | WastageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wastages.
     */
    cursor?: WastageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wastages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wastages.
     */
    skip?: number
    distinct?: WastageScalarFieldEnum | WastageScalarFieldEnum[]
  }

  /**
   * Wastage create
   */
  export type WastageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * The data needed to create a Wastage.
     */
    data: XOR<WastageCreateInput, WastageUncheckedCreateInput>
  }

  /**
   * Wastage createMany
   */
  export type WastageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wastages.
     */
    data: WastageCreateManyInput | WastageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wastage createManyAndReturn
   */
  export type WastageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wastages.
     */
    data: WastageCreateManyInput | WastageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wastage update
   */
  export type WastageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * The data needed to update a Wastage.
     */
    data: XOR<WastageUpdateInput, WastageUncheckedUpdateInput>
    /**
     * Choose, which Wastage to update.
     */
    where: WastageWhereUniqueInput
  }

  /**
   * Wastage updateMany
   */
  export type WastageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wastages.
     */
    data: XOR<WastageUpdateManyMutationInput, WastageUncheckedUpdateManyInput>
    /**
     * Filter which Wastages to update
     */
    where?: WastageWhereInput
  }

  /**
   * Wastage upsert
   */
  export type WastageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * The filter to search for the Wastage to update in case it exists.
     */
    where: WastageWhereUniqueInput
    /**
     * In case the Wastage found by the `where` argument doesn't exist, create a new Wastage with this data.
     */
    create: XOR<WastageCreateInput, WastageUncheckedCreateInput>
    /**
     * In case the Wastage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WastageUpdateInput, WastageUncheckedUpdateInput>
  }

  /**
   * Wastage delete
   */
  export type WastageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
    /**
     * Filter which Wastage to delete.
     */
    where: WastageWhereUniqueInput
  }

  /**
   * Wastage deleteMany
   */
  export type WastageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wastages to delete
     */
    where?: WastageWhereInput
  }

  /**
   * Wastage without action
   */
  export type WastageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wastage
     */
    select?: WastageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WastageInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    user_email: string | null
    subject: string | null
    message: string | null
    status: string | null
    priority: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    user_email: string | null
    subject: string | null
    message: string | null
    status: string | null
    priority: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    user_email: number
    subject: number
    message: number
    status: number
    priority: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    user_email?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    user_email?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    user_email?: true
    subject?: true
    message?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    user_email: string
    subject: string
    message: string | null
    status: string
    priority: string | null
    created_at: Date
    updated_at: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    user_email?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_email: string
      subject: string
      message: string | null
      status: string
      priority: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly user_email: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly created_at: FieldRef<"SupportTicket", 'DateTime'>
    readonly updated_at: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    user_email: string | null
    plan_name: string | null
    status: string | null
    subscription_start_date: Date | null
    next_billing_date: Date | null
    current_period_end: Date | null
    amount: number | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_method_last4: string | null
    payment_method_brand: string | null
    cancelled_at: Date | null
    cancel_reason: string | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    user_email: string | null
    plan_name: string | null
    status: string | null
    subscription_start_date: Date | null
    next_billing_date: Date | null
    current_period_end: Date | null
    amount: number | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_method_last4: string | null
    payment_method_brand: string | null
    cancelled_at: Date | null
    cancel_reason: string | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    user_email: number
    plan_name: number
    status: number
    subscription_start_date: number
    next_billing_date: number
    current_period_end: number
    amount: number
    stripe_customer_id: number
    stripe_subscription_id: number
    payment_method_last4: number
    payment_method_brand: number
    cancelled_at: number
    cancel_reason: number
    reminder_before_sent: number
    reminder_after_sent: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amount?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amount?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    user_email?: true
    plan_name?: true
    status?: true
    subscription_start_date?: true
    next_billing_date?: true
    current_period_end?: true
    amount?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_method_last4?: true
    payment_method_brand?: true
    cancelled_at?: true
    cancel_reason?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    user_email?: true
    plan_name?: true
    status?: true
    subscription_start_date?: true
    next_billing_date?: true
    current_period_end?: true
    amount?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_method_last4?: true
    payment_method_brand?: true
    cancelled_at?: true
    cancel_reason?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    user_email?: true
    plan_name?: true
    status?: true
    subscription_start_date?: true
    next_billing_date?: true
    current_period_end?: true
    amount?: true
    stripe_customer_id?: true
    stripe_subscription_id?: true
    payment_method_last4?: true
    payment_method_brand?: true
    cancelled_at?: true
    cancel_reason?: true
    reminder_before_sent?: true
    reminder_after_sent?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    user_email: string
    plan_name: string | null
    status: string
    subscription_start_date: Date | null
    next_billing_date: Date | null
    current_period_end: Date | null
    amount: number | null
    stripe_customer_id: string | null
    stripe_subscription_id: string | null
    payment_method_last4: string | null
    payment_method_brand: string | null
    cancelled_at: Date | null
    cancel_reason: string | null
    reminder_before_sent: boolean | null
    reminder_after_sent: boolean | null
    created_at: Date
    updated_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    plan_name?: boolean
    status?: boolean
    subscription_start_date?: boolean
    next_billing_date?: boolean
    current_period_end?: boolean
    amount?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_method_last4?: boolean
    payment_method_brand?: boolean
    cancelled_at?: boolean
    cancel_reason?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    plan_name?: boolean
    status?: boolean
    subscription_start_date?: boolean
    next_billing_date?: boolean
    current_period_end?: boolean
    amount?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_method_last4?: boolean
    payment_method_brand?: boolean
    cancelled_at?: boolean
    cancel_reason?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    user_email?: boolean
    plan_name?: boolean
    status?: boolean
    subscription_start_date?: boolean
    next_billing_date?: boolean
    current_period_end?: boolean
    amount?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_id?: boolean
    payment_method_last4?: boolean
    payment_method_brand?: boolean
    cancelled_at?: boolean
    cancel_reason?: boolean
    reminder_before_sent?: boolean
    reminder_after_sent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_email: string
      plan_name: string | null
      status: string
      subscription_start_date: Date | null
      next_billing_date: Date | null
      current_period_end: Date | null
      amount: number | null
      stripe_customer_id: string | null
      stripe_subscription_id: string | null
      payment_method_last4: string | null
      payment_method_brand: string | null
      cancelled_at: Date | null
      cancel_reason: string | null
      reminder_before_sent: boolean | null
      reminder_after_sent: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly user_email: FieldRef<"Subscription", 'String'>
    readonly plan_name: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly subscription_start_date: FieldRef<"Subscription", 'DateTime'>
    readonly next_billing_date: FieldRef<"Subscription", 'DateTime'>
    readonly current_period_end: FieldRef<"Subscription", 'DateTime'>
    readonly amount: FieldRef<"Subscription", 'Float'>
    readonly stripe_customer_id: FieldRef<"Subscription", 'String'>
    readonly stripe_subscription_id: FieldRef<"Subscription", 'String'>
    readonly payment_method_last4: FieldRef<"Subscription", 'String'>
    readonly payment_method_brand: FieldRef<"Subscription", 'String'>
    readonly cancelled_at: FieldRef<"Subscription", 'DateTime'>
    readonly cancel_reason: FieldRef<"Subscription", 'String'>
    readonly reminder_before_sent: FieldRef<"Subscription", 'Boolean'>
    readonly reminder_after_sent: FieldRef<"Subscription", 'Boolean'>
    readonly created_at: FieldRef<"Subscription", 'DateTime'>
    readonly updated_at: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
  }


  /**
   * Model PaymentHistory
   */

  export type AggregatePaymentHistory = {
    _count: PaymentHistoryCountAggregateOutputType | null
    _avg: PaymentHistoryAvgAggregateOutputType | null
    _sum: PaymentHistorySumAggregateOutputType | null
    _min: PaymentHistoryMinAggregateOutputType | null
    _max: PaymentHistoryMaxAggregateOutputType | null
  }

  export type PaymentHistoryAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentHistorySumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentHistoryMinAggregateOutputType = {
    id: string | null
    user_email: string | null
    subscription_id: string | null
    amount: number | null
    currency: string | null
    status: string | null
    payment_date: Date | null
    stripe_payment_id: string | null
    payment_method_last4: string | null
    error_message: string | null
    created_at: Date | null
  }

  export type PaymentHistoryMaxAggregateOutputType = {
    id: string | null
    user_email: string | null
    subscription_id: string | null
    amount: number | null
    currency: string | null
    status: string | null
    payment_date: Date | null
    stripe_payment_id: string | null
    payment_method_last4: string | null
    error_message: string | null
    created_at: Date | null
  }

  export type PaymentHistoryCountAggregateOutputType = {
    id: number
    user_email: number
    subscription_id: number
    amount: number
    currency: number
    status: number
    payment_date: number
    stripe_payment_id: number
    payment_method_last4: number
    error_message: number
    created_at: number
    _all: number
  }


  export type PaymentHistoryAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentHistorySumAggregateInputType = {
    amount?: true
  }

  export type PaymentHistoryMinAggregateInputType = {
    id?: true
    user_email?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    payment_date?: true
    stripe_payment_id?: true
    payment_method_last4?: true
    error_message?: true
    created_at?: true
  }

  export type PaymentHistoryMaxAggregateInputType = {
    id?: true
    user_email?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    payment_date?: true
    stripe_payment_id?: true
    payment_method_last4?: true
    error_message?: true
    created_at?: true
  }

  export type PaymentHistoryCountAggregateInputType = {
    id?: true
    user_email?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    payment_date?: true
    stripe_payment_id?: true
    payment_method_last4?: true
    error_message?: true
    created_at?: true
    _all?: true
  }

  export type PaymentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentHistory to aggregate.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentHistories
    **/
    _count?: true | PaymentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentHistoryMaxAggregateInputType
  }

  export type GetPaymentHistoryAggregateType<T extends PaymentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentHistory[P]>
      : GetScalarType<T[P], AggregatePaymentHistory[P]>
  }




  export type PaymentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentHistoryWhereInput
    orderBy?: PaymentHistoryOrderByWithAggregationInput | PaymentHistoryOrderByWithAggregationInput[]
    by: PaymentHistoryScalarFieldEnum[] | PaymentHistoryScalarFieldEnum
    having?: PaymentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentHistoryCountAggregateInputType | true
    _avg?: PaymentHistoryAvgAggregateInputType
    _sum?: PaymentHistorySumAggregateInputType
    _min?: PaymentHistoryMinAggregateInputType
    _max?: PaymentHistoryMaxAggregateInputType
  }

  export type PaymentHistoryGroupByOutputType = {
    id: string
    user_email: string
    subscription_id: string | null
    amount: number | null
    currency: string | null
    status: string | null
    payment_date: Date | null
    stripe_payment_id: string | null
    payment_method_last4: string | null
    error_message: string | null
    created_at: Date
    _count: PaymentHistoryCountAggregateOutputType | null
    _avg: PaymentHistoryAvgAggregateOutputType | null
    _sum: PaymentHistorySumAggregateOutputType | null
    _min: PaymentHistoryMinAggregateOutputType | null
    _max: PaymentHistoryMaxAggregateOutputType | null
  }

  type GetPaymentHistoryGroupByPayload<T extends PaymentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PaymentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    payment_date?: boolean
    stripe_payment_id?: boolean
    payment_method_last4?: boolean
    error_message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["paymentHistory"]>

  export type PaymentHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    payment_date?: boolean
    stripe_payment_id?: boolean
    payment_method_last4?: boolean
    error_message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["paymentHistory"]>

  export type PaymentHistorySelectScalar = {
    id?: boolean
    user_email?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    payment_date?: boolean
    stripe_payment_id?: boolean
    payment_method_last4?: boolean
    error_message?: boolean
    created_at?: boolean
  }


  export type $PaymentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_email: string
      subscription_id: string | null
      amount: number | null
      currency: string | null
      status: string | null
      payment_date: Date | null
      stripe_payment_id: string | null
      payment_method_last4: string | null
      error_message: string | null
      created_at: Date
    }, ExtArgs["result"]["paymentHistory"]>
    composites: {}
  }

  type PaymentHistoryGetPayload<S extends boolean | null | undefined | PaymentHistoryDefaultArgs> = $Result.GetResult<Prisma.$PaymentHistoryPayload, S>

  type PaymentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentHistoryCountAggregateInputType | true
    }

  export interface PaymentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentHistory'], meta: { name: 'PaymentHistory' } }
    /**
     * Find zero or one PaymentHistory that matches the filter.
     * @param {PaymentHistoryFindUniqueArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentHistoryFindUniqueArgs>(args: SelectSubset<T, PaymentHistoryFindUniqueArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentHistoryFindUniqueOrThrowArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindFirstArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentHistoryFindFirstArgs>(args?: SelectSubset<T, PaymentHistoryFindFirstArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindFirstOrThrowArgs} args - Arguments to find a PaymentHistory
     * @example
     * // Get one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentHistories
     * const paymentHistories = await prisma.paymentHistory.findMany()
     * 
     * // Get first 10 PaymentHistories
     * const paymentHistories = await prisma.paymentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentHistoryWithIdOnly = await prisma.paymentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentHistoryFindManyArgs>(args?: SelectSubset<T, PaymentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentHistory.
     * @param {PaymentHistoryCreateArgs} args - Arguments to create a PaymentHistory.
     * @example
     * // Create one PaymentHistory
     * const PaymentHistory = await prisma.paymentHistory.create({
     *   data: {
     *     // ... data to create a PaymentHistory
     *   }
     * })
     * 
     */
    create<T extends PaymentHistoryCreateArgs>(args: SelectSubset<T, PaymentHistoryCreateArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentHistories.
     * @param {PaymentHistoryCreateManyArgs} args - Arguments to create many PaymentHistories.
     * @example
     * // Create many PaymentHistories
     * const paymentHistory = await prisma.paymentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentHistoryCreateManyArgs>(args?: SelectSubset<T, PaymentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentHistories and returns the data saved in the database.
     * @param {PaymentHistoryCreateManyAndReturnArgs} args - Arguments to create many PaymentHistories.
     * @example
     * // Create many PaymentHistories
     * const paymentHistory = await prisma.paymentHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentHistories and only return the `id`
     * const paymentHistoryWithIdOnly = await prisma.paymentHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentHistory.
     * @param {PaymentHistoryDeleteArgs} args - Arguments to delete one PaymentHistory.
     * @example
     * // Delete one PaymentHistory
     * const PaymentHistory = await prisma.paymentHistory.delete({
     *   where: {
     *     // ... filter to delete one PaymentHistory
     *   }
     * })
     * 
     */
    delete<T extends PaymentHistoryDeleteArgs>(args: SelectSubset<T, PaymentHistoryDeleteArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentHistory.
     * @param {PaymentHistoryUpdateArgs} args - Arguments to update one PaymentHistory.
     * @example
     * // Update one PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentHistoryUpdateArgs>(args: SelectSubset<T, PaymentHistoryUpdateArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentHistories.
     * @param {PaymentHistoryDeleteManyArgs} args - Arguments to filter PaymentHistories to delete.
     * @example
     * // Delete a few PaymentHistories
     * const { count } = await prisma.paymentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentHistoryDeleteManyArgs>(args?: SelectSubset<T, PaymentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentHistories
     * const paymentHistory = await prisma.paymentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentHistoryUpdateManyArgs>(args: SelectSubset<T, PaymentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentHistory.
     * @param {PaymentHistoryUpsertArgs} args - Arguments to update or create a PaymentHistory.
     * @example
     * // Update or create a PaymentHistory
     * const paymentHistory = await prisma.paymentHistory.upsert({
     *   create: {
     *     // ... data to create a PaymentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentHistory we want to update
     *   }
     * })
     */
    upsert<T extends PaymentHistoryUpsertArgs>(args: SelectSubset<T, PaymentHistoryUpsertArgs<ExtArgs>>): Prisma__PaymentHistoryClient<$Result.GetResult<Prisma.$PaymentHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryCountArgs} args - Arguments to filter PaymentHistories to count.
     * @example
     * // Count the number of PaymentHistories
     * const count = await prisma.paymentHistory.count({
     *   where: {
     *     // ... the filter for the PaymentHistories we want to count
     *   }
     * })
    **/
    count<T extends PaymentHistoryCountArgs>(
      args?: Subset<T, PaymentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentHistoryAggregateArgs>(args: Subset<T, PaymentHistoryAggregateArgs>): Prisma.PrismaPromise<GetPaymentHistoryAggregateType<T>>

    /**
     * Group by PaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PaymentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentHistory model
   */
  readonly fields: PaymentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentHistory model
   */ 
  interface PaymentHistoryFieldRefs {
    readonly id: FieldRef<"PaymentHistory", 'String'>
    readonly user_email: FieldRef<"PaymentHistory", 'String'>
    readonly subscription_id: FieldRef<"PaymentHistory", 'String'>
    readonly amount: FieldRef<"PaymentHistory", 'Float'>
    readonly currency: FieldRef<"PaymentHistory", 'String'>
    readonly status: FieldRef<"PaymentHistory", 'String'>
    readonly payment_date: FieldRef<"PaymentHistory", 'DateTime'>
    readonly stripe_payment_id: FieldRef<"PaymentHistory", 'String'>
    readonly payment_method_last4: FieldRef<"PaymentHistory", 'String'>
    readonly error_message: FieldRef<"PaymentHistory", 'String'>
    readonly created_at: FieldRef<"PaymentHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentHistory findUnique
   */
  export type PaymentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory findUniqueOrThrow
   */
  export type PaymentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory findFirst
   */
  export type PaymentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentHistories.
     */
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory findFirstOrThrow
   */
  export type PaymentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter, which PaymentHistory to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentHistories.
     */
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory findMany
   */
  export type PaymentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter, which PaymentHistories to fetch.
     */
    where?: PaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentHistories to fetch.
     */
    orderBy?: PaymentHistoryOrderByWithRelationInput | PaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentHistories.
     */
    cursor?: PaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentHistories.
     */
    skip?: number
    distinct?: PaymentHistoryScalarFieldEnum | PaymentHistoryScalarFieldEnum[]
  }

  /**
   * PaymentHistory create
   */
  export type PaymentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentHistory.
     */
    data: XOR<PaymentHistoryCreateInput, PaymentHistoryUncheckedCreateInput>
  }

  /**
   * PaymentHistory createMany
   */
  export type PaymentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentHistories.
     */
    data: PaymentHistoryCreateManyInput | PaymentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentHistory createManyAndReturn
   */
  export type PaymentHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentHistories.
     */
    data: PaymentHistoryCreateManyInput | PaymentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentHistory update
   */
  export type PaymentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentHistory.
     */
    data: XOR<PaymentHistoryUpdateInput, PaymentHistoryUncheckedUpdateInput>
    /**
     * Choose, which PaymentHistory to update.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory updateMany
   */
  export type PaymentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentHistories.
     */
    data: XOR<PaymentHistoryUpdateManyMutationInput, PaymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PaymentHistories to update
     */
    where?: PaymentHistoryWhereInput
  }

  /**
   * PaymentHistory upsert
   */
  export type PaymentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentHistory to update in case it exists.
     */
    where: PaymentHistoryWhereUniqueInput
    /**
     * In case the PaymentHistory found by the `where` argument doesn't exist, create a new PaymentHistory with this data.
     */
    create: XOR<PaymentHistoryCreateInput, PaymentHistoryUncheckedCreateInput>
    /**
     * In case the PaymentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentHistoryUpdateInput, PaymentHistoryUncheckedUpdateInput>
  }

  /**
   * PaymentHistory delete
   */
  export type PaymentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
    /**
     * Filter which PaymentHistory to delete.
     */
    where: PaymentHistoryWhereUniqueInput
  }

  /**
   * PaymentHistory deleteMany
   */
  export type PaymentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentHistories to delete
     */
    where?: PaymentHistoryWhereInput
  }

  /**
   * PaymentHistory without action
   */
  export type PaymentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentHistory
     */
    select?: PaymentHistorySelect<ExtArgs> | null
  }


  /**
   * Model PaymentLink
   */

  export type AggregatePaymentLink = {
    _count: PaymentLinkCountAggregateOutputType | null
    _avg: PaymentLinkAvgAggregateOutputType | null
    _sum: PaymentLinkSumAggregateOutputType | null
    _min: PaymentLinkMinAggregateOutputType | null
    _max: PaymentLinkMaxAggregateOutputType | null
  }

  export type PaymentLinkAvgAggregateOutputType = {
    amount: number | null
    platform_fee_amount: number | null
    net_amount: number | null
  }

  export type PaymentLinkSumAggregateOutputType = {
    amount: number | null
    platform_fee_amount: number | null
    net_amount: number | null
  }

  export type PaymentLinkMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    stripe_checkout_session_id: string | null
    stripe_payment_intent_id: string | null
    checkout_url: string | null
    expires_at: Date | null
    paid_at: Date | null
    platform_fee_amount: number | null
    net_amount: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentLinkMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string | null
    stripe_checkout_session_id: string | null
    stripe_payment_intent_id: string | null
    checkout_url: string | null
    expires_at: Date | null
    paid_at: Date | null
    platform_fee_amount: number | null
    net_amount: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentLinkCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    amount: number
    currency: number
    description: number
    status: number
    stripe_checkout_session_id: number
    stripe_payment_intent_id: number
    checkout_url: number
    expires_at: number
    paid_at: number
    platform_fee_amount: number
    net_amount: number
    payment_metadata: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentLinkAvgAggregateInputType = {
    amount?: true
    platform_fee_amount?: true
    net_amount?: true
  }

  export type PaymentLinkSumAggregateInputType = {
    amount?: true
    platform_fee_amount?: true
    net_amount?: true
  }

  export type PaymentLinkMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    stripe_checkout_session_id?: true
    stripe_payment_intent_id?: true
    checkout_url?: true
    expires_at?: true
    paid_at?: true
    platform_fee_amount?: true
    net_amount?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentLinkMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    stripe_checkout_session_id?: true
    stripe_payment_intent_id?: true
    checkout_url?: true
    expires_at?: true
    paid_at?: true
    platform_fee_amount?: true
    net_amount?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentLinkCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    stripe_checkout_session_id?: true
    stripe_payment_intent_id?: true
    checkout_url?: true
    expires_at?: true
    paid_at?: true
    platform_fee_amount?: true
    net_amount?: true
    payment_metadata?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentLink to aggregate.
     */
    where?: PaymentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentLinks to fetch.
     */
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentLinks
    **/
    _count?: true | PaymentLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentLinkMaxAggregateInputType
  }

  export type GetPaymentLinkAggregateType<T extends PaymentLinkAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentLink[P]>
      : GetScalarType<T[P], AggregatePaymentLink[P]>
  }




  export type PaymentLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentLinkWhereInput
    orderBy?: PaymentLinkOrderByWithAggregationInput | PaymentLinkOrderByWithAggregationInput[]
    by: PaymentLinkScalarFieldEnum[] | PaymentLinkScalarFieldEnum
    having?: PaymentLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentLinkCountAggregateInputType | true
    _avg?: PaymentLinkAvgAggregateInputType
    _sum?: PaymentLinkSumAggregateInputType
    _min?: PaymentLinkMinAggregateInputType
    _max?: PaymentLinkMaxAggregateInputType
  }

  export type PaymentLinkGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: string
    stripe_checkout_session_id: string | null
    stripe_payment_intent_id: string | null
    checkout_url: string | null
    expires_at: Date | null
    paid_at: Date | null
    platform_fee_amount: number | null
    net_amount: number | null
    payment_metadata: JsonValue | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: PaymentLinkCountAggregateOutputType | null
    _avg: PaymentLinkAvgAggregateOutputType | null
    _sum: PaymentLinkSumAggregateOutputType | null
    _min: PaymentLinkMinAggregateOutputType | null
    _max: PaymentLinkMaxAggregateOutputType | null
  }

  type GetPaymentLinkGroupByPayload<T extends PaymentLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentLinkGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentLinkGroupByOutputType[P]>
        }
      >
    >


  export type PaymentLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    stripe_checkout_session_id?: boolean
    stripe_payment_intent_id?: boolean
    checkout_url?: boolean
    expires_at?: boolean
    paid_at?: boolean
    platform_fee_amount?: boolean
    net_amount?: boolean
    payment_metadata?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentLink"]>

  export type PaymentLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    stripe_checkout_session_id?: boolean
    stripe_payment_intent_id?: boolean
    checkout_url?: boolean
    expires_at?: boolean
    paid_at?: boolean
    platform_fee_amount?: boolean
    net_amount?: boolean
    payment_metadata?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentLink"]>

  export type PaymentLinkSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    stripe_checkout_session_id?: boolean
    stripe_payment_intent_id?: boolean
    checkout_url?: boolean
    expires_at?: boolean
    paid_at?: boolean
    platform_fee_amount?: boolean
    net_amount?: boolean
    payment_metadata?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PaymentLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentLink"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string | null
      amount: number | null
      currency: string | null
      description: string | null
      status: string
      stripe_checkout_session_id: string | null
      stripe_payment_intent_id: string | null
      checkout_url: string | null
      expires_at: Date | null
      paid_at: Date | null
      platform_fee_amount: number | null
      net_amount: number | null
      payment_metadata: Prisma.JsonValue | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["paymentLink"]>
    composites: {}
  }

  type PaymentLinkGetPayload<S extends boolean | null | undefined | PaymentLinkDefaultArgs> = $Result.GetResult<Prisma.$PaymentLinkPayload, S>

  type PaymentLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentLinkCountAggregateInputType | true
    }

  export interface PaymentLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentLink'], meta: { name: 'PaymentLink' } }
    /**
     * Find zero or one PaymentLink that matches the filter.
     * @param {PaymentLinkFindUniqueArgs} args - Arguments to find a PaymentLink
     * @example
     * // Get one PaymentLink
     * const paymentLink = await prisma.paymentLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentLinkFindUniqueArgs>(args: SelectSubset<T, PaymentLinkFindUniqueArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentLinkFindUniqueOrThrowArgs} args - Arguments to find a PaymentLink
     * @example
     * // Get one PaymentLink
     * const paymentLink = await prisma.paymentLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkFindFirstArgs} args - Arguments to find a PaymentLink
     * @example
     * // Get one PaymentLink
     * const paymentLink = await prisma.paymentLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentLinkFindFirstArgs>(args?: SelectSubset<T, PaymentLinkFindFirstArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkFindFirstOrThrowArgs} args - Arguments to find a PaymentLink
     * @example
     * // Get one PaymentLink
     * const paymentLink = await prisma.paymentLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentLinks
     * const paymentLinks = await prisma.paymentLink.findMany()
     * 
     * // Get first 10 PaymentLinks
     * const paymentLinks = await prisma.paymentLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentLinkWithIdOnly = await prisma.paymentLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentLinkFindManyArgs>(args?: SelectSubset<T, PaymentLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentLink.
     * @param {PaymentLinkCreateArgs} args - Arguments to create a PaymentLink.
     * @example
     * // Create one PaymentLink
     * const PaymentLink = await prisma.paymentLink.create({
     *   data: {
     *     // ... data to create a PaymentLink
     *   }
     * })
     * 
     */
    create<T extends PaymentLinkCreateArgs>(args: SelectSubset<T, PaymentLinkCreateArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentLinks.
     * @param {PaymentLinkCreateManyArgs} args - Arguments to create many PaymentLinks.
     * @example
     * // Create many PaymentLinks
     * const paymentLink = await prisma.paymentLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentLinkCreateManyArgs>(args?: SelectSubset<T, PaymentLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentLinks and returns the data saved in the database.
     * @param {PaymentLinkCreateManyAndReturnArgs} args - Arguments to create many PaymentLinks.
     * @example
     * // Create many PaymentLinks
     * const paymentLink = await prisma.paymentLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentLinks and only return the `id`
     * const paymentLinkWithIdOnly = await prisma.paymentLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentLink.
     * @param {PaymentLinkDeleteArgs} args - Arguments to delete one PaymentLink.
     * @example
     * // Delete one PaymentLink
     * const PaymentLink = await prisma.paymentLink.delete({
     *   where: {
     *     // ... filter to delete one PaymentLink
     *   }
     * })
     * 
     */
    delete<T extends PaymentLinkDeleteArgs>(args: SelectSubset<T, PaymentLinkDeleteArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentLink.
     * @param {PaymentLinkUpdateArgs} args - Arguments to update one PaymentLink.
     * @example
     * // Update one PaymentLink
     * const paymentLink = await prisma.paymentLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentLinkUpdateArgs>(args: SelectSubset<T, PaymentLinkUpdateArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentLinks.
     * @param {PaymentLinkDeleteManyArgs} args - Arguments to filter PaymentLinks to delete.
     * @example
     * // Delete a few PaymentLinks
     * const { count } = await prisma.paymentLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentLinkDeleteManyArgs>(args?: SelectSubset<T, PaymentLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentLinks
     * const paymentLink = await prisma.paymentLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentLinkUpdateManyArgs>(args: SelectSubset<T, PaymentLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentLink.
     * @param {PaymentLinkUpsertArgs} args - Arguments to update or create a PaymentLink.
     * @example
     * // Update or create a PaymentLink
     * const paymentLink = await prisma.paymentLink.upsert({
     *   create: {
     *     // ... data to create a PaymentLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentLink we want to update
     *   }
     * })
     */
    upsert<T extends PaymentLinkUpsertArgs>(args: SelectSubset<T, PaymentLinkUpsertArgs<ExtArgs>>): Prisma__PaymentLinkClient<$Result.GetResult<Prisma.$PaymentLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkCountArgs} args - Arguments to filter PaymentLinks to count.
     * @example
     * // Count the number of PaymentLinks
     * const count = await prisma.paymentLink.count({
     *   where: {
     *     // ... the filter for the PaymentLinks we want to count
     *   }
     * })
    **/
    count<T extends PaymentLinkCountArgs>(
      args?: Subset<T, PaymentLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentLinkAggregateArgs>(args: Subset<T, PaymentLinkAggregateArgs>): Prisma.PrismaPromise<GetPaymentLinkAggregateType<T>>

    /**
     * Group by PaymentLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentLinkGroupByArgs['orderBy'] }
        : { orderBy?: PaymentLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentLink model
   */
  readonly fields: PaymentLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentLink model
   */ 
  interface PaymentLinkFieldRefs {
    readonly id: FieldRef<"PaymentLink", 'String'>
    readonly customer_id: FieldRef<"PaymentLink", 'String'>
    readonly customer_name: FieldRef<"PaymentLink", 'String'>
    readonly amount: FieldRef<"PaymentLink", 'Float'>
    readonly currency: FieldRef<"PaymentLink", 'String'>
    readonly description: FieldRef<"PaymentLink", 'String'>
    readonly status: FieldRef<"PaymentLink", 'String'>
    readonly stripe_checkout_session_id: FieldRef<"PaymentLink", 'String'>
    readonly stripe_payment_intent_id: FieldRef<"PaymentLink", 'String'>
    readonly checkout_url: FieldRef<"PaymentLink", 'String'>
    readonly expires_at: FieldRef<"PaymentLink", 'DateTime'>
    readonly paid_at: FieldRef<"PaymentLink", 'DateTime'>
    readonly platform_fee_amount: FieldRef<"PaymentLink", 'Float'>
    readonly net_amount: FieldRef<"PaymentLink", 'Float'>
    readonly payment_metadata: FieldRef<"PaymentLink", 'Json'>
    readonly created_by: FieldRef<"PaymentLink", 'String'>
    readonly created_at: FieldRef<"PaymentLink", 'DateTime'>
    readonly updated_at: FieldRef<"PaymentLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentLink findUnique
   */
  export type PaymentLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter, which PaymentLink to fetch.
     */
    where: PaymentLinkWhereUniqueInput
  }

  /**
   * PaymentLink findUniqueOrThrow
   */
  export type PaymentLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter, which PaymentLink to fetch.
     */
    where: PaymentLinkWhereUniqueInput
  }

  /**
   * PaymentLink findFirst
   */
  export type PaymentLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter, which PaymentLink to fetch.
     */
    where?: PaymentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentLinks to fetch.
     */
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentLinks.
     */
    cursor?: PaymentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentLinks.
     */
    distinct?: PaymentLinkScalarFieldEnum | PaymentLinkScalarFieldEnum[]
  }

  /**
   * PaymentLink findFirstOrThrow
   */
  export type PaymentLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter, which PaymentLink to fetch.
     */
    where?: PaymentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentLinks to fetch.
     */
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentLinks.
     */
    cursor?: PaymentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentLinks.
     */
    distinct?: PaymentLinkScalarFieldEnum | PaymentLinkScalarFieldEnum[]
  }

  /**
   * PaymentLink findMany
   */
  export type PaymentLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter, which PaymentLinks to fetch.
     */
    where?: PaymentLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentLinks to fetch.
     */
    orderBy?: PaymentLinkOrderByWithRelationInput | PaymentLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentLinks.
     */
    cursor?: PaymentLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentLinks.
     */
    skip?: number
    distinct?: PaymentLinkScalarFieldEnum | PaymentLinkScalarFieldEnum[]
  }

  /**
   * PaymentLink create
   */
  export type PaymentLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentLink.
     */
    data: XOR<PaymentLinkCreateInput, PaymentLinkUncheckedCreateInput>
  }

  /**
   * PaymentLink createMany
   */
  export type PaymentLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentLinks.
     */
    data: PaymentLinkCreateManyInput | PaymentLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentLink createManyAndReturn
   */
  export type PaymentLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentLinks.
     */
    data: PaymentLinkCreateManyInput | PaymentLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentLink update
   */
  export type PaymentLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentLink.
     */
    data: XOR<PaymentLinkUpdateInput, PaymentLinkUncheckedUpdateInput>
    /**
     * Choose, which PaymentLink to update.
     */
    where: PaymentLinkWhereUniqueInput
  }

  /**
   * PaymentLink updateMany
   */
  export type PaymentLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentLinks.
     */
    data: XOR<PaymentLinkUpdateManyMutationInput, PaymentLinkUncheckedUpdateManyInput>
    /**
     * Filter which PaymentLinks to update
     */
    where?: PaymentLinkWhereInput
  }

  /**
   * PaymentLink upsert
   */
  export type PaymentLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentLink to update in case it exists.
     */
    where: PaymentLinkWhereUniqueInput
    /**
     * In case the PaymentLink found by the `where` argument doesn't exist, create a new PaymentLink with this data.
     */
    create: XOR<PaymentLinkCreateInput, PaymentLinkUncheckedCreateInput>
    /**
     * In case the PaymentLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentLinkUpdateInput, PaymentLinkUncheckedUpdateInput>
  }

  /**
   * PaymentLink delete
   */
  export type PaymentLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
    /**
     * Filter which PaymentLink to delete.
     */
    where: PaymentLinkWhereUniqueInput
  }

  /**
   * PaymentLink deleteMany
   */
  export type PaymentLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentLinks to delete
     */
    where?: PaymentLinkWhereInput
  }

  /**
   * PaymentLink without action
   */
  export type PaymentLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentLink
     */
    select?: PaymentLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentLinkInclude<ExtArgs> | null
  }


  /**
   * Model ConsumptionLog
   */

  export type AggregateConsumptionLog = {
    _count: ConsumptionLogCountAggregateOutputType | null
    _avg: ConsumptionLogAvgAggregateOutputType | null
    _sum: ConsumptionLogSumAggregateOutputType | null
    _min: ConsumptionLogMinAggregateOutputType | null
    _max: ConsumptionLogMaxAggregateOutputType | null
  }

  export type ConsumptionLogAvgAggregateOutputType = {
    quantity_prepared: number | null
    total_cost: number | null
    cost_per_meal: number | null
  }

  export type ConsumptionLogSumAggregateOutputType = {
    quantity_prepared: number | null
    total_cost: number | null
    cost_per_meal: number | null
  }

  export type ConsumptionLogMinAggregateOutputType = {
    id: string | null
    date: string | null
    recipe_id: string | null
    recipe_name: string | null
    meal_type: string | null
    quantity_prepared: number | null
    total_cost: number | null
    cost_per_meal: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ConsumptionLogMaxAggregateOutputType = {
    id: string | null
    date: string | null
    recipe_id: string | null
    recipe_name: string | null
    meal_type: string | null
    quantity_prepared: number | null
    total_cost: number | null
    cost_per_meal: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type ConsumptionLogCountAggregateOutputType = {
    id: number
    date: number
    recipe_id: number
    recipe_name: number
    meal_type: number
    quantity_prepared: number
    ingredients_used: number
    total_cost: number
    cost_per_meal: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ConsumptionLogAvgAggregateInputType = {
    quantity_prepared?: true
    total_cost?: true
    cost_per_meal?: true
  }

  export type ConsumptionLogSumAggregateInputType = {
    quantity_prepared?: true
    total_cost?: true
    cost_per_meal?: true
  }

  export type ConsumptionLogMinAggregateInputType = {
    id?: true
    date?: true
    recipe_id?: true
    recipe_name?: true
    meal_type?: true
    quantity_prepared?: true
    total_cost?: true
    cost_per_meal?: true
    created_by?: true
    created_at?: true
  }

  export type ConsumptionLogMaxAggregateInputType = {
    id?: true
    date?: true
    recipe_id?: true
    recipe_name?: true
    meal_type?: true
    quantity_prepared?: true
    total_cost?: true
    cost_per_meal?: true
    created_by?: true
    created_at?: true
  }

  export type ConsumptionLogCountAggregateInputType = {
    id?: true
    date?: true
    recipe_id?: true
    recipe_name?: true
    meal_type?: true
    quantity_prepared?: true
    ingredients_used?: true
    total_cost?: true
    cost_per_meal?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ConsumptionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsumptionLog to aggregate.
     */
    where?: ConsumptionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsumptionLogs to fetch.
     */
    orderBy?: ConsumptionLogOrderByWithRelationInput | ConsumptionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsumptionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsumptionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsumptionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsumptionLogs
    **/
    _count?: true | ConsumptionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsumptionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsumptionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsumptionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsumptionLogMaxAggregateInputType
  }

  export type GetConsumptionLogAggregateType<T extends ConsumptionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateConsumptionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsumptionLog[P]>
      : GetScalarType<T[P], AggregateConsumptionLog[P]>
  }




  export type ConsumptionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsumptionLogWhereInput
    orderBy?: ConsumptionLogOrderByWithAggregationInput | ConsumptionLogOrderByWithAggregationInput[]
    by: ConsumptionLogScalarFieldEnum[] | ConsumptionLogScalarFieldEnum
    having?: ConsumptionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsumptionLogCountAggregateInputType | true
    _avg?: ConsumptionLogAvgAggregateInputType
    _sum?: ConsumptionLogSumAggregateInputType
    _min?: ConsumptionLogMinAggregateInputType
    _max?: ConsumptionLogMaxAggregateInputType
  }

  export type ConsumptionLogGroupByOutputType = {
    id: string
    date: string | null
    recipe_id: string | null
    recipe_name: string | null
    meal_type: string | null
    quantity_prepared: number | null
    ingredients_used: JsonValue | null
    total_cost: number | null
    cost_per_meal: number | null
    created_by: string | null
    created_at: Date
    _count: ConsumptionLogCountAggregateOutputType | null
    _avg: ConsumptionLogAvgAggregateOutputType | null
    _sum: ConsumptionLogSumAggregateOutputType | null
    _min: ConsumptionLogMinAggregateOutputType | null
    _max: ConsumptionLogMaxAggregateOutputType | null
  }

  type GetConsumptionLogGroupByPayload<T extends ConsumptionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsumptionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsumptionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsumptionLogGroupByOutputType[P]>
            : GetScalarType<T[P], ConsumptionLogGroupByOutputType[P]>
        }
      >
    >


  export type ConsumptionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    recipe_id?: boolean
    recipe_name?: boolean
    meal_type?: boolean
    quantity_prepared?: boolean
    ingredients_used?: boolean
    total_cost?: boolean
    cost_per_meal?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["consumptionLog"]>

  export type ConsumptionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    recipe_id?: boolean
    recipe_name?: boolean
    meal_type?: boolean
    quantity_prepared?: boolean
    ingredients_used?: boolean
    total_cost?: boolean
    cost_per_meal?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["consumptionLog"]>

  export type ConsumptionLogSelectScalar = {
    id?: boolean
    date?: boolean
    recipe_id?: boolean
    recipe_name?: boolean
    meal_type?: boolean
    quantity_prepared?: boolean
    ingredients_used?: boolean
    total_cost?: boolean
    cost_per_meal?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $ConsumptionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsumptionLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string | null
      recipe_id: string | null
      recipe_name: string | null
      meal_type: string | null
      quantity_prepared: number | null
      ingredients_used: Prisma.JsonValue | null
      total_cost: number | null
      cost_per_meal: number | null
      created_by: string | null
      created_at: Date
    }, ExtArgs["result"]["consumptionLog"]>
    composites: {}
  }

  type ConsumptionLogGetPayload<S extends boolean | null | undefined | ConsumptionLogDefaultArgs> = $Result.GetResult<Prisma.$ConsumptionLogPayload, S>

  type ConsumptionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsumptionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsumptionLogCountAggregateInputType | true
    }

  export interface ConsumptionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsumptionLog'], meta: { name: 'ConsumptionLog' } }
    /**
     * Find zero or one ConsumptionLog that matches the filter.
     * @param {ConsumptionLogFindUniqueArgs} args - Arguments to find a ConsumptionLog
     * @example
     * // Get one ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsumptionLogFindUniqueArgs>(args: SelectSubset<T, ConsumptionLogFindUniqueArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsumptionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsumptionLogFindUniqueOrThrowArgs} args - Arguments to find a ConsumptionLog
     * @example
     * // Get one ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsumptionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsumptionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsumptionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogFindFirstArgs} args - Arguments to find a ConsumptionLog
     * @example
     * // Get one ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsumptionLogFindFirstArgs>(args?: SelectSubset<T, ConsumptionLogFindFirstArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsumptionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogFindFirstOrThrowArgs} args - Arguments to find a ConsumptionLog
     * @example
     * // Get one ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsumptionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsumptionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsumptionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsumptionLogs
     * const consumptionLogs = await prisma.consumptionLog.findMany()
     * 
     * // Get first 10 ConsumptionLogs
     * const consumptionLogs = await prisma.consumptionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consumptionLogWithIdOnly = await prisma.consumptionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsumptionLogFindManyArgs>(args?: SelectSubset<T, ConsumptionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsumptionLog.
     * @param {ConsumptionLogCreateArgs} args - Arguments to create a ConsumptionLog.
     * @example
     * // Create one ConsumptionLog
     * const ConsumptionLog = await prisma.consumptionLog.create({
     *   data: {
     *     // ... data to create a ConsumptionLog
     *   }
     * })
     * 
     */
    create<T extends ConsumptionLogCreateArgs>(args: SelectSubset<T, ConsumptionLogCreateArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsumptionLogs.
     * @param {ConsumptionLogCreateManyArgs} args - Arguments to create many ConsumptionLogs.
     * @example
     * // Create many ConsumptionLogs
     * const consumptionLog = await prisma.consumptionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsumptionLogCreateManyArgs>(args?: SelectSubset<T, ConsumptionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsumptionLogs and returns the data saved in the database.
     * @param {ConsumptionLogCreateManyAndReturnArgs} args - Arguments to create many ConsumptionLogs.
     * @example
     * // Create many ConsumptionLogs
     * const consumptionLog = await prisma.consumptionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsumptionLogs and only return the `id`
     * const consumptionLogWithIdOnly = await prisma.consumptionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsumptionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsumptionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsumptionLog.
     * @param {ConsumptionLogDeleteArgs} args - Arguments to delete one ConsumptionLog.
     * @example
     * // Delete one ConsumptionLog
     * const ConsumptionLog = await prisma.consumptionLog.delete({
     *   where: {
     *     // ... filter to delete one ConsumptionLog
     *   }
     * })
     * 
     */
    delete<T extends ConsumptionLogDeleteArgs>(args: SelectSubset<T, ConsumptionLogDeleteArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsumptionLog.
     * @param {ConsumptionLogUpdateArgs} args - Arguments to update one ConsumptionLog.
     * @example
     * // Update one ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsumptionLogUpdateArgs>(args: SelectSubset<T, ConsumptionLogUpdateArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsumptionLogs.
     * @param {ConsumptionLogDeleteManyArgs} args - Arguments to filter ConsumptionLogs to delete.
     * @example
     * // Delete a few ConsumptionLogs
     * const { count } = await prisma.consumptionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsumptionLogDeleteManyArgs>(args?: SelectSubset<T, ConsumptionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsumptionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsumptionLogs
     * const consumptionLog = await prisma.consumptionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsumptionLogUpdateManyArgs>(args: SelectSubset<T, ConsumptionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsumptionLog.
     * @param {ConsumptionLogUpsertArgs} args - Arguments to update or create a ConsumptionLog.
     * @example
     * // Update or create a ConsumptionLog
     * const consumptionLog = await prisma.consumptionLog.upsert({
     *   create: {
     *     // ... data to create a ConsumptionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsumptionLog we want to update
     *   }
     * })
     */
    upsert<T extends ConsumptionLogUpsertArgs>(args: SelectSubset<T, ConsumptionLogUpsertArgs<ExtArgs>>): Prisma__ConsumptionLogClient<$Result.GetResult<Prisma.$ConsumptionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsumptionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogCountArgs} args - Arguments to filter ConsumptionLogs to count.
     * @example
     * // Count the number of ConsumptionLogs
     * const count = await prisma.consumptionLog.count({
     *   where: {
     *     // ... the filter for the ConsumptionLogs we want to count
     *   }
     * })
    **/
    count<T extends ConsumptionLogCountArgs>(
      args?: Subset<T, ConsumptionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsumptionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsumptionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsumptionLogAggregateArgs>(args: Subset<T, ConsumptionLogAggregateArgs>): Prisma.PrismaPromise<GetConsumptionLogAggregateType<T>>

    /**
     * Group by ConsumptionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsumptionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsumptionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsumptionLogGroupByArgs['orderBy'] }
        : { orderBy?: ConsumptionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsumptionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsumptionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsumptionLog model
   */
  readonly fields: ConsumptionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsumptionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsumptionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsumptionLog model
   */ 
  interface ConsumptionLogFieldRefs {
    readonly id: FieldRef<"ConsumptionLog", 'String'>
    readonly date: FieldRef<"ConsumptionLog", 'String'>
    readonly recipe_id: FieldRef<"ConsumptionLog", 'String'>
    readonly recipe_name: FieldRef<"ConsumptionLog", 'String'>
    readonly meal_type: FieldRef<"ConsumptionLog", 'String'>
    readonly quantity_prepared: FieldRef<"ConsumptionLog", 'Int'>
    readonly ingredients_used: FieldRef<"ConsumptionLog", 'Json'>
    readonly total_cost: FieldRef<"ConsumptionLog", 'Float'>
    readonly cost_per_meal: FieldRef<"ConsumptionLog", 'Float'>
    readonly created_by: FieldRef<"ConsumptionLog", 'String'>
    readonly created_at: FieldRef<"ConsumptionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsumptionLog findUnique
   */
  export type ConsumptionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter, which ConsumptionLog to fetch.
     */
    where: ConsumptionLogWhereUniqueInput
  }

  /**
   * ConsumptionLog findUniqueOrThrow
   */
  export type ConsumptionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter, which ConsumptionLog to fetch.
     */
    where: ConsumptionLogWhereUniqueInput
  }

  /**
   * ConsumptionLog findFirst
   */
  export type ConsumptionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter, which ConsumptionLog to fetch.
     */
    where?: ConsumptionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsumptionLogs to fetch.
     */
    orderBy?: ConsumptionLogOrderByWithRelationInput | ConsumptionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsumptionLogs.
     */
    cursor?: ConsumptionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsumptionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsumptionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsumptionLogs.
     */
    distinct?: ConsumptionLogScalarFieldEnum | ConsumptionLogScalarFieldEnum[]
  }

  /**
   * ConsumptionLog findFirstOrThrow
   */
  export type ConsumptionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter, which ConsumptionLog to fetch.
     */
    where?: ConsumptionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsumptionLogs to fetch.
     */
    orderBy?: ConsumptionLogOrderByWithRelationInput | ConsumptionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsumptionLogs.
     */
    cursor?: ConsumptionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsumptionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsumptionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsumptionLogs.
     */
    distinct?: ConsumptionLogScalarFieldEnum | ConsumptionLogScalarFieldEnum[]
  }

  /**
   * ConsumptionLog findMany
   */
  export type ConsumptionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter, which ConsumptionLogs to fetch.
     */
    where?: ConsumptionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsumptionLogs to fetch.
     */
    orderBy?: ConsumptionLogOrderByWithRelationInput | ConsumptionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsumptionLogs.
     */
    cursor?: ConsumptionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsumptionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsumptionLogs.
     */
    skip?: number
    distinct?: ConsumptionLogScalarFieldEnum | ConsumptionLogScalarFieldEnum[]
  }

  /**
   * ConsumptionLog create
   */
  export type ConsumptionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * The data needed to create a ConsumptionLog.
     */
    data?: XOR<ConsumptionLogCreateInput, ConsumptionLogUncheckedCreateInput>
  }

  /**
   * ConsumptionLog createMany
   */
  export type ConsumptionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsumptionLogs.
     */
    data: ConsumptionLogCreateManyInput | ConsumptionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsumptionLog createManyAndReturn
   */
  export type ConsumptionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsumptionLogs.
     */
    data: ConsumptionLogCreateManyInput | ConsumptionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsumptionLog update
   */
  export type ConsumptionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * The data needed to update a ConsumptionLog.
     */
    data: XOR<ConsumptionLogUpdateInput, ConsumptionLogUncheckedUpdateInput>
    /**
     * Choose, which ConsumptionLog to update.
     */
    where: ConsumptionLogWhereUniqueInput
  }

  /**
   * ConsumptionLog updateMany
   */
  export type ConsumptionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsumptionLogs.
     */
    data: XOR<ConsumptionLogUpdateManyMutationInput, ConsumptionLogUncheckedUpdateManyInput>
    /**
     * Filter which ConsumptionLogs to update
     */
    where?: ConsumptionLogWhereInput
  }

  /**
   * ConsumptionLog upsert
   */
  export type ConsumptionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * The filter to search for the ConsumptionLog to update in case it exists.
     */
    where: ConsumptionLogWhereUniqueInput
    /**
     * In case the ConsumptionLog found by the `where` argument doesn't exist, create a new ConsumptionLog with this data.
     */
    create: XOR<ConsumptionLogCreateInput, ConsumptionLogUncheckedCreateInput>
    /**
     * In case the ConsumptionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsumptionLogUpdateInput, ConsumptionLogUncheckedUpdateInput>
  }

  /**
   * ConsumptionLog delete
   */
  export type ConsumptionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
    /**
     * Filter which ConsumptionLog to delete.
     */
    where: ConsumptionLogWhereUniqueInput
  }

  /**
   * ConsumptionLog deleteMany
   */
  export type ConsumptionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsumptionLogs to delete
     */
    where?: ConsumptionLogWhereInput
  }

  /**
   * ConsumptionLog without action
   */
  export type ConsumptionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsumptionLog
     */
    select?: ConsumptionLogSelect<ExtArgs> | null
  }


  /**
   * Model MealRating
   */

  export type AggregateMealRating = {
    _count: MealRatingCountAggregateOutputType | null
    _avg: MealRatingAvgAggregateOutputType | null
    _sum: MealRatingSumAggregateOutputType | null
    _min: MealRatingMinAggregateOutputType | null
    _max: MealRatingMaxAggregateOutputType | null
  }

  export type MealRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type MealRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type MealRatingMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    order_id: string | null
    rating: number | null
    feedback: string | null
    meal_type: string | null
    meal_date: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type MealRatingMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    order_id: string | null
    rating: number | null
    feedback: string | null
    meal_type: string | null
    meal_date: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type MealRatingCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    order_id: number
    rating: number
    feedback: number
    meal_type: number
    meal_date: number
    created_by: number
    created_at: number
    _all: number
  }


  export type MealRatingAvgAggregateInputType = {
    rating?: true
  }

  export type MealRatingSumAggregateInputType = {
    rating?: true
  }

  export type MealRatingMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    order_id?: true
    rating?: true
    feedback?: true
    meal_type?: true
    meal_date?: true
    created_by?: true
    created_at?: true
  }

  export type MealRatingMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    order_id?: true
    rating?: true
    feedback?: true
    meal_type?: true
    meal_date?: true
    created_by?: true
    created_at?: true
  }

  export type MealRatingCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    order_id?: true
    rating?: true
    feedback?: true
    meal_type?: true
    meal_date?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type MealRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealRating to aggregate.
     */
    where?: MealRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealRatings to fetch.
     */
    orderBy?: MealRatingOrderByWithRelationInput | MealRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MealRatings
    **/
    _count?: true | MealRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealRatingMaxAggregateInputType
  }

  export type GetMealRatingAggregateType<T extends MealRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateMealRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMealRating[P]>
      : GetScalarType<T[P], AggregateMealRating[P]>
  }




  export type MealRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealRatingWhereInput
    orderBy?: MealRatingOrderByWithAggregationInput | MealRatingOrderByWithAggregationInput[]
    by: MealRatingScalarFieldEnum[] | MealRatingScalarFieldEnum
    having?: MealRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealRatingCountAggregateInputType | true
    _avg?: MealRatingAvgAggregateInputType
    _sum?: MealRatingSumAggregateInputType
    _min?: MealRatingMinAggregateInputType
    _max?: MealRatingMaxAggregateInputType
  }

  export type MealRatingGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string | null
    order_id: string | null
    rating: number
    feedback: string | null
    meal_type: string | null
    meal_date: string | null
    created_by: string
    created_at: Date
    _count: MealRatingCountAggregateOutputType | null
    _avg: MealRatingAvgAggregateOutputType | null
    _sum: MealRatingSumAggregateOutputType | null
    _min: MealRatingMinAggregateOutputType | null
    _max: MealRatingMaxAggregateOutputType | null
  }

  type GetMealRatingGroupByPayload<T extends MealRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealRatingGroupByOutputType[P]>
            : GetScalarType<T[P], MealRatingGroupByOutputType[P]>
        }
      >
    >


  export type MealRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    order_id?: boolean
    rating?: boolean
    feedback?: boolean
    meal_type?: boolean
    meal_date?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["mealRating"]>

  export type MealRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    order_id?: boolean
    rating?: boolean
    feedback?: boolean
    meal_type?: boolean
    meal_date?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["mealRating"]>

  export type MealRatingSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    order_id?: boolean
    rating?: boolean
    feedback?: boolean
    meal_type?: boolean
    meal_date?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $MealRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MealRating"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string | null
      order_id: string | null
      rating: number
      feedback: string | null
      meal_type: string | null
      meal_date: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["mealRating"]>
    composites: {}
  }

  type MealRatingGetPayload<S extends boolean | null | undefined | MealRatingDefaultArgs> = $Result.GetResult<Prisma.$MealRatingPayload, S>

  type MealRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MealRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MealRatingCountAggregateInputType | true
    }

  export interface MealRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MealRating'], meta: { name: 'MealRating' } }
    /**
     * Find zero or one MealRating that matches the filter.
     * @param {MealRatingFindUniqueArgs} args - Arguments to find a MealRating
     * @example
     * // Get one MealRating
     * const mealRating = await prisma.mealRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealRatingFindUniqueArgs>(args: SelectSubset<T, MealRatingFindUniqueArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MealRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MealRatingFindUniqueOrThrowArgs} args - Arguments to find a MealRating
     * @example
     * // Get one MealRating
     * const mealRating = await prisma.mealRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, MealRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MealRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingFindFirstArgs} args - Arguments to find a MealRating
     * @example
     * // Get one MealRating
     * const mealRating = await prisma.mealRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealRatingFindFirstArgs>(args?: SelectSubset<T, MealRatingFindFirstArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MealRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingFindFirstOrThrowArgs} args - Arguments to find a MealRating
     * @example
     * // Get one MealRating
     * const mealRating = await prisma.mealRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, MealRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MealRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MealRatings
     * const mealRatings = await prisma.mealRating.findMany()
     * 
     * // Get first 10 MealRatings
     * const mealRatings = await prisma.mealRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealRatingWithIdOnly = await prisma.mealRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealRatingFindManyArgs>(args?: SelectSubset<T, MealRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MealRating.
     * @param {MealRatingCreateArgs} args - Arguments to create a MealRating.
     * @example
     * // Create one MealRating
     * const MealRating = await prisma.mealRating.create({
     *   data: {
     *     // ... data to create a MealRating
     *   }
     * })
     * 
     */
    create<T extends MealRatingCreateArgs>(args: SelectSubset<T, MealRatingCreateArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MealRatings.
     * @param {MealRatingCreateManyArgs} args - Arguments to create many MealRatings.
     * @example
     * // Create many MealRatings
     * const mealRating = await prisma.mealRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealRatingCreateManyArgs>(args?: SelectSubset<T, MealRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MealRatings and returns the data saved in the database.
     * @param {MealRatingCreateManyAndReturnArgs} args - Arguments to create many MealRatings.
     * @example
     * // Create many MealRatings
     * const mealRating = await prisma.mealRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MealRatings and only return the `id`
     * const mealRatingWithIdOnly = await prisma.mealRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, MealRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MealRating.
     * @param {MealRatingDeleteArgs} args - Arguments to delete one MealRating.
     * @example
     * // Delete one MealRating
     * const MealRating = await prisma.mealRating.delete({
     *   where: {
     *     // ... filter to delete one MealRating
     *   }
     * })
     * 
     */
    delete<T extends MealRatingDeleteArgs>(args: SelectSubset<T, MealRatingDeleteArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MealRating.
     * @param {MealRatingUpdateArgs} args - Arguments to update one MealRating.
     * @example
     * // Update one MealRating
     * const mealRating = await prisma.mealRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealRatingUpdateArgs>(args: SelectSubset<T, MealRatingUpdateArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MealRatings.
     * @param {MealRatingDeleteManyArgs} args - Arguments to filter MealRatings to delete.
     * @example
     * // Delete a few MealRatings
     * const { count } = await prisma.mealRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealRatingDeleteManyArgs>(args?: SelectSubset<T, MealRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MealRatings
     * const mealRating = await prisma.mealRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealRatingUpdateManyArgs>(args: SelectSubset<T, MealRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MealRating.
     * @param {MealRatingUpsertArgs} args - Arguments to update or create a MealRating.
     * @example
     * // Update or create a MealRating
     * const mealRating = await prisma.mealRating.upsert({
     *   create: {
     *     // ... data to create a MealRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MealRating we want to update
     *   }
     * })
     */
    upsert<T extends MealRatingUpsertArgs>(args: SelectSubset<T, MealRatingUpsertArgs<ExtArgs>>): Prisma__MealRatingClient<$Result.GetResult<Prisma.$MealRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MealRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingCountArgs} args - Arguments to filter MealRatings to count.
     * @example
     * // Count the number of MealRatings
     * const count = await prisma.mealRating.count({
     *   where: {
     *     // ... the filter for the MealRatings we want to count
     *   }
     * })
    **/
    count<T extends MealRatingCountArgs>(
      args?: Subset<T, MealRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MealRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealRatingAggregateArgs>(args: Subset<T, MealRatingAggregateArgs>): Prisma.PrismaPromise<GetMealRatingAggregateType<T>>

    /**
     * Group by MealRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealRatingGroupByArgs['orderBy'] }
        : { orderBy?: MealRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MealRating model
   */
  readonly fields: MealRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MealRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MealRating model
   */ 
  interface MealRatingFieldRefs {
    readonly id: FieldRef<"MealRating", 'String'>
    readonly customer_id: FieldRef<"MealRating", 'String'>
    readonly customer_name: FieldRef<"MealRating", 'String'>
    readonly order_id: FieldRef<"MealRating", 'String'>
    readonly rating: FieldRef<"MealRating", 'Int'>
    readonly feedback: FieldRef<"MealRating", 'String'>
    readonly meal_type: FieldRef<"MealRating", 'String'>
    readonly meal_date: FieldRef<"MealRating", 'String'>
    readonly created_by: FieldRef<"MealRating", 'String'>
    readonly created_at: FieldRef<"MealRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MealRating findUnique
   */
  export type MealRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter, which MealRating to fetch.
     */
    where: MealRatingWhereUniqueInput
  }

  /**
   * MealRating findUniqueOrThrow
   */
  export type MealRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter, which MealRating to fetch.
     */
    where: MealRatingWhereUniqueInput
  }

  /**
   * MealRating findFirst
   */
  export type MealRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter, which MealRating to fetch.
     */
    where?: MealRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealRatings to fetch.
     */
    orderBy?: MealRatingOrderByWithRelationInput | MealRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealRatings.
     */
    cursor?: MealRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealRatings.
     */
    distinct?: MealRatingScalarFieldEnum | MealRatingScalarFieldEnum[]
  }

  /**
   * MealRating findFirstOrThrow
   */
  export type MealRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter, which MealRating to fetch.
     */
    where?: MealRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealRatings to fetch.
     */
    orderBy?: MealRatingOrderByWithRelationInput | MealRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealRatings.
     */
    cursor?: MealRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealRatings.
     */
    distinct?: MealRatingScalarFieldEnum | MealRatingScalarFieldEnum[]
  }

  /**
   * MealRating findMany
   */
  export type MealRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter, which MealRatings to fetch.
     */
    where?: MealRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealRatings to fetch.
     */
    orderBy?: MealRatingOrderByWithRelationInput | MealRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MealRatings.
     */
    cursor?: MealRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealRatings.
     */
    skip?: number
    distinct?: MealRatingScalarFieldEnum | MealRatingScalarFieldEnum[]
  }

  /**
   * MealRating create
   */
  export type MealRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * The data needed to create a MealRating.
     */
    data: XOR<MealRatingCreateInput, MealRatingUncheckedCreateInput>
  }

  /**
   * MealRating createMany
   */
  export type MealRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MealRatings.
     */
    data: MealRatingCreateManyInput | MealRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MealRating createManyAndReturn
   */
  export type MealRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MealRatings.
     */
    data: MealRatingCreateManyInput | MealRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MealRating update
   */
  export type MealRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * The data needed to update a MealRating.
     */
    data: XOR<MealRatingUpdateInput, MealRatingUncheckedUpdateInput>
    /**
     * Choose, which MealRating to update.
     */
    where: MealRatingWhereUniqueInput
  }

  /**
   * MealRating updateMany
   */
  export type MealRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MealRatings.
     */
    data: XOR<MealRatingUpdateManyMutationInput, MealRatingUncheckedUpdateManyInput>
    /**
     * Filter which MealRatings to update
     */
    where?: MealRatingWhereInput
  }

  /**
   * MealRating upsert
   */
  export type MealRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * The filter to search for the MealRating to update in case it exists.
     */
    where: MealRatingWhereUniqueInput
    /**
     * In case the MealRating found by the `where` argument doesn't exist, create a new MealRating with this data.
     */
    create: XOR<MealRatingCreateInput, MealRatingUncheckedCreateInput>
    /**
     * In case the MealRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealRatingUpdateInput, MealRatingUncheckedUpdateInput>
  }

  /**
   * MealRating delete
   */
  export type MealRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
    /**
     * Filter which MealRating to delete.
     */
    where: MealRatingWhereUniqueInput
  }

  /**
   * MealRating deleteMany
   */
  export type MealRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealRatings to delete
     */
    where?: MealRatingWhereInput
  }

  /**
   * MealRating without action
   */
  export type MealRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealRating
     */
    select?: MealRatingSelect<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    customer_id: string | null
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
    currency: string | null
    period_start: Date | null
    period_end: Date | null
    status: string | null
    trn_number: string | null
    business_name: string | null
    business_address: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    customer_id: string | null
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
    currency: string | null
    period_start: Date | null
    period_end: Date | null
    status: string | null
    trn_number: string | null
    business_name: string | null
    business_address: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoice_number: number
    customer_id: number
    customer_name: number
    customer_phone: number
    customer_address: number
    amount: number
    tax_amount: number
    total_amount: number
    currency: number
    period_start: number
    period_end: number
    status: number
    trn_number: number
    business_name: number
    business_address: number
    notes: number
    created_by: number
    created_at: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
    tax_amount?: true
    total_amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
    tax_amount?: true
    total_amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    currency?: true
    period_start?: true
    period_end?: true
    status?: true
    trn_number?: true
    business_name?: true
    business_address?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    currency?: true
    period_start?: true
    period_end?: true
    status?: true
    trn_number?: true
    business_name?: true
    business_address?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    currency?: true
    period_start?: true
    period_end?: true
    status?: true
    trn_number?: true
    business_name?: true
    business_address?: true
    notes?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoice_number: string
    customer_id: string
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    amount: number
    tax_amount: number | null
    total_amount: number
    currency: string | null
    period_start: Date | null
    period_end: Date | null
    status: string | null
    trn_number: string | null
    business_name: string | null
    business_address: string | null
    notes: string | null
    created_by: string
    created_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    currency?: boolean
    period_start?: boolean
    period_end?: boolean
    status?: boolean
    trn_number?: boolean
    business_name?: boolean
    business_address?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    currency?: boolean
    period_start?: boolean
    period_end?: boolean
    status?: boolean
    trn_number?: boolean
    business_name?: boolean
    business_address?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    currency?: boolean
    period_start?: boolean
    period_end?: boolean
    status?: boolean
    trn_number?: boolean
    business_name?: boolean
    business_address?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_number: string
      customer_id: string
      customer_name: string | null
      customer_phone: string | null
      customer_address: string | null
      amount: number
      tax_amount: number | null
      total_amount: number
      currency: string | null
      period_start: Date | null
      period_end: Date | null
      status: string | null
      trn_number: string | null
      business_name: string | null
      business_address: string | null
      notes: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoice_number: FieldRef<"Invoice", 'String'>
    readonly customer_id: FieldRef<"Invoice", 'String'>
    readonly customer_name: FieldRef<"Invoice", 'String'>
    readonly customer_phone: FieldRef<"Invoice", 'String'>
    readonly customer_address: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly tax_amount: FieldRef<"Invoice", 'Float'>
    readonly total_amount: FieldRef<"Invoice", 'Float'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly period_start: FieldRef<"Invoice", 'DateTime'>
    readonly period_end: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly trn_number: FieldRef<"Invoice", 'String'>
    readonly business_name: FieldRef<"Invoice", 'String'>
    readonly business_address: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly created_by: FieldRef<"Invoice", 'String'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    discount_amount: number | null
  }

  export type ReferralSumAggregateOutputType = {
    discount_amount: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrer_id: string | null
    referrer_name: string | null
    referred_id: string | null
    referred_name: string | null
    referral_code: string | null
    status: string | null
    discount_amount: number | null
    discount_applied: boolean | null
    created_by: string | null
    created_at: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrer_id: string | null
    referrer_name: string | null
    referred_id: string | null
    referred_name: string | null
    referral_code: string | null
    status: string | null
    discount_amount: number | null
    discount_applied: boolean | null
    created_by: string | null
    created_at: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrer_id: number
    referrer_name: number
    referred_id: number
    referred_name: number
    referral_code: number
    status: number
    discount_amount: number
    discount_applied: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    discount_amount?: true
  }

  export type ReferralSumAggregateInputType = {
    discount_amount?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrer_id?: true
    referrer_name?: true
    referred_id?: true
    referred_name?: true
    referral_code?: true
    status?: true
    discount_amount?: true
    discount_applied?: true
    created_by?: true
    created_at?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrer_id?: true
    referrer_name?: true
    referred_id?: true
    referred_name?: true
    referral_code?: true
    status?: true
    discount_amount?: true
    discount_applied?: true
    created_by?: true
    created_at?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrer_id?: true
    referrer_name?: true
    referred_id?: true
    referred_name?: true
    referral_code?: true
    status?: true
    discount_amount?: true
    discount_applied?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrer_id: string
    referrer_name: string | null
    referred_id: string | null
    referred_name: string | null
    referral_code: string
    status: string | null
    discount_amount: number | null
    discount_applied: boolean | null
    created_by: string
    created_at: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrer_id?: boolean
    referrer_name?: boolean
    referred_id?: boolean
    referred_name?: boolean
    referral_code?: boolean
    status?: boolean
    discount_amount?: boolean
    discount_applied?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrer_id?: boolean
    referrer_name?: boolean
    referred_id?: boolean
    referred_name?: boolean
    referral_code?: boolean
    status?: boolean
    discount_amount?: boolean
    discount_applied?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrer_id?: boolean
    referrer_name?: boolean
    referred_id?: boolean
    referred_name?: boolean
    referral_code?: boolean
    status?: boolean
    discount_amount?: boolean
    discount_applied?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrer_id: string
      referrer_name: string | null
      referred_id: string | null
      referred_name: string | null
      referral_code: string
      status: string | null
      discount_amount: number | null
      discount_applied: boolean | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrer_id: FieldRef<"Referral", 'String'>
    readonly referrer_name: FieldRef<"Referral", 'String'>
    readonly referred_id: FieldRef<"Referral", 'String'>
    readonly referred_name: FieldRef<"Referral", 'String'>
    readonly referral_code: FieldRef<"Referral", 'String'>
    readonly status: FieldRef<"Referral", 'String'>
    readonly discount_amount: FieldRef<"Referral", 'Float'>
    readonly discount_applied: FieldRef<"Referral", 'Boolean'>
    readonly created_by: FieldRef<"Referral", 'String'>
    readonly created_at: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
  }


  /**
   * Model FamilyGroup
   */

  export type AggregateFamilyGroup = {
    _count: FamilyGroupCountAggregateOutputType | null
    _avg: FamilyGroupAvgAggregateOutputType | null
    _sum: FamilyGroupSumAggregateOutputType | null
    _min: FamilyGroupMinAggregateOutputType | null
    _max: FamilyGroupMaxAggregateOutputType | null
  }

  export type FamilyGroupAvgAggregateOutputType = {
    billing_amount: number | null
  }

  export type FamilyGroupSumAggregateOutputType = {
    billing_amount: number | null
  }

  export type FamilyGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    primary_contact: string | null
    primary_phone: string | null
    billing_amount: number | null
    billing_status: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FamilyGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    primary_contact: string | null
    primary_phone: string | null
    billing_amount: number | null
    billing_status: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FamilyGroupCountAggregateOutputType = {
    id: number
    name: number
    primary_contact: number
    primary_phone: number
    billing_amount: number
    billing_status: number
    notes: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FamilyGroupAvgAggregateInputType = {
    billing_amount?: true
  }

  export type FamilyGroupSumAggregateInputType = {
    billing_amount?: true
  }

  export type FamilyGroupMinAggregateInputType = {
    id?: true
    name?: true
    primary_contact?: true
    primary_phone?: true
    billing_amount?: true
    billing_status?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FamilyGroupMaxAggregateInputType = {
    id?: true
    name?: true
    primary_contact?: true
    primary_phone?: true
    billing_amount?: true
    billing_status?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type FamilyGroupCountAggregateInputType = {
    id?: true
    name?: true
    primary_contact?: true
    primary_phone?: true
    billing_amount?: true
    billing_status?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FamilyGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroup to aggregate.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyGroups
    **/
    _count?: true | FamilyGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyGroupMaxAggregateInputType
  }

  export type GetFamilyGroupAggregateType<T extends FamilyGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyGroup[P]>
      : GetScalarType<T[P], AggregateFamilyGroup[P]>
  }




  export type FamilyGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyGroupWhereInput
    orderBy?: FamilyGroupOrderByWithAggregationInput | FamilyGroupOrderByWithAggregationInput[]
    by: FamilyGroupScalarFieldEnum[] | FamilyGroupScalarFieldEnum
    having?: FamilyGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyGroupCountAggregateInputType | true
    _avg?: FamilyGroupAvgAggregateInputType
    _sum?: FamilyGroupSumAggregateInputType
    _min?: FamilyGroupMinAggregateInputType
    _max?: FamilyGroupMaxAggregateInputType
  }

  export type FamilyGroupGroupByOutputType = {
    id: string
    name: string
    primary_contact: string | null
    primary_phone: string | null
    billing_amount: number | null
    billing_status: string | null
    notes: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: FamilyGroupCountAggregateOutputType | null
    _avg: FamilyGroupAvgAggregateOutputType | null
    _sum: FamilyGroupSumAggregateOutputType | null
    _min: FamilyGroupMinAggregateOutputType | null
    _max: FamilyGroupMaxAggregateOutputType | null
  }

  type GetFamilyGroupGroupByPayload<T extends FamilyGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyGroupGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyGroupGroupByOutputType[P]>
        }
      >
    >


  export type FamilyGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    primary_contact?: boolean
    primary_phone?: boolean
    billing_amount?: boolean
    billing_status?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["familyGroup"]>

  export type FamilyGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    primary_contact?: boolean
    primary_phone?: boolean
    billing_amount?: boolean
    billing_status?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["familyGroup"]>

  export type FamilyGroupSelectScalar = {
    id?: boolean
    name?: boolean
    primary_contact?: boolean
    primary_phone?: boolean
    billing_amount?: boolean
    billing_status?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $FamilyGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyGroup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      primary_contact: string | null
      primary_phone: string | null
      billing_amount: number | null
      billing_status: string | null
      notes: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["familyGroup"]>
    composites: {}
  }

  type FamilyGroupGetPayload<S extends boolean | null | undefined | FamilyGroupDefaultArgs> = $Result.GetResult<Prisma.$FamilyGroupPayload, S>

  type FamilyGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FamilyGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FamilyGroupCountAggregateInputType | true
    }

  export interface FamilyGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyGroup'], meta: { name: 'FamilyGroup' } }
    /**
     * Find zero or one FamilyGroup that matches the filter.
     * @param {FamilyGroupFindUniqueArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyGroupFindUniqueArgs>(args: SelectSubset<T, FamilyGroupFindUniqueArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FamilyGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FamilyGroupFindUniqueOrThrowArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FamilyGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindFirstArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyGroupFindFirstArgs>(args?: SelectSubset<T, FamilyGroupFindFirstArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FamilyGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindFirstOrThrowArgs} args - Arguments to find a FamilyGroup
     * @example
     * // Get one FamilyGroup
     * const familyGroup = await prisma.familyGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FamilyGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyGroups
     * const familyGroups = await prisma.familyGroup.findMany()
     * 
     * // Get first 10 FamilyGroups
     * const familyGroups = await prisma.familyGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyGroupWithIdOnly = await prisma.familyGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyGroupFindManyArgs>(args?: SelectSubset<T, FamilyGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FamilyGroup.
     * @param {FamilyGroupCreateArgs} args - Arguments to create a FamilyGroup.
     * @example
     * // Create one FamilyGroup
     * const FamilyGroup = await prisma.familyGroup.create({
     *   data: {
     *     // ... data to create a FamilyGroup
     *   }
     * })
     * 
     */
    create<T extends FamilyGroupCreateArgs>(args: SelectSubset<T, FamilyGroupCreateArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FamilyGroups.
     * @param {FamilyGroupCreateManyArgs} args - Arguments to create many FamilyGroups.
     * @example
     * // Create many FamilyGroups
     * const familyGroup = await prisma.familyGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyGroupCreateManyArgs>(args?: SelectSubset<T, FamilyGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FamilyGroups and returns the data saved in the database.
     * @param {FamilyGroupCreateManyAndReturnArgs} args - Arguments to create many FamilyGroups.
     * @example
     * // Create many FamilyGroups
     * const familyGroup = await prisma.familyGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FamilyGroups and only return the `id`
     * const familyGroupWithIdOnly = await prisma.familyGroup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamilyGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, FamilyGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FamilyGroup.
     * @param {FamilyGroupDeleteArgs} args - Arguments to delete one FamilyGroup.
     * @example
     * // Delete one FamilyGroup
     * const FamilyGroup = await prisma.familyGroup.delete({
     *   where: {
     *     // ... filter to delete one FamilyGroup
     *   }
     * })
     * 
     */
    delete<T extends FamilyGroupDeleteArgs>(args: SelectSubset<T, FamilyGroupDeleteArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FamilyGroup.
     * @param {FamilyGroupUpdateArgs} args - Arguments to update one FamilyGroup.
     * @example
     * // Update one FamilyGroup
     * const familyGroup = await prisma.familyGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyGroupUpdateArgs>(args: SelectSubset<T, FamilyGroupUpdateArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FamilyGroups.
     * @param {FamilyGroupDeleteManyArgs} args - Arguments to filter FamilyGroups to delete.
     * @example
     * // Delete a few FamilyGroups
     * const { count } = await prisma.familyGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyGroupDeleteManyArgs>(args?: SelectSubset<T, FamilyGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyGroups
     * const familyGroup = await prisma.familyGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyGroupUpdateManyArgs>(args: SelectSubset<T, FamilyGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyGroup.
     * @param {FamilyGroupUpsertArgs} args - Arguments to update or create a FamilyGroup.
     * @example
     * // Update or create a FamilyGroup
     * const familyGroup = await prisma.familyGroup.upsert({
     *   create: {
     *     // ... data to create a FamilyGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyGroup we want to update
     *   }
     * })
     */
    upsert<T extends FamilyGroupUpsertArgs>(args: SelectSubset<T, FamilyGroupUpsertArgs<ExtArgs>>): Prisma__FamilyGroupClient<$Result.GetResult<Prisma.$FamilyGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FamilyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupCountArgs} args - Arguments to filter FamilyGroups to count.
     * @example
     * // Count the number of FamilyGroups
     * const count = await prisma.familyGroup.count({
     *   where: {
     *     // ... the filter for the FamilyGroups we want to count
     *   }
     * })
    **/
    count<T extends FamilyGroupCountArgs>(
      args?: Subset<T, FamilyGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyGroupAggregateArgs>(args: Subset<T, FamilyGroupAggregateArgs>): Prisma.PrismaPromise<GetFamilyGroupAggregateType<T>>

    /**
     * Group by FamilyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyGroupGroupByArgs['orderBy'] }
        : { orderBy?: FamilyGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyGroup model
   */
  readonly fields: FamilyGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyGroup model
   */ 
  interface FamilyGroupFieldRefs {
    readonly id: FieldRef<"FamilyGroup", 'String'>
    readonly name: FieldRef<"FamilyGroup", 'String'>
    readonly primary_contact: FieldRef<"FamilyGroup", 'String'>
    readonly primary_phone: FieldRef<"FamilyGroup", 'String'>
    readonly billing_amount: FieldRef<"FamilyGroup", 'Float'>
    readonly billing_status: FieldRef<"FamilyGroup", 'String'>
    readonly notes: FieldRef<"FamilyGroup", 'String'>
    readonly created_by: FieldRef<"FamilyGroup", 'String'>
    readonly created_at: FieldRef<"FamilyGroup", 'DateTime'>
    readonly updated_at: FieldRef<"FamilyGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyGroup findUnique
   */
  export type FamilyGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup findUniqueOrThrow
   */
  export type FamilyGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup findFirst
   */
  export type FamilyGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroups.
     */
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup findFirstOrThrow
   */
  export type FamilyGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter, which FamilyGroup to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyGroups.
     */
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup findMany
   */
  export type FamilyGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter, which FamilyGroups to fetch.
     */
    where?: FamilyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyGroups to fetch.
     */
    orderBy?: FamilyGroupOrderByWithRelationInput | FamilyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyGroups.
     */
    cursor?: FamilyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyGroups.
     */
    skip?: number
    distinct?: FamilyGroupScalarFieldEnum | FamilyGroupScalarFieldEnum[]
  }

  /**
   * FamilyGroup create
   */
  export type FamilyGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * The data needed to create a FamilyGroup.
     */
    data: XOR<FamilyGroupCreateInput, FamilyGroupUncheckedCreateInput>
  }

  /**
   * FamilyGroup createMany
   */
  export type FamilyGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyGroups.
     */
    data: FamilyGroupCreateManyInput | FamilyGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyGroup createManyAndReturn
   */
  export type FamilyGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FamilyGroups.
     */
    data: FamilyGroupCreateManyInput | FamilyGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyGroup update
   */
  export type FamilyGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * The data needed to update a FamilyGroup.
     */
    data: XOR<FamilyGroupUpdateInput, FamilyGroupUncheckedUpdateInput>
    /**
     * Choose, which FamilyGroup to update.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup updateMany
   */
  export type FamilyGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyGroups.
     */
    data: XOR<FamilyGroupUpdateManyMutationInput, FamilyGroupUncheckedUpdateManyInput>
    /**
     * Filter which FamilyGroups to update
     */
    where?: FamilyGroupWhereInput
  }

  /**
   * FamilyGroup upsert
   */
  export type FamilyGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * The filter to search for the FamilyGroup to update in case it exists.
     */
    where: FamilyGroupWhereUniqueInput
    /**
     * In case the FamilyGroup found by the `where` argument doesn't exist, create a new FamilyGroup with this data.
     */
    create: XOR<FamilyGroupCreateInput, FamilyGroupUncheckedCreateInput>
    /**
     * In case the FamilyGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyGroupUpdateInput, FamilyGroupUncheckedUpdateInput>
  }

  /**
   * FamilyGroup delete
   */
  export type FamilyGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
    /**
     * Filter which FamilyGroup to delete.
     */
    where: FamilyGroupWhereUniqueInput
  }

  /**
   * FamilyGroup deleteMany
   */
  export type FamilyGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyGroups to delete
     */
    where?: FamilyGroupWhereInput
  }

  /**
   * FamilyGroup without action
   */
  export type FamilyGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyGroup
     */
    select?: FamilyGroupSelect<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    vehicle_number: string | null
    is_active: boolean | null
    access_code: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    vehicle_number: string | null
    is_active: boolean | null
    access_code: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    vehicle_number: number
    is_active: number
    access_code: number
    created_by: number
    created_at: number
    _all: number
  }


  export type DriverMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicle_number?: true
    is_active?: true
    access_code?: true
    created_by?: true
    created_at?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicle_number?: true
    is_active?: true
    access_code?: true
    created_by?: true
    created_at?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    vehicle_number?: true
    is_active?: true
    access_code?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    vehicle_number: string | null
    is_active: boolean
    access_code: string | null
    created_by: string
    created_at: Date
    _count: DriverCountAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicle_number?: boolean
    is_active?: boolean
    access_code?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicle_number?: boolean
    is_active?: boolean
    access_code?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    vehicle_number?: boolean
    is_active?: boolean
    access_code?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      vehicle_number: string | null
      is_active: boolean
      access_code: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */ 
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'String'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly phone: FieldRef<"Driver", 'String'>
    readonly vehicle_number: FieldRef<"Driver", 'String'>
    readonly is_active: FieldRef<"Driver", 'Boolean'>
    readonly access_code: FieldRef<"Driver", 'String'>
    readonly created_by: FieldRef<"Driver", 'String'>
    readonly created_at: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
  }


  /**
   * Model DeliveryBatch
   */

  export type AggregateDeliveryBatch = {
    _count: DeliveryBatchCountAggregateOutputType | null
    _avg: DeliveryBatchAvgAggregateOutputType | null
    _sum: DeliveryBatchSumAggregateOutputType | null
    _min: DeliveryBatchMinAggregateOutputType | null
    _max: DeliveryBatchMaxAggregateOutputType | null
  }

  export type DeliveryBatchAvgAggregateOutputType = {
    total_orders: number | null
    delivered_count: number | null
  }

  export type DeliveryBatchSumAggregateOutputType = {
    total_orders: number | null
    delivered_count: number | null
  }

  export type DeliveryBatchMinAggregateOutputType = {
    id: string | null
    name: string | null
    area: string | null
    driver_id: string | null
    driver_name: string | null
    delivery_date: string | null
    status: string | null
    total_orders: number | null
    delivered_count: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type DeliveryBatchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    area: string | null
    driver_id: string | null
    driver_name: string | null
    delivery_date: string | null
    status: string | null
    total_orders: number | null
    delivered_count: number | null
    created_by: string | null
    created_at: Date | null
  }

  export type DeliveryBatchCountAggregateOutputType = {
    id: number
    name: number
    area: number
    driver_id: number
    driver_name: number
    delivery_date: number
    status: number
    total_orders: number
    delivered_count: number
    created_by: number
    created_at: number
    _all: number
  }


  export type DeliveryBatchAvgAggregateInputType = {
    total_orders?: true
    delivered_count?: true
  }

  export type DeliveryBatchSumAggregateInputType = {
    total_orders?: true
    delivered_count?: true
  }

  export type DeliveryBatchMinAggregateInputType = {
    id?: true
    name?: true
    area?: true
    driver_id?: true
    driver_name?: true
    delivery_date?: true
    status?: true
    total_orders?: true
    delivered_count?: true
    created_by?: true
    created_at?: true
  }

  export type DeliveryBatchMaxAggregateInputType = {
    id?: true
    name?: true
    area?: true
    driver_id?: true
    driver_name?: true
    delivery_date?: true
    status?: true
    total_orders?: true
    delivered_count?: true
    created_by?: true
    created_at?: true
  }

  export type DeliveryBatchCountAggregateInputType = {
    id?: true
    name?: true
    area?: true
    driver_id?: true
    driver_name?: true
    delivery_date?: true
    status?: true
    total_orders?: true
    delivered_count?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type DeliveryBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBatch to aggregate.
     */
    where?: DeliveryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBatches to fetch.
     */
    orderBy?: DeliveryBatchOrderByWithRelationInput | DeliveryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryBatches
    **/
    _count?: true | DeliveryBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryBatchMaxAggregateInputType
  }

  export type GetDeliveryBatchAggregateType<T extends DeliveryBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryBatch[P]>
      : GetScalarType<T[P], AggregateDeliveryBatch[P]>
  }




  export type DeliveryBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryBatchWhereInput
    orderBy?: DeliveryBatchOrderByWithAggregationInput | DeliveryBatchOrderByWithAggregationInput[]
    by: DeliveryBatchScalarFieldEnum[] | DeliveryBatchScalarFieldEnum
    having?: DeliveryBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryBatchCountAggregateInputType | true
    _avg?: DeliveryBatchAvgAggregateInputType
    _sum?: DeliveryBatchSumAggregateInputType
    _min?: DeliveryBatchMinAggregateInputType
    _max?: DeliveryBatchMaxAggregateInputType
  }

  export type DeliveryBatchGroupByOutputType = {
    id: string
    name: string | null
    area: string | null
    driver_id: string | null
    driver_name: string | null
    delivery_date: string
    status: string | null
    total_orders: number | null
    delivered_count: number | null
    created_by: string
    created_at: Date
    _count: DeliveryBatchCountAggregateOutputType | null
    _avg: DeliveryBatchAvgAggregateOutputType | null
    _sum: DeliveryBatchSumAggregateOutputType | null
    _min: DeliveryBatchMinAggregateOutputType | null
    _max: DeliveryBatchMaxAggregateOutputType | null
  }

  type GetDeliveryBatchGroupByPayload<T extends DeliveryBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryBatchGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryBatchGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    area?: boolean
    driver_id?: boolean
    driver_name?: boolean
    delivery_date?: boolean
    status?: boolean
    total_orders?: boolean
    delivered_count?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["deliveryBatch"]>

  export type DeliveryBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    area?: boolean
    driver_id?: boolean
    driver_name?: boolean
    delivery_date?: boolean
    status?: boolean
    total_orders?: boolean
    delivered_count?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["deliveryBatch"]>

  export type DeliveryBatchSelectScalar = {
    id?: boolean
    name?: boolean
    area?: boolean
    driver_id?: boolean
    driver_name?: boolean
    delivery_date?: boolean
    status?: boolean
    total_orders?: boolean
    delivered_count?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $DeliveryBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryBatch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      area: string | null
      driver_id: string | null
      driver_name: string | null
      delivery_date: string
      status: string | null
      total_orders: number | null
      delivered_count: number | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["deliveryBatch"]>
    composites: {}
  }

  type DeliveryBatchGetPayload<S extends boolean | null | undefined | DeliveryBatchDefaultArgs> = $Result.GetResult<Prisma.$DeliveryBatchPayload, S>

  type DeliveryBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryBatchCountAggregateInputType | true
    }

  export interface DeliveryBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryBatch'], meta: { name: 'DeliveryBatch' } }
    /**
     * Find zero or one DeliveryBatch that matches the filter.
     * @param {DeliveryBatchFindUniqueArgs} args - Arguments to find a DeliveryBatch
     * @example
     * // Get one DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryBatchFindUniqueArgs>(args: SelectSubset<T, DeliveryBatchFindUniqueArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryBatchFindUniqueOrThrowArgs} args - Arguments to find a DeliveryBatch
     * @example
     * // Get one DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchFindFirstArgs} args - Arguments to find a DeliveryBatch
     * @example
     * // Get one DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryBatchFindFirstArgs>(args?: SelectSubset<T, DeliveryBatchFindFirstArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchFindFirstOrThrowArgs} args - Arguments to find a DeliveryBatch
     * @example
     * // Get one DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryBatches
     * const deliveryBatches = await prisma.deliveryBatch.findMany()
     * 
     * // Get first 10 DeliveryBatches
     * const deliveryBatches = await prisma.deliveryBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryBatchWithIdOnly = await prisma.deliveryBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryBatchFindManyArgs>(args?: SelectSubset<T, DeliveryBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryBatch.
     * @param {DeliveryBatchCreateArgs} args - Arguments to create a DeliveryBatch.
     * @example
     * // Create one DeliveryBatch
     * const DeliveryBatch = await prisma.deliveryBatch.create({
     *   data: {
     *     // ... data to create a DeliveryBatch
     *   }
     * })
     * 
     */
    create<T extends DeliveryBatchCreateArgs>(args: SelectSubset<T, DeliveryBatchCreateArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryBatches.
     * @param {DeliveryBatchCreateManyArgs} args - Arguments to create many DeliveryBatches.
     * @example
     * // Create many DeliveryBatches
     * const deliveryBatch = await prisma.deliveryBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryBatchCreateManyArgs>(args?: SelectSubset<T, DeliveryBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryBatches and returns the data saved in the database.
     * @param {DeliveryBatchCreateManyAndReturnArgs} args - Arguments to create many DeliveryBatches.
     * @example
     * // Create many DeliveryBatches
     * const deliveryBatch = await prisma.deliveryBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryBatches and only return the `id`
     * const deliveryBatchWithIdOnly = await prisma.deliveryBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryBatch.
     * @param {DeliveryBatchDeleteArgs} args - Arguments to delete one DeliveryBatch.
     * @example
     * // Delete one DeliveryBatch
     * const DeliveryBatch = await prisma.deliveryBatch.delete({
     *   where: {
     *     // ... filter to delete one DeliveryBatch
     *   }
     * })
     * 
     */
    delete<T extends DeliveryBatchDeleteArgs>(args: SelectSubset<T, DeliveryBatchDeleteArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryBatch.
     * @param {DeliveryBatchUpdateArgs} args - Arguments to update one DeliveryBatch.
     * @example
     * // Update one DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryBatchUpdateArgs>(args: SelectSubset<T, DeliveryBatchUpdateArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryBatches.
     * @param {DeliveryBatchDeleteManyArgs} args - Arguments to filter DeliveryBatches to delete.
     * @example
     * // Delete a few DeliveryBatches
     * const { count } = await prisma.deliveryBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryBatchDeleteManyArgs>(args?: SelectSubset<T, DeliveryBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryBatches
     * const deliveryBatch = await prisma.deliveryBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryBatchUpdateManyArgs>(args: SelectSubset<T, DeliveryBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryBatch.
     * @param {DeliveryBatchUpsertArgs} args - Arguments to update or create a DeliveryBatch.
     * @example
     * // Update or create a DeliveryBatch
     * const deliveryBatch = await prisma.deliveryBatch.upsert({
     *   create: {
     *     // ... data to create a DeliveryBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryBatch we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryBatchUpsertArgs>(args: SelectSubset<T, DeliveryBatchUpsertArgs<ExtArgs>>): Prisma__DeliveryBatchClient<$Result.GetResult<Prisma.$DeliveryBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchCountArgs} args - Arguments to filter DeliveryBatches to count.
     * @example
     * // Count the number of DeliveryBatches
     * const count = await prisma.deliveryBatch.count({
     *   where: {
     *     // ... the filter for the DeliveryBatches we want to count
     *   }
     * })
    **/
    count<T extends DeliveryBatchCountArgs>(
      args?: Subset<T, DeliveryBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryBatchAggregateArgs>(args: Subset<T, DeliveryBatchAggregateArgs>): Prisma.PrismaPromise<GetDeliveryBatchAggregateType<T>>

    /**
     * Group by DeliveryBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryBatchGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryBatch model
   */
  readonly fields: DeliveryBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryBatch model
   */ 
  interface DeliveryBatchFieldRefs {
    readonly id: FieldRef<"DeliveryBatch", 'String'>
    readonly name: FieldRef<"DeliveryBatch", 'String'>
    readonly area: FieldRef<"DeliveryBatch", 'String'>
    readonly driver_id: FieldRef<"DeliveryBatch", 'String'>
    readonly driver_name: FieldRef<"DeliveryBatch", 'String'>
    readonly delivery_date: FieldRef<"DeliveryBatch", 'String'>
    readonly status: FieldRef<"DeliveryBatch", 'String'>
    readonly total_orders: FieldRef<"DeliveryBatch", 'Int'>
    readonly delivered_count: FieldRef<"DeliveryBatch", 'Int'>
    readonly created_by: FieldRef<"DeliveryBatch", 'String'>
    readonly created_at: FieldRef<"DeliveryBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryBatch findUnique
   */
  export type DeliveryBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryBatch to fetch.
     */
    where: DeliveryBatchWhereUniqueInput
  }

  /**
   * DeliveryBatch findUniqueOrThrow
   */
  export type DeliveryBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryBatch to fetch.
     */
    where: DeliveryBatchWhereUniqueInput
  }

  /**
   * DeliveryBatch findFirst
   */
  export type DeliveryBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryBatch to fetch.
     */
    where?: DeliveryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBatches to fetch.
     */
    orderBy?: DeliveryBatchOrderByWithRelationInput | DeliveryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBatches.
     */
    cursor?: DeliveryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBatches.
     */
    distinct?: DeliveryBatchScalarFieldEnum | DeliveryBatchScalarFieldEnum[]
  }

  /**
   * DeliveryBatch findFirstOrThrow
   */
  export type DeliveryBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryBatch to fetch.
     */
    where?: DeliveryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBatches to fetch.
     */
    orderBy?: DeliveryBatchOrderByWithRelationInput | DeliveryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryBatches.
     */
    cursor?: DeliveryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryBatches.
     */
    distinct?: DeliveryBatchScalarFieldEnum | DeliveryBatchScalarFieldEnum[]
  }

  /**
   * DeliveryBatch findMany
   */
  export type DeliveryBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryBatches to fetch.
     */
    where?: DeliveryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryBatches to fetch.
     */
    orderBy?: DeliveryBatchOrderByWithRelationInput | DeliveryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryBatches.
     */
    cursor?: DeliveryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryBatches.
     */
    skip?: number
    distinct?: DeliveryBatchScalarFieldEnum | DeliveryBatchScalarFieldEnum[]
  }

  /**
   * DeliveryBatch create
   */
  export type DeliveryBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * The data needed to create a DeliveryBatch.
     */
    data: XOR<DeliveryBatchCreateInput, DeliveryBatchUncheckedCreateInput>
  }

  /**
   * DeliveryBatch createMany
   */
  export type DeliveryBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryBatches.
     */
    data: DeliveryBatchCreateManyInput | DeliveryBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryBatch createManyAndReturn
   */
  export type DeliveryBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryBatches.
     */
    data: DeliveryBatchCreateManyInput | DeliveryBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryBatch update
   */
  export type DeliveryBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * The data needed to update a DeliveryBatch.
     */
    data: XOR<DeliveryBatchUpdateInput, DeliveryBatchUncheckedUpdateInput>
    /**
     * Choose, which DeliveryBatch to update.
     */
    where: DeliveryBatchWhereUniqueInput
  }

  /**
   * DeliveryBatch updateMany
   */
  export type DeliveryBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryBatches.
     */
    data: XOR<DeliveryBatchUpdateManyMutationInput, DeliveryBatchUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryBatches to update
     */
    where?: DeliveryBatchWhereInput
  }

  /**
   * DeliveryBatch upsert
   */
  export type DeliveryBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * The filter to search for the DeliveryBatch to update in case it exists.
     */
    where: DeliveryBatchWhereUniqueInput
    /**
     * In case the DeliveryBatch found by the `where` argument doesn't exist, create a new DeliveryBatch with this data.
     */
    create: XOR<DeliveryBatchCreateInput, DeliveryBatchUncheckedCreateInput>
    /**
     * In case the DeliveryBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryBatchUpdateInput, DeliveryBatchUncheckedUpdateInput>
  }

  /**
   * DeliveryBatch delete
   */
  export type DeliveryBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
    /**
     * Filter which DeliveryBatch to delete.
     */
    where: DeliveryBatchWhereUniqueInput
  }

  /**
   * DeliveryBatch deleteMany
   */
  export type DeliveryBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryBatches to delete
     */
    where?: DeliveryBatchWhereInput
  }

  /**
   * DeliveryBatch without action
   */
  export type DeliveryBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryBatch
     */
    select?: DeliveryBatchSelect<ExtArgs> | null
  }


  /**
   * Model DeliveryItem
   */

  export type AggregateDeliveryItem = {
    _count: DeliveryItemCountAggregateOutputType | null
    _avg: DeliveryItemAvgAggregateOutputType | null
    _sum: DeliveryItemSumAggregateOutputType | null
    _min: DeliveryItemMinAggregateOutputType | null
    _max: DeliveryItemMaxAggregateOutputType | null
  }

  export type DeliveryItemAvgAggregateOutputType = {
    roti_quantity: number | null
  }

  export type DeliveryItemSumAggregateOutputType = {
    roti_quantity: number | null
  }

  export type DeliveryItemMinAggregateOutputType = {
    id: string | null
    batch_id: string | null
    customer_id: string | null
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    area: string | null
    meal_type: string | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    status: string | null
    delivered_at: Date | null
    delivery_photo: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type DeliveryItemMaxAggregateOutputType = {
    id: string | null
    batch_id: string | null
    customer_id: string | null
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    area: string | null
    meal_type: string | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    status: string | null
    delivered_at: Date | null
    delivery_photo: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type DeliveryItemCountAggregateOutputType = {
    id: number
    batch_id: number
    customer_id: number
    customer_name: number
    customer_phone: number
    customer_address: number
    area: number
    meal_type: number
    roti_quantity: number
    rice_type: number
    special_notes: number
    status: number
    delivered_at: number
    delivery_photo: number
    notes: number
    created_by: number
    created_at: number
    _all: number
  }


  export type DeliveryItemAvgAggregateInputType = {
    roti_quantity?: true
  }

  export type DeliveryItemSumAggregateInputType = {
    roti_quantity?: true
  }

  export type DeliveryItemMinAggregateInputType = {
    id?: true
    batch_id?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    area?: true
    meal_type?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    status?: true
    delivered_at?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type DeliveryItemMaxAggregateInputType = {
    id?: true
    batch_id?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    area?: true
    meal_type?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    status?: true
    delivered_at?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type DeliveryItemCountAggregateInputType = {
    id?: true
    batch_id?: true
    customer_id?: true
    customer_name?: true
    customer_phone?: true
    customer_address?: true
    area?: true
    meal_type?: true
    roti_quantity?: true
    rice_type?: true
    special_notes?: true
    status?: true
    delivered_at?: true
    delivery_photo?: true
    notes?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type DeliveryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryItem to aggregate.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryItems
    **/
    _count?: true | DeliveryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryItemMaxAggregateInputType
  }

  export type GetDeliveryItemAggregateType<T extends DeliveryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryItem[P]>
      : GetScalarType<T[P], AggregateDeliveryItem[P]>
  }




  export type DeliveryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryItemWhereInput
    orderBy?: DeliveryItemOrderByWithAggregationInput | DeliveryItemOrderByWithAggregationInput[]
    by: DeliveryItemScalarFieldEnum[] | DeliveryItemScalarFieldEnum
    having?: DeliveryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryItemCountAggregateInputType | true
    _avg?: DeliveryItemAvgAggregateInputType
    _sum?: DeliveryItemSumAggregateInputType
    _min?: DeliveryItemMinAggregateInputType
    _max?: DeliveryItemMaxAggregateInputType
  }

  export type DeliveryItemGroupByOutputType = {
    id: string
    batch_id: string
    customer_id: string
    customer_name: string | null
    customer_phone: string | null
    customer_address: string | null
    area: string | null
    meal_type: string | null
    roti_quantity: number | null
    rice_type: string | null
    special_notes: string | null
    status: string | null
    delivered_at: Date | null
    delivery_photo: string | null
    notes: string | null
    created_by: string
    created_at: Date
    _count: DeliveryItemCountAggregateOutputType | null
    _avg: DeliveryItemAvgAggregateOutputType | null
    _sum: DeliveryItemSumAggregateOutputType | null
    _min: DeliveryItemMinAggregateOutputType | null
    _max: DeliveryItemMaxAggregateOutputType | null
  }

  type GetDeliveryItemGroupByPayload<T extends DeliveryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryItemGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryItemGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batch_id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    area?: boolean
    meal_type?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    status?: boolean
    delivered_at?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["deliveryItem"]>

  export type DeliveryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batch_id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    area?: boolean
    meal_type?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    status?: boolean
    delivered_at?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["deliveryItem"]>

  export type DeliveryItemSelectScalar = {
    id?: boolean
    batch_id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    customer_phone?: boolean
    customer_address?: boolean
    area?: boolean
    meal_type?: boolean
    roti_quantity?: boolean
    rice_type?: boolean
    special_notes?: boolean
    status?: boolean
    delivered_at?: boolean
    delivery_photo?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $DeliveryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batch_id: string
      customer_id: string
      customer_name: string | null
      customer_phone: string | null
      customer_address: string | null
      area: string | null
      meal_type: string | null
      roti_quantity: number | null
      rice_type: string | null
      special_notes: string | null
      status: string | null
      delivered_at: Date | null
      delivery_photo: string | null
      notes: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["deliveryItem"]>
    composites: {}
  }

  type DeliveryItemGetPayload<S extends boolean | null | undefined | DeliveryItemDefaultArgs> = $Result.GetResult<Prisma.$DeliveryItemPayload, S>

  type DeliveryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryItemCountAggregateInputType | true
    }

  export interface DeliveryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryItem'], meta: { name: 'DeliveryItem' } }
    /**
     * Find zero or one DeliveryItem that matches the filter.
     * @param {DeliveryItemFindUniqueArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryItemFindUniqueArgs>(args: SelectSubset<T, DeliveryItemFindUniqueArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryItemFindUniqueOrThrowArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindFirstArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryItemFindFirstArgs>(args?: SelectSubset<T, DeliveryItemFindFirstArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindFirstOrThrowArgs} args - Arguments to find a DeliveryItem
     * @example
     * // Get one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryItems
     * const deliveryItems = await prisma.deliveryItem.findMany()
     * 
     * // Get first 10 DeliveryItems
     * const deliveryItems = await prisma.deliveryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryItemWithIdOnly = await prisma.deliveryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryItemFindManyArgs>(args?: SelectSubset<T, DeliveryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryItem.
     * @param {DeliveryItemCreateArgs} args - Arguments to create a DeliveryItem.
     * @example
     * // Create one DeliveryItem
     * const DeliveryItem = await prisma.deliveryItem.create({
     *   data: {
     *     // ... data to create a DeliveryItem
     *   }
     * })
     * 
     */
    create<T extends DeliveryItemCreateArgs>(args: SelectSubset<T, DeliveryItemCreateArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryItems.
     * @param {DeliveryItemCreateManyArgs} args - Arguments to create many DeliveryItems.
     * @example
     * // Create many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryItemCreateManyArgs>(args?: SelectSubset<T, DeliveryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryItems and returns the data saved in the database.
     * @param {DeliveryItemCreateManyAndReturnArgs} args - Arguments to create many DeliveryItems.
     * @example
     * // Create many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryItems and only return the `id`
     * const deliveryItemWithIdOnly = await prisma.deliveryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryItem.
     * @param {DeliveryItemDeleteArgs} args - Arguments to delete one DeliveryItem.
     * @example
     * // Delete one DeliveryItem
     * const DeliveryItem = await prisma.deliveryItem.delete({
     *   where: {
     *     // ... filter to delete one DeliveryItem
     *   }
     * })
     * 
     */
    delete<T extends DeliveryItemDeleteArgs>(args: SelectSubset<T, DeliveryItemDeleteArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryItem.
     * @param {DeliveryItemUpdateArgs} args - Arguments to update one DeliveryItem.
     * @example
     * // Update one DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryItemUpdateArgs>(args: SelectSubset<T, DeliveryItemUpdateArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryItems.
     * @param {DeliveryItemDeleteManyArgs} args - Arguments to filter DeliveryItems to delete.
     * @example
     * // Delete a few DeliveryItems
     * const { count } = await prisma.deliveryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryItemDeleteManyArgs>(args?: SelectSubset<T, DeliveryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryItems
     * const deliveryItem = await prisma.deliveryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryItemUpdateManyArgs>(args: SelectSubset<T, DeliveryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryItem.
     * @param {DeliveryItemUpsertArgs} args - Arguments to update or create a DeliveryItem.
     * @example
     * // Update or create a DeliveryItem
     * const deliveryItem = await prisma.deliveryItem.upsert({
     *   create: {
     *     // ... data to create a DeliveryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryItem we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryItemUpsertArgs>(args: SelectSubset<T, DeliveryItemUpsertArgs<ExtArgs>>): Prisma__DeliveryItemClient<$Result.GetResult<Prisma.$DeliveryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemCountArgs} args - Arguments to filter DeliveryItems to count.
     * @example
     * // Count the number of DeliveryItems
     * const count = await prisma.deliveryItem.count({
     *   where: {
     *     // ... the filter for the DeliveryItems we want to count
     *   }
     * })
    **/
    count<T extends DeliveryItemCountArgs>(
      args?: Subset<T, DeliveryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryItemAggregateArgs>(args: Subset<T, DeliveryItemAggregateArgs>): Prisma.PrismaPromise<GetDeliveryItemAggregateType<T>>

    /**
     * Group by DeliveryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryItemGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryItem model
   */
  readonly fields: DeliveryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryItem model
   */ 
  interface DeliveryItemFieldRefs {
    readonly id: FieldRef<"DeliveryItem", 'String'>
    readonly batch_id: FieldRef<"DeliveryItem", 'String'>
    readonly customer_id: FieldRef<"DeliveryItem", 'String'>
    readonly customer_name: FieldRef<"DeliveryItem", 'String'>
    readonly customer_phone: FieldRef<"DeliveryItem", 'String'>
    readonly customer_address: FieldRef<"DeliveryItem", 'String'>
    readonly area: FieldRef<"DeliveryItem", 'String'>
    readonly meal_type: FieldRef<"DeliveryItem", 'String'>
    readonly roti_quantity: FieldRef<"DeliveryItem", 'Int'>
    readonly rice_type: FieldRef<"DeliveryItem", 'String'>
    readonly special_notes: FieldRef<"DeliveryItem", 'String'>
    readonly status: FieldRef<"DeliveryItem", 'String'>
    readonly delivered_at: FieldRef<"DeliveryItem", 'DateTime'>
    readonly delivery_photo: FieldRef<"DeliveryItem", 'String'>
    readonly notes: FieldRef<"DeliveryItem", 'String'>
    readonly created_by: FieldRef<"DeliveryItem", 'String'>
    readonly created_at: FieldRef<"DeliveryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryItem findUnique
   */
  export type DeliveryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem findUniqueOrThrow
   */
  export type DeliveryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem findFirst
   */
  export type DeliveryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryItems.
     */
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem findFirstOrThrow
   */
  export type DeliveryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryItem to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryItems.
     */
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem findMany
   */
  export type DeliveryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryItems to fetch.
     */
    where?: DeliveryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryItems to fetch.
     */
    orderBy?: DeliveryItemOrderByWithRelationInput | DeliveryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryItems.
     */
    cursor?: DeliveryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryItems.
     */
    skip?: number
    distinct?: DeliveryItemScalarFieldEnum | DeliveryItemScalarFieldEnum[]
  }

  /**
   * DeliveryItem create
   */
  export type DeliveryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * The data needed to create a DeliveryItem.
     */
    data: XOR<DeliveryItemCreateInput, DeliveryItemUncheckedCreateInput>
  }

  /**
   * DeliveryItem createMany
   */
  export type DeliveryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryItems.
     */
    data: DeliveryItemCreateManyInput | DeliveryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryItem createManyAndReturn
   */
  export type DeliveryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryItems.
     */
    data: DeliveryItemCreateManyInput | DeliveryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryItem update
   */
  export type DeliveryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * The data needed to update a DeliveryItem.
     */
    data: XOR<DeliveryItemUpdateInput, DeliveryItemUncheckedUpdateInput>
    /**
     * Choose, which DeliveryItem to update.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem updateMany
   */
  export type DeliveryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryItems.
     */
    data: XOR<DeliveryItemUpdateManyMutationInput, DeliveryItemUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryItems to update
     */
    where?: DeliveryItemWhereInput
  }

  /**
   * DeliveryItem upsert
   */
  export type DeliveryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * The filter to search for the DeliveryItem to update in case it exists.
     */
    where: DeliveryItemWhereUniqueInput
    /**
     * In case the DeliveryItem found by the `where` argument doesn't exist, create a new DeliveryItem with this data.
     */
    create: XOR<DeliveryItemCreateInput, DeliveryItemUncheckedCreateInput>
    /**
     * In case the DeliveryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryItemUpdateInput, DeliveryItemUncheckedUpdateInput>
  }

  /**
   * DeliveryItem delete
   */
  export type DeliveryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
    /**
     * Filter which DeliveryItem to delete.
     */
    where: DeliveryItemWhereUniqueInput
  }

  /**
   * DeliveryItem deleteMany
   */
  export type DeliveryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryItems to delete
     */
    where?: DeliveryItemWhereInput
  }

  /**
   * DeliveryItem without action
   */
  export type DeliveryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryItem
     */
    select?: DeliveryItemSelect<ExtArgs> | null
  }


  /**
   * Model Container
   */

  export type AggregateContainer = {
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  export type ContainerAvgAggregateOutputType = {
    given_count: number | null
    returned_count: number | null
    outstanding: number | null
    deposit_amount: number | null
  }

  export type ContainerSumAggregateOutputType = {
    given_count: number | null
    returned_count: number | null
    outstanding: number | null
    deposit_amount: number | null
  }

  export type ContainerMinAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    container_type: string | null
    given_date: Date | null
    given_count: number | null
    returned_count: number | null
    outstanding: number | null
    deposit_amount: number | null
    deposit_paid: boolean | null
    last_reminder: Date | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ContainerMaxAggregateOutputType = {
    id: string | null
    customer_id: string | null
    customer_name: string | null
    container_type: string | null
    given_date: Date | null
    given_count: number | null
    returned_count: number | null
    outstanding: number | null
    deposit_amount: number | null
    deposit_paid: boolean | null
    last_reminder: Date | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ContainerCountAggregateOutputType = {
    id: number
    customer_id: number
    customer_name: number
    container_type: number
    given_date: number
    given_count: number
    returned_count: number
    outstanding: number
    deposit_amount: number
    deposit_paid: number
    last_reminder: number
    notes: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ContainerAvgAggregateInputType = {
    given_count?: true
    returned_count?: true
    outstanding?: true
    deposit_amount?: true
  }

  export type ContainerSumAggregateInputType = {
    given_count?: true
    returned_count?: true
    outstanding?: true
    deposit_amount?: true
  }

  export type ContainerMinAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    container_type?: true
    given_date?: true
    given_count?: true
    returned_count?: true
    outstanding?: true
    deposit_amount?: true
    deposit_paid?: true
    last_reminder?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ContainerMaxAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    container_type?: true
    given_date?: true
    given_count?: true
    returned_count?: true
    outstanding?: true
    deposit_amount?: true
    deposit_paid?: true
    last_reminder?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type ContainerCountAggregateInputType = {
    id?: true
    customer_id?: true
    customer_name?: true
    container_type?: true
    given_date?: true
    given_count?: true
    returned_count?: true
    outstanding?: true
    deposit_amount?: true
    deposit_paid?: true
    last_reminder?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ContainerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Container to aggregate.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Containers
    **/
    _count?: true | ContainerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerMaxAggregateInputType
  }

  export type GetContainerAggregateType<T extends ContainerAggregateArgs> = {
        [P in keyof T & keyof AggregateContainer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainer[P]>
      : GetScalarType<T[P], AggregateContainer[P]>
  }




  export type ContainerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerWhereInput
    orderBy?: ContainerOrderByWithAggregationInput | ContainerOrderByWithAggregationInput[]
    by: ContainerScalarFieldEnum[] | ContainerScalarFieldEnum
    having?: ContainerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerCountAggregateInputType | true
    _avg?: ContainerAvgAggregateInputType
    _sum?: ContainerSumAggregateInputType
    _min?: ContainerMinAggregateInputType
    _max?: ContainerMaxAggregateInputType
  }

  export type ContainerGroupByOutputType = {
    id: string
    customer_id: string
    customer_name: string | null
    container_type: string | null
    given_date: Date | null
    given_count: number
    returned_count: number
    outstanding: number
    deposit_amount: number | null
    deposit_paid: boolean | null
    last_reminder: Date | null
    notes: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: ContainerCountAggregateOutputType | null
    _avg: ContainerAvgAggregateOutputType | null
    _sum: ContainerSumAggregateOutputType | null
    _min: ContainerMinAggregateOutputType | null
    _max: ContainerMaxAggregateOutputType | null
  }

  type GetContainerGroupByPayload<T extends ContainerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerGroupByOutputType[P]>
        }
      >
    >


  export type ContainerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    container_type?: boolean
    given_date?: boolean
    given_count?: boolean
    returned_count?: boolean
    outstanding?: boolean
    deposit_amount?: boolean
    deposit_paid?: boolean
    last_reminder?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    container_type?: boolean
    given_date?: boolean
    given_count?: boolean
    returned_count?: boolean
    outstanding?: boolean
    deposit_amount?: boolean
    deposit_paid?: boolean
    last_reminder?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["container"]>

  export type ContainerSelectScalar = {
    id?: boolean
    customer_id?: boolean
    customer_name?: boolean
    container_type?: boolean
    given_date?: boolean
    given_count?: boolean
    returned_count?: boolean
    outstanding?: boolean
    deposit_amount?: boolean
    deposit_paid?: boolean
    last_reminder?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $ContainerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Container"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_id: string
      customer_name: string | null
      container_type: string | null
      given_date: Date | null
      given_count: number
      returned_count: number
      outstanding: number
      deposit_amount: number | null
      deposit_paid: boolean | null
      last_reminder: Date | null
      notes: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["container"]>
    composites: {}
  }

  type ContainerGetPayload<S extends boolean | null | undefined | ContainerDefaultArgs> = $Result.GetResult<Prisma.$ContainerPayload, S>

  type ContainerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContainerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContainerCountAggregateInputType | true
    }

  export interface ContainerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Container'], meta: { name: 'Container' } }
    /**
     * Find zero or one Container that matches the filter.
     * @param {ContainerFindUniqueArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerFindUniqueArgs>(args: SelectSubset<T, ContainerFindUniqueArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Container that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContainerFindUniqueOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Container that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerFindFirstArgs>(args?: SelectSubset<T, ContainerFindFirstArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Container that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindFirstOrThrowArgs} args - Arguments to find a Container
     * @example
     * // Get one Container
     * const container = await prisma.container.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Containers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Containers
     * const containers = await prisma.container.findMany()
     * 
     * // Get first 10 Containers
     * const containers = await prisma.container.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerWithIdOnly = await prisma.container.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerFindManyArgs>(args?: SelectSubset<T, ContainerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Container.
     * @param {ContainerCreateArgs} args - Arguments to create a Container.
     * @example
     * // Create one Container
     * const Container = await prisma.container.create({
     *   data: {
     *     // ... data to create a Container
     *   }
     * })
     * 
     */
    create<T extends ContainerCreateArgs>(args: SelectSubset<T, ContainerCreateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Containers.
     * @param {ContainerCreateManyArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerCreateManyArgs>(args?: SelectSubset<T, ContainerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Containers and returns the data saved in the database.
     * @param {ContainerCreateManyAndReturnArgs} args - Arguments to create many Containers.
     * @example
     * // Create many Containers
     * const container = await prisma.container.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Containers and only return the `id`
     * const containerWithIdOnly = await prisma.container.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Container.
     * @param {ContainerDeleteArgs} args - Arguments to delete one Container.
     * @example
     * // Delete one Container
     * const Container = await prisma.container.delete({
     *   where: {
     *     // ... filter to delete one Container
     *   }
     * })
     * 
     */
    delete<T extends ContainerDeleteArgs>(args: SelectSubset<T, ContainerDeleteArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Container.
     * @param {ContainerUpdateArgs} args - Arguments to update one Container.
     * @example
     * // Update one Container
     * const container = await prisma.container.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerUpdateArgs>(args: SelectSubset<T, ContainerUpdateArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Containers.
     * @param {ContainerDeleteManyArgs} args - Arguments to filter Containers to delete.
     * @example
     * // Delete a few Containers
     * const { count } = await prisma.container.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerDeleteManyArgs>(args?: SelectSubset<T, ContainerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Containers
     * const container = await prisma.container.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerUpdateManyArgs>(args: SelectSubset<T, ContainerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Container.
     * @param {ContainerUpsertArgs} args - Arguments to update or create a Container.
     * @example
     * // Update or create a Container
     * const container = await prisma.container.upsert({
     *   create: {
     *     // ... data to create a Container
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Container we want to update
     *   }
     * })
     */
    upsert<T extends ContainerUpsertArgs>(args: SelectSubset<T, ContainerUpsertArgs<ExtArgs>>): Prisma__ContainerClient<$Result.GetResult<Prisma.$ContainerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Containers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerCountArgs} args - Arguments to filter Containers to count.
     * @example
     * // Count the number of Containers
     * const count = await prisma.container.count({
     *   where: {
     *     // ... the filter for the Containers we want to count
     *   }
     * })
    **/
    count<T extends ContainerCountArgs>(
      args?: Subset<T, ContainerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerAggregateArgs>(args: Subset<T, ContainerAggregateArgs>): Prisma.PrismaPromise<GetContainerAggregateType<T>>

    /**
     * Group by Container.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerGroupByArgs['orderBy'] }
        : { orderBy?: ContainerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Container model
   */
  readonly fields: ContainerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Container.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Container model
   */ 
  interface ContainerFieldRefs {
    readonly id: FieldRef<"Container", 'String'>
    readonly customer_id: FieldRef<"Container", 'String'>
    readonly customer_name: FieldRef<"Container", 'String'>
    readonly container_type: FieldRef<"Container", 'String'>
    readonly given_date: FieldRef<"Container", 'DateTime'>
    readonly given_count: FieldRef<"Container", 'Int'>
    readonly returned_count: FieldRef<"Container", 'Int'>
    readonly outstanding: FieldRef<"Container", 'Int'>
    readonly deposit_amount: FieldRef<"Container", 'Float'>
    readonly deposit_paid: FieldRef<"Container", 'Boolean'>
    readonly last_reminder: FieldRef<"Container", 'DateTime'>
    readonly notes: FieldRef<"Container", 'String'>
    readonly created_by: FieldRef<"Container", 'String'>
    readonly created_at: FieldRef<"Container", 'DateTime'>
    readonly updated_at: FieldRef<"Container", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Container findUnique
   */
  export type ContainerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findUniqueOrThrow
   */
  export type ContainerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container findFirst
   */
  export type ContainerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findFirstOrThrow
   */
  export type ContainerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter, which Container to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Containers.
     */
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container findMany
   */
  export type ContainerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter, which Containers to fetch.
     */
    where?: ContainerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Containers to fetch.
     */
    orderBy?: ContainerOrderByWithRelationInput | ContainerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Containers.
     */
    cursor?: ContainerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Containers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Containers.
     */
    skip?: number
    distinct?: ContainerScalarFieldEnum | ContainerScalarFieldEnum[]
  }

  /**
   * Container create
   */
  export type ContainerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * The data needed to create a Container.
     */
    data: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
  }

  /**
   * Container createMany
   */
  export type ContainerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Container createManyAndReturn
   */
  export type ContainerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Containers.
     */
    data: ContainerCreateManyInput | ContainerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Container update
   */
  export type ContainerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * The data needed to update a Container.
     */
    data: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
    /**
     * Choose, which Container to update.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container updateMany
   */
  export type ContainerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Containers.
     */
    data: XOR<ContainerUpdateManyMutationInput, ContainerUncheckedUpdateManyInput>
    /**
     * Filter which Containers to update
     */
    where?: ContainerWhereInput
  }

  /**
   * Container upsert
   */
  export type ContainerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * The filter to search for the Container to update in case it exists.
     */
    where: ContainerWhereUniqueInput
    /**
     * In case the Container found by the `where` argument doesn't exist, create a new Container with this data.
     */
    create: XOR<ContainerCreateInput, ContainerUncheckedCreateInput>
    /**
     * In case the Container was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerUpdateInput, ContainerUncheckedUpdateInput>
  }

  /**
   * Container delete
   */
  export type ContainerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
    /**
     * Filter which Container to delete.
     */
    where: ContainerWhereUniqueInput
  }

  /**
   * Container deleteMany
   */
  export type ContainerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Containers to delete
     */
    where?: ContainerWhereInput
  }

  /**
   * Container without action
   */
  export type ContainerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Container
     */
    select?: ContainerSelect<ExtArgs> | null
  }


  /**
   * Model ContainerLog
   */

  export type AggregateContainerLog = {
    _count: ContainerLogCountAggregateOutputType | null
    _avg: ContainerLogAvgAggregateOutputType | null
    _sum: ContainerLogSumAggregateOutputType | null
    _min: ContainerLogMinAggregateOutputType | null
    _max: ContainerLogMaxAggregateOutputType | null
  }

  export type ContainerLogAvgAggregateOutputType = {
    count: number | null
  }

  export type ContainerLogSumAggregateOutputType = {
    count: number | null
  }

  export type ContainerLogMinAggregateOutputType = {
    id: string | null
    container_id: string | null
    customer_id: string | null
    action: string | null
    count: number | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ContainerLogMaxAggregateOutputType = {
    id: string | null
    container_id: string | null
    customer_id: string | null
    action: string | null
    count: number | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ContainerLogCountAggregateOutputType = {
    id: number
    container_id: number
    customer_id: number
    action: number
    count: number
    notes: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ContainerLogAvgAggregateInputType = {
    count?: true
  }

  export type ContainerLogSumAggregateInputType = {
    count?: true
  }

  export type ContainerLogMinAggregateInputType = {
    id?: true
    container_id?: true
    customer_id?: true
    action?: true
    count?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type ContainerLogMaxAggregateInputType = {
    id?: true
    container_id?: true
    customer_id?: true
    action?: true
    count?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type ContainerLogCountAggregateInputType = {
    id?: true
    container_id?: true
    customer_id?: true
    action?: true
    count?: true
    notes?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ContainerLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerLog to aggregate.
     */
    where?: ContainerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerLogs to fetch.
     */
    orderBy?: ContainerLogOrderByWithRelationInput | ContainerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContainerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContainerLogs
    **/
    _count?: true | ContainerLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContainerLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContainerLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContainerLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContainerLogMaxAggregateInputType
  }

  export type GetContainerLogAggregateType<T extends ContainerLogAggregateArgs> = {
        [P in keyof T & keyof AggregateContainerLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainerLog[P]>
      : GetScalarType<T[P], AggregateContainerLog[P]>
  }




  export type ContainerLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContainerLogWhereInput
    orderBy?: ContainerLogOrderByWithAggregationInput | ContainerLogOrderByWithAggregationInput[]
    by: ContainerLogScalarFieldEnum[] | ContainerLogScalarFieldEnum
    having?: ContainerLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContainerLogCountAggregateInputType | true
    _avg?: ContainerLogAvgAggregateInputType
    _sum?: ContainerLogSumAggregateInputType
    _min?: ContainerLogMinAggregateInputType
    _max?: ContainerLogMaxAggregateInputType
  }

  export type ContainerLogGroupByOutputType = {
    id: string
    container_id: string
    customer_id: string
    action: string
    count: number
    notes: string | null
    created_by: string
    created_at: Date
    _count: ContainerLogCountAggregateOutputType | null
    _avg: ContainerLogAvgAggregateOutputType | null
    _sum: ContainerLogSumAggregateOutputType | null
    _min: ContainerLogMinAggregateOutputType | null
    _max: ContainerLogMaxAggregateOutputType | null
  }

  type GetContainerLogGroupByPayload<T extends ContainerLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContainerLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContainerLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContainerLogGroupByOutputType[P]>
            : GetScalarType<T[P], ContainerLogGroupByOutputType[P]>
        }
      >
    >


  export type ContainerLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    container_id?: boolean
    customer_id?: boolean
    action?: boolean
    count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["containerLog"]>

  export type ContainerLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    container_id?: boolean
    customer_id?: boolean
    action?: boolean
    count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["containerLog"]>

  export type ContainerLogSelectScalar = {
    id?: boolean
    container_id?: boolean
    customer_id?: boolean
    action?: boolean
    count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $ContainerLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContainerLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      container_id: string
      customer_id: string
      action: string
      count: number
      notes: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["containerLog"]>
    composites: {}
  }

  type ContainerLogGetPayload<S extends boolean | null | undefined | ContainerLogDefaultArgs> = $Result.GetResult<Prisma.$ContainerLogPayload, S>

  type ContainerLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContainerLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContainerLogCountAggregateInputType | true
    }

  export interface ContainerLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContainerLog'], meta: { name: 'ContainerLog' } }
    /**
     * Find zero or one ContainerLog that matches the filter.
     * @param {ContainerLogFindUniqueArgs} args - Arguments to find a ContainerLog
     * @example
     * // Get one ContainerLog
     * const containerLog = await prisma.containerLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContainerLogFindUniqueArgs>(args: SelectSubset<T, ContainerLogFindUniqueArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContainerLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContainerLogFindUniqueOrThrowArgs} args - Arguments to find a ContainerLog
     * @example
     * // Get one ContainerLog
     * const containerLog = await prisma.containerLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContainerLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ContainerLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContainerLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogFindFirstArgs} args - Arguments to find a ContainerLog
     * @example
     * // Get one ContainerLog
     * const containerLog = await prisma.containerLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContainerLogFindFirstArgs>(args?: SelectSubset<T, ContainerLogFindFirstArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContainerLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogFindFirstOrThrowArgs} args - Arguments to find a ContainerLog
     * @example
     * // Get one ContainerLog
     * const containerLog = await prisma.containerLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContainerLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ContainerLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContainerLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContainerLogs
     * const containerLogs = await prisma.containerLog.findMany()
     * 
     * // Get first 10 ContainerLogs
     * const containerLogs = await prisma.containerLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const containerLogWithIdOnly = await prisma.containerLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContainerLogFindManyArgs>(args?: SelectSubset<T, ContainerLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContainerLog.
     * @param {ContainerLogCreateArgs} args - Arguments to create a ContainerLog.
     * @example
     * // Create one ContainerLog
     * const ContainerLog = await prisma.containerLog.create({
     *   data: {
     *     // ... data to create a ContainerLog
     *   }
     * })
     * 
     */
    create<T extends ContainerLogCreateArgs>(args: SelectSubset<T, ContainerLogCreateArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContainerLogs.
     * @param {ContainerLogCreateManyArgs} args - Arguments to create many ContainerLogs.
     * @example
     * // Create many ContainerLogs
     * const containerLog = await prisma.containerLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContainerLogCreateManyArgs>(args?: SelectSubset<T, ContainerLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContainerLogs and returns the data saved in the database.
     * @param {ContainerLogCreateManyAndReturnArgs} args - Arguments to create many ContainerLogs.
     * @example
     * // Create many ContainerLogs
     * const containerLog = await prisma.containerLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContainerLogs and only return the `id`
     * const containerLogWithIdOnly = await prisma.containerLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContainerLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ContainerLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContainerLog.
     * @param {ContainerLogDeleteArgs} args - Arguments to delete one ContainerLog.
     * @example
     * // Delete one ContainerLog
     * const ContainerLog = await prisma.containerLog.delete({
     *   where: {
     *     // ... filter to delete one ContainerLog
     *   }
     * })
     * 
     */
    delete<T extends ContainerLogDeleteArgs>(args: SelectSubset<T, ContainerLogDeleteArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContainerLog.
     * @param {ContainerLogUpdateArgs} args - Arguments to update one ContainerLog.
     * @example
     * // Update one ContainerLog
     * const containerLog = await prisma.containerLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContainerLogUpdateArgs>(args: SelectSubset<T, ContainerLogUpdateArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContainerLogs.
     * @param {ContainerLogDeleteManyArgs} args - Arguments to filter ContainerLogs to delete.
     * @example
     * // Delete a few ContainerLogs
     * const { count } = await prisma.containerLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContainerLogDeleteManyArgs>(args?: SelectSubset<T, ContainerLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContainerLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContainerLogs
     * const containerLog = await prisma.containerLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContainerLogUpdateManyArgs>(args: SelectSubset<T, ContainerLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContainerLog.
     * @param {ContainerLogUpsertArgs} args - Arguments to update or create a ContainerLog.
     * @example
     * // Update or create a ContainerLog
     * const containerLog = await prisma.containerLog.upsert({
     *   create: {
     *     // ... data to create a ContainerLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContainerLog we want to update
     *   }
     * })
     */
    upsert<T extends ContainerLogUpsertArgs>(args: SelectSubset<T, ContainerLogUpsertArgs<ExtArgs>>): Prisma__ContainerLogClient<$Result.GetResult<Prisma.$ContainerLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContainerLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogCountArgs} args - Arguments to filter ContainerLogs to count.
     * @example
     * // Count the number of ContainerLogs
     * const count = await prisma.containerLog.count({
     *   where: {
     *     // ... the filter for the ContainerLogs we want to count
     *   }
     * })
    **/
    count<T extends ContainerLogCountArgs>(
      args?: Subset<T, ContainerLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContainerLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContainerLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContainerLogAggregateArgs>(args: Subset<T, ContainerLogAggregateArgs>): Prisma.PrismaPromise<GetContainerLogAggregateType<T>>

    /**
     * Group by ContainerLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContainerLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContainerLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContainerLogGroupByArgs['orderBy'] }
        : { orderBy?: ContainerLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContainerLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainerLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContainerLog model
   */
  readonly fields: ContainerLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContainerLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContainerLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContainerLog model
   */ 
  interface ContainerLogFieldRefs {
    readonly id: FieldRef<"ContainerLog", 'String'>
    readonly container_id: FieldRef<"ContainerLog", 'String'>
    readonly customer_id: FieldRef<"ContainerLog", 'String'>
    readonly action: FieldRef<"ContainerLog", 'String'>
    readonly count: FieldRef<"ContainerLog", 'Int'>
    readonly notes: FieldRef<"ContainerLog", 'String'>
    readonly created_by: FieldRef<"ContainerLog", 'String'>
    readonly created_at: FieldRef<"ContainerLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContainerLog findUnique
   */
  export type ContainerLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter, which ContainerLog to fetch.
     */
    where: ContainerLogWhereUniqueInput
  }

  /**
   * ContainerLog findUniqueOrThrow
   */
  export type ContainerLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter, which ContainerLog to fetch.
     */
    where: ContainerLogWhereUniqueInput
  }

  /**
   * ContainerLog findFirst
   */
  export type ContainerLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter, which ContainerLog to fetch.
     */
    where?: ContainerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerLogs to fetch.
     */
    orderBy?: ContainerLogOrderByWithRelationInput | ContainerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerLogs.
     */
    cursor?: ContainerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerLogs.
     */
    distinct?: ContainerLogScalarFieldEnum | ContainerLogScalarFieldEnum[]
  }

  /**
   * ContainerLog findFirstOrThrow
   */
  export type ContainerLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter, which ContainerLog to fetch.
     */
    where?: ContainerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerLogs to fetch.
     */
    orderBy?: ContainerLogOrderByWithRelationInput | ContainerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContainerLogs.
     */
    cursor?: ContainerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContainerLogs.
     */
    distinct?: ContainerLogScalarFieldEnum | ContainerLogScalarFieldEnum[]
  }

  /**
   * ContainerLog findMany
   */
  export type ContainerLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter, which ContainerLogs to fetch.
     */
    where?: ContainerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContainerLogs to fetch.
     */
    orderBy?: ContainerLogOrderByWithRelationInput | ContainerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContainerLogs.
     */
    cursor?: ContainerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContainerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContainerLogs.
     */
    skip?: number
    distinct?: ContainerLogScalarFieldEnum | ContainerLogScalarFieldEnum[]
  }

  /**
   * ContainerLog create
   */
  export type ContainerLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * The data needed to create a ContainerLog.
     */
    data: XOR<ContainerLogCreateInput, ContainerLogUncheckedCreateInput>
  }

  /**
   * ContainerLog createMany
   */
  export type ContainerLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContainerLogs.
     */
    data: ContainerLogCreateManyInput | ContainerLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerLog createManyAndReturn
   */
  export type ContainerLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContainerLogs.
     */
    data: ContainerLogCreateManyInput | ContainerLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContainerLog update
   */
  export type ContainerLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * The data needed to update a ContainerLog.
     */
    data: XOR<ContainerLogUpdateInput, ContainerLogUncheckedUpdateInput>
    /**
     * Choose, which ContainerLog to update.
     */
    where: ContainerLogWhereUniqueInput
  }

  /**
   * ContainerLog updateMany
   */
  export type ContainerLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContainerLogs.
     */
    data: XOR<ContainerLogUpdateManyMutationInput, ContainerLogUncheckedUpdateManyInput>
    /**
     * Filter which ContainerLogs to update
     */
    where?: ContainerLogWhereInput
  }

  /**
   * ContainerLog upsert
   */
  export type ContainerLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * The filter to search for the ContainerLog to update in case it exists.
     */
    where: ContainerLogWhereUniqueInput
    /**
     * In case the ContainerLog found by the `where` argument doesn't exist, create a new ContainerLog with this data.
     */
    create: XOR<ContainerLogCreateInput, ContainerLogUncheckedCreateInput>
    /**
     * In case the ContainerLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContainerLogUpdateInput, ContainerLogUncheckedUpdateInput>
  }

  /**
   * ContainerLog delete
   */
  export type ContainerLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
    /**
     * Filter which ContainerLog to delete.
     */
    where: ContainerLogWhereUniqueInput
  }

  /**
   * ContainerLog deleteMany
   */
  export type ContainerLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContainerLogs to delete
     */
    where?: ContainerLogWhereInput
  }

  /**
   * ContainerLog without action
   */
  export type ContainerLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContainerLog
     */
    select?: ContainerLogSelect<ExtArgs> | null
  }


  /**
   * Model Kitchen
   */

  export type AggregateKitchen = {
    _count: KitchenCountAggregateOutputType | null
    _avg: KitchenAvgAggregateOutputType | null
    _sum: KitchenSumAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  export type KitchenAvgAggregateOutputType = {
    capacity: number | null
  }

  export type KitchenSumAggregateOutputType = {
    capacity: number | null
  }

  export type KitchenMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    manager_name: string | null
    capacity: number | null
    areas_served: string | null
    is_active: boolean | null
    created_by: string | null
    created_at: Date | null
  }

  export type KitchenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    manager_name: string | null
    capacity: number | null
    areas_served: string | null
    is_active: boolean | null
    created_by: string | null
    created_at: Date | null
  }

  export type KitchenCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    manager_name: number
    capacity: number
    areas_served: number
    is_active: number
    created_by: number
    created_at: number
    _all: number
  }


  export type KitchenAvgAggregateInputType = {
    capacity?: true
  }

  export type KitchenSumAggregateInputType = {
    capacity?: true
  }

  export type KitchenMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    manager_name?: true
    capacity?: true
    areas_served?: true
    is_active?: true
    created_by?: true
    created_at?: true
  }

  export type KitchenMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    manager_name?: true
    capacity?: true
    areas_served?: true
    is_active?: true
    created_by?: true
    created_at?: true
  }

  export type KitchenCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    manager_name?: true
    capacity?: true
    areas_served?: true
    is_active?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type KitchenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchen to aggregate.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kitchens
    **/
    _count?: true | KitchenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitchenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitchenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitchenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitchenMaxAggregateInputType
  }

  export type GetKitchenAggregateType<T extends KitchenAggregateArgs> = {
        [P in keyof T & keyof AggregateKitchen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchen[P]>
      : GetScalarType<T[P], AggregateKitchen[P]>
  }




  export type KitchenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenWhereInput
    orderBy?: KitchenOrderByWithAggregationInput | KitchenOrderByWithAggregationInput[]
    by: KitchenScalarFieldEnum[] | KitchenScalarFieldEnum
    having?: KitchenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitchenCountAggregateInputType | true
    _avg?: KitchenAvgAggregateInputType
    _sum?: KitchenSumAggregateInputType
    _min?: KitchenMinAggregateInputType
    _max?: KitchenMaxAggregateInputType
  }

  export type KitchenGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    manager_name: string | null
    capacity: number | null
    areas_served: string | null
    is_active: boolean
    created_by: string
    created_at: Date
    _count: KitchenCountAggregateOutputType | null
    _avg: KitchenAvgAggregateOutputType | null
    _sum: KitchenSumAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  type GetKitchenGroupByPayload<T extends KitchenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitchenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitchenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitchenGroupByOutputType[P]>
            : GetScalarType<T[P], KitchenGroupByOutputType[P]>
        }
      >
    >


  export type KitchenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    manager_name?: boolean
    capacity?: boolean
    areas_served?: boolean
    is_active?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    manager_name?: boolean
    capacity?: boolean
    areas_served?: boolean
    is_active?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    manager_name?: boolean
    capacity?: boolean
    areas_served?: boolean
    is_active?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $KitchenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kitchen"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      manager_name: string | null
      capacity: number | null
      areas_served: string | null
      is_active: boolean
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["kitchen"]>
    composites: {}
  }

  type KitchenGetPayload<S extends boolean | null | undefined | KitchenDefaultArgs> = $Result.GetResult<Prisma.$KitchenPayload, S>

  type KitchenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KitchenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KitchenCountAggregateInputType | true
    }

  export interface KitchenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kitchen'], meta: { name: 'Kitchen' } }
    /**
     * Find zero or one Kitchen that matches the filter.
     * @param {KitchenFindUniqueArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitchenFindUniqueArgs>(args: SelectSubset<T, KitchenFindUniqueArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kitchen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KitchenFindUniqueOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitchenFindUniqueOrThrowArgs>(args: SelectSubset<T, KitchenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kitchen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitchenFindFirstArgs>(args?: SelectSubset<T, KitchenFindFirstArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kitchen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitchenFindFirstOrThrowArgs>(args?: SelectSubset<T, KitchenFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kitchens
     * const kitchens = await prisma.kitchen.findMany()
     * 
     * // Get first 10 Kitchens
     * const kitchens = await prisma.kitchen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitchenFindManyArgs>(args?: SelectSubset<T, KitchenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kitchen.
     * @param {KitchenCreateArgs} args - Arguments to create a Kitchen.
     * @example
     * // Create one Kitchen
     * const Kitchen = await prisma.kitchen.create({
     *   data: {
     *     // ... data to create a Kitchen
     *   }
     * })
     * 
     */
    create<T extends KitchenCreateArgs>(args: SelectSubset<T, KitchenCreateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kitchens.
     * @param {KitchenCreateManyArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitchenCreateManyArgs>(args?: SelectSubset<T, KitchenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kitchens and returns the data saved in the database.
     * @param {KitchenCreateManyAndReturnArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kitchens and only return the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitchenCreateManyAndReturnArgs>(args?: SelectSubset<T, KitchenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kitchen.
     * @param {KitchenDeleteArgs} args - Arguments to delete one Kitchen.
     * @example
     * // Delete one Kitchen
     * const Kitchen = await prisma.kitchen.delete({
     *   where: {
     *     // ... filter to delete one Kitchen
     *   }
     * })
     * 
     */
    delete<T extends KitchenDeleteArgs>(args: SelectSubset<T, KitchenDeleteArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kitchen.
     * @param {KitchenUpdateArgs} args - Arguments to update one Kitchen.
     * @example
     * // Update one Kitchen
     * const kitchen = await prisma.kitchen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitchenUpdateArgs>(args: SelectSubset<T, KitchenUpdateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kitchens.
     * @param {KitchenDeleteManyArgs} args - Arguments to filter Kitchens to delete.
     * @example
     * // Delete a few Kitchens
     * const { count } = await prisma.kitchen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitchenDeleteManyArgs>(args?: SelectSubset<T, KitchenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitchenUpdateManyArgs>(args: SelectSubset<T, KitchenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kitchen.
     * @param {KitchenUpsertArgs} args - Arguments to update or create a Kitchen.
     * @example
     * // Update or create a Kitchen
     * const kitchen = await prisma.kitchen.upsert({
     *   create: {
     *     // ... data to create a Kitchen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kitchen we want to update
     *   }
     * })
     */
    upsert<T extends KitchenUpsertArgs>(args: SelectSubset<T, KitchenUpsertArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenCountArgs} args - Arguments to filter Kitchens to count.
     * @example
     * // Count the number of Kitchens
     * const count = await prisma.kitchen.count({
     *   where: {
     *     // ... the filter for the Kitchens we want to count
     *   }
     * })
    **/
    count<T extends KitchenCountArgs>(
      args?: Subset<T, KitchenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenAggregateArgs>(args: Subset<T, KitchenAggregateArgs>): Prisma.PrismaPromise<GetKitchenAggregateType<T>>

    /**
     * Group by Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenGroupByArgs['orderBy'] }
        : { orderBy?: KitchenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kitchen model
   */
  readonly fields: KitchenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kitchen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitchenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kitchen model
   */ 
  interface KitchenFieldRefs {
    readonly id: FieldRef<"Kitchen", 'String'>
    readonly name: FieldRef<"Kitchen", 'String'>
    readonly address: FieldRef<"Kitchen", 'String'>
    readonly phone: FieldRef<"Kitchen", 'String'>
    readonly manager_name: FieldRef<"Kitchen", 'String'>
    readonly capacity: FieldRef<"Kitchen", 'Int'>
    readonly areas_served: FieldRef<"Kitchen", 'String'>
    readonly is_active: FieldRef<"Kitchen", 'Boolean'>
    readonly created_by: FieldRef<"Kitchen", 'String'>
    readonly created_at: FieldRef<"Kitchen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kitchen findUnique
   */
  export type KitchenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findUniqueOrThrow
   */
  export type KitchenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findFirst
   */
  export type KitchenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findFirstOrThrow
   */
  export type KitchenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findMany
   */
  export type KitchenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter, which Kitchens to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen create
   */
  export type KitchenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * The data needed to create a Kitchen.
     */
    data: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
  }

  /**
   * Kitchen createMany
   */
  export type KitchenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kitchen createManyAndReturn
   */
  export type KitchenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kitchen update
   */
  export type KitchenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * The data needed to update a Kitchen.
     */
    data: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
    /**
     * Choose, which Kitchen to update.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen updateMany
   */
  export type KitchenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kitchens.
     */
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    /**
     * Filter which Kitchens to update
     */
    where?: KitchenWhereInput
  }

  /**
   * Kitchen upsert
   */
  export type KitchenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * The filter to search for the Kitchen to update in case it exists.
     */
    where: KitchenWhereUniqueInput
    /**
     * In case the Kitchen found by the `where` argument doesn't exist, create a new Kitchen with this data.
     */
    create: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
    /**
     * In case the Kitchen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
  }

  /**
   * Kitchen delete
   */
  export type KitchenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Filter which Kitchen to delete.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen deleteMany
   */
  export type KitchenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchens to delete
     */
    where?: KitchenWhereInput
  }

  /**
   * Kitchen without action
   */
  export type KitchenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
  }


  /**
   * Model PrepItem
   */

  export type AggregatePrepItem = {
    _count: PrepItemCountAggregateOutputType | null
    _avg: PrepItemAvgAggregateOutputType | null
    _sum: PrepItemSumAggregateOutputType | null
    _min: PrepItemMinAggregateOutputType | null
    _max: PrepItemMaxAggregateOutputType | null
  }

  export type PrepItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PrepItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type PrepItemMinAggregateOutputType = {
    id: string | null
    kitchen_id: string | null
    meal_type: string | null
    prep_date: string | null
    item_name: string | null
    quantity: number | null
    unit: string | null
    status: string | null
    prepared_by: string | null
    prepared_at: Date | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type PrepItemMaxAggregateOutputType = {
    id: string | null
    kitchen_id: string | null
    meal_type: string | null
    prep_date: string | null
    item_name: string | null
    quantity: number | null
    unit: string | null
    status: string | null
    prepared_by: string | null
    prepared_at: Date | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type PrepItemCountAggregateOutputType = {
    id: number
    kitchen_id: number
    meal_type: number
    prep_date: number
    item_name: number
    quantity: number
    unit: number
    status: number
    prepared_by: number
    prepared_at: number
    notes: number
    created_by: number
    created_at: number
    _all: number
  }


  export type PrepItemAvgAggregateInputType = {
    quantity?: true
  }

  export type PrepItemSumAggregateInputType = {
    quantity?: true
  }

  export type PrepItemMinAggregateInputType = {
    id?: true
    kitchen_id?: true
    meal_type?: true
    prep_date?: true
    item_name?: true
    quantity?: true
    unit?: true
    status?: true
    prepared_by?: true
    prepared_at?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type PrepItemMaxAggregateInputType = {
    id?: true
    kitchen_id?: true
    meal_type?: true
    prep_date?: true
    item_name?: true
    quantity?: true
    unit?: true
    status?: true
    prepared_by?: true
    prepared_at?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type PrepItemCountAggregateInputType = {
    id?: true
    kitchen_id?: true
    meal_type?: true
    prep_date?: true
    item_name?: true
    quantity?: true
    unit?: true
    status?: true
    prepared_by?: true
    prepared_at?: true
    notes?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type PrepItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrepItem to aggregate.
     */
    where?: PrepItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrepItems to fetch.
     */
    orderBy?: PrepItemOrderByWithRelationInput | PrepItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrepItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrepItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrepItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrepItems
    **/
    _count?: true | PrepItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrepItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrepItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrepItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrepItemMaxAggregateInputType
  }

  export type GetPrepItemAggregateType<T extends PrepItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrepItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrepItem[P]>
      : GetScalarType<T[P], AggregatePrepItem[P]>
  }




  export type PrepItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrepItemWhereInput
    orderBy?: PrepItemOrderByWithAggregationInput | PrepItemOrderByWithAggregationInput[]
    by: PrepItemScalarFieldEnum[] | PrepItemScalarFieldEnum
    having?: PrepItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrepItemCountAggregateInputType | true
    _avg?: PrepItemAvgAggregateInputType
    _sum?: PrepItemSumAggregateInputType
    _min?: PrepItemMinAggregateInputType
    _max?: PrepItemMaxAggregateInputType
  }

  export type PrepItemGroupByOutputType = {
    id: string
    kitchen_id: string | null
    meal_type: string | null
    prep_date: string
    item_name: string
    quantity: number
    unit: string | null
    status: string | null
    prepared_by: string | null
    prepared_at: Date | null
    notes: string | null
    created_by: string
    created_at: Date
    _count: PrepItemCountAggregateOutputType | null
    _avg: PrepItemAvgAggregateOutputType | null
    _sum: PrepItemSumAggregateOutputType | null
    _min: PrepItemMinAggregateOutputType | null
    _max: PrepItemMaxAggregateOutputType | null
  }

  type GetPrepItemGroupByPayload<T extends PrepItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrepItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrepItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrepItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrepItemGroupByOutputType[P]>
        }
      >
    >


  export type PrepItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchen_id?: boolean
    meal_type?: boolean
    prep_date?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    status?: boolean
    prepared_by?: boolean
    prepared_at?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["prepItem"]>

  export type PrepItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kitchen_id?: boolean
    meal_type?: boolean
    prep_date?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    status?: boolean
    prepared_by?: boolean
    prepared_at?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["prepItem"]>

  export type PrepItemSelectScalar = {
    id?: boolean
    kitchen_id?: boolean
    meal_type?: boolean
    prep_date?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    status?: boolean
    prepared_by?: boolean
    prepared_at?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $PrepItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrepItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kitchen_id: string | null
      meal_type: string | null
      prep_date: string
      item_name: string
      quantity: number
      unit: string | null
      status: string | null
      prepared_by: string | null
      prepared_at: Date | null
      notes: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["prepItem"]>
    composites: {}
  }

  type PrepItemGetPayload<S extends boolean | null | undefined | PrepItemDefaultArgs> = $Result.GetResult<Prisma.$PrepItemPayload, S>

  type PrepItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrepItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrepItemCountAggregateInputType | true
    }

  export interface PrepItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrepItem'], meta: { name: 'PrepItem' } }
    /**
     * Find zero or one PrepItem that matches the filter.
     * @param {PrepItemFindUniqueArgs} args - Arguments to find a PrepItem
     * @example
     * // Get one PrepItem
     * const prepItem = await prisma.prepItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrepItemFindUniqueArgs>(args: SelectSubset<T, PrepItemFindUniqueArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrepItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrepItemFindUniqueOrThrowArgs} args - Arguments to find a PrepItem
     * @example
     * // Get one PrepItem
     * const prepItem = await prisma.prepItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrepItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrepItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrepItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemFindFirstArgs} args - Arguments to find a PrepItem
     * @example
     * // Get one PrepItem
     * const prepItem = await prisma.prepItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrepItemFindFirstArgs>(args?: SelectSubset<T, PrepItemFindFirstArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrepItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemFindFirstOrThrowArgs} args - Arguments to find a PrepItem
     * @example
     * // Get one PrepItem
     * const prepItem = await prisma.prepItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrepItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrepItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrepItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrepItems
     * const prepItems = await prisma.prepItem.findMany()
     * 
     * // Get first 10 PrepItems
     * const prepItems = await prisma.prepItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prepItemWithIdOnly = await prisma.prepItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrepItemFindManyArgs>(args?: SelectSubset<T, PrepItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrepItem.
     * @param {PrepItemCreateArgs} args - Arguments to create a PrepItem.
     * @example
     * // Create one PrepItem
     * const PrepItem = await prisma.prepItem.create({
     *   data: {
     *     // ... data to create a PrepItem
     *   }
     * })
     * 
     */
    create<T extends PrepItemCreateArgs>(args: SelectSubset<T, PrepItemCreateArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrepItems.
     * @param {PrepItemCreateManyArgs} args - Arguments to create many PrepItems.
     * @example
     * // Create many PrepItems
     * const prepItem = await prisma.prepItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrepItemCreateManyArgs>(args?: SelectSubset<T, PrepItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrepItems and returns the data saved in the database.
     * @param {PrepItemCreateManyAndReturnArgs} args - Arguments to create many PrepItems.
     * @example
     * // Create many PrepItems
     * const prepItem = await prisma.prepItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrepItems and only return the `id`
     * const prepItemWithIdOnly = await prisma.prepItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrepItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrepItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrepItem.
     * @param {PrepItemDeleteArgs} args - Arguments to delete one PrepItem.
     * @example
     * // Delete one PrepItem
     * const PrepItem = await prisma.prepItem.delete({
     *   where: {
     *     // ... filter to delete one PrepItem
     *   }
     * })
     * 
     */
    delete<T extends PrepItemDeleteArgs>(args: SelectSubset<T, PrepItemDeleteArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrepItem.
     * @param {PrepItemUpdateArgs} args - Arguments to update one PrepItem.
     * @example
     * // Update one PrepItem
     * const prepItem = await prisma.prepItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrepItemUpdateArgs>(args: SelectSubset<T, PrepItemUpdateArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrepItems.
     * @param {PrepItemDeleteManyArgs} args - Arguments to filter PrepItems to delete.
     * @example
     * // Delete a few PrepItems
     * const { count } = await prisma.prepItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrepItemDeleteManyArgs>(args?: SelectSubset<T, PrepItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrepItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrepItems
     * const prepItem = await prisma.prepItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrepItemUpdateManyArgs>(args: SelectSubset<T, PrepItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrepItem.
     * @param {PrepItemUpsertArgs} args - Arguments to update or create a PrepItem.
     * @example
     * // Update or create a PrepItem
     * const prepItem = await prisma.prepItem.upsert({
     *   create: {
     *     // ... data to create a PrepItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrepItem we want to update
     *   }
     * })
     */
    upsert<T extends PrepItemUpsertArgs>(args: SelectSubset<T, PrepItemUpsertArgs<ExtArgs>>): Prisma__PrepItemClient<$Result.GetResult<Prisma.$PrepItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrepItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemCountArgs} args - Arguments to filter PrepItems to count.
     * @example
     * // Count the number of PrepItems
     * const count = await prisma.prepItem.count({
     *   where: {
     *     // ... the filter for the PrepItems we want to count
     *   }
     * })
    **/
    count<T extends PrepItemCountArgs>(
      args?: Subset<T, PrepItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrepItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrepItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrepItemAggregateArgs>(args: Subset<T, PrepItemAggregateArgs>): Prisma.PrismaPromise<GetPrepItemAggregateType<T>>

    /**
     * Group by PrepItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrepItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrepItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrepItemGroupByArgs['orderBy'] }
        : { orderBy?: PrepItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrepItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrepItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrepItem model
   */
  readonly fields: PrepItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrepItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrepItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrepItem model
   */ 
  interface PrepItemFieldRefs {
    readonly id: FieldRef<"PrepItem", 'String'>
    readonly kitchen_id: FieldRef<"PrepItem", 'String'>
    readonly meal_type: FieldRef<"PrepItem", 'String'>
    readonly prep_date: FieldRef<"PrepItem", 'String'>
    readonly item_name: FieldRef<"PrepItem", 'String'>
    readonly quantity: FieldRef<"PrepItem", 'Int'>
    readonly unit: FieldRef<"PrepItem", 'String'>
    readonly status: FieldRef<"PrepItem", 'String'>
    readonly prepared_by: FieldRef<"PrepItem", 'String'>
    readonly prepared_at: FieldRef<"PrepItem", 'DateTime'>
    readonly notes: FieldRef<"PrepItem", 'String'>
    readonly created_by: FieldRef<"PrepItem", 'String'>
    readonly created_at: FieldRef<"PrepItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrepItem findUnique
   */
  export type PrepItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter, which PrepItem to fetch.
     */
    where: PrepItemWhereUniqueInput
  }

  /**
   * PrepItem findUniqueOrThrow
   */
  export type PrepItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter, which PrepItem to fetch.
     */
    where: PrepItemWhereUniqueInput
  }

  /**
   * PrepItem findFirst
   */
  export type PrepItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter, which PrepItem to fetch.
     */
    where?: PrepItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrepItems to fetch.
     */
    orderBy?: PrepItemOrderByWithRelationInput | PrepItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrepItems.
     */
    cursor?: PrepItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrepItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrepItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrepItems.
     */
    distinct?: PrepItemScalarFieldEnum | PrepItemScalarFieldEnum[]
  }

  /**
   * PrepItem findFirstOrThrow
   */
  export type PrepItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter, which PrepItem to fetch.
     */
    where?: PrepItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrepItems to fetch.
     */
    orderBy?: PrepItemOrderByWithRelationInput | PrepItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrepItems.
     */
    cursor?: PrepItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrepItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrepItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrepItems.
     */
    distinct?: PrepItemScalarFieldEnum | PrepItemScalarFieldEnum[]
  }

  /**
   * PrepItem findMany
   */
  export type PrepItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter, which PrepItems to fetch.
     */
    where?: PrepItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrepItems to fetch.
     */
    orderBy?: PrepItemOrderByWithRelationInput | PrepItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrepItems.
     */
    cursor?: PrepItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrepItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrepItems.
     */
    skip?: number
    distinct?: PrepItemScalarFieldEnum | PrepItemScalarFieldEnum[]
  }

  /**
   * PrepItem create
   */
  export type PrepItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * The data needed to create a PrepItem.
     */
    data: XOR<PrepItemCreateInput, PrepItemUncheckedCreateInput>
  }

  /**
   * PrepItem createMany
   */
  export type PrepItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrepItems.
     */
    data: PrepItemCreateManyInput | PrepItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrepItem createManyAndReturn
   */
  export type PrepItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrepItems.
     */
    data: PrepItemCreateManyInput | PrepItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrepItem update
   */
  export type PrepItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * The data needed to update a PrepItem.
     */
    data: XOR<PrepItemUpdateInput, PrepItemUncheckedUpdateInput>
    /**
     * Choose, which PrepItem to update.
     */
    where: PrepItemWhereUniqueInput
  }

  /**
   * PrepItem updateMany
   */
  export type PrepItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrepItems.
     */
    data: XOR<PrepItemUpdateManyMutationInput, PrepItemUncheckedUpdateManyInput>
    /**
     * Filter which PrepItems to update
     */
    where?: PrepItemWhereInput
  }

  /**
   * PrepItem upsert
   */
  export type PrepItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * The filter to search for the PrepItem to update in case it exists.
     */
    where: PrepItemWhereUniqueInput
    /**
     * In case the PrepItem found by the `where` argument doesn't exist, create a new PrepItem with this data.
     */
    create: XOR<PrepItemCreateInput, PrepItemUncheckedCreateInput>
    /**
     * In case the PrepItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrepItemUpdateInput, PrepItemUncheckedUpdateInput>
  }

  /**
   * PrepItem delete
   */
  export type PrepItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
    /**
     * Filter which PrepItem to delete.
     */
    where: PrepItemWhereUniqueInput
  }

  /**
   * PrepItem deleteMany
   */
  export type PrepItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrepItems to delete
     */
    where?: PrepItemWhereInput
  }

  /**
   * PrepItem without action
   */
  export type PrepItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrepItem
     */
    select?: PrepItemSelect<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    customer_phone: string | null
    direction: string | null
    message: string | null
    intent: string | null
    auto_replied: boolean | null
    reply_message: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    customer_phone: string | null
    direction: string | null
    message: string | null
    intent: string | null
    auto_replied: boolean | null
    reply_message: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    customer_phone: number
    direction: number
    message: number
    intent: number
    auto_replied: number
    reply_message: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    customer_phone?: true
    direction?: true
    message?: true
    intent?: true
    auto_replied?: true
    reply_message?: true
    created_by?: true
    created_at?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    customer_phone?: true
    direction?: true
    message?: true
    intent?: true
    auto_replied?: true
    reply_message?: true
    created_by?: true
    created_at?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    customer_phone?: true
    direction?: true
    message?: true
    intent?: true
    auto_replied?: true
    reply_message?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    customer_phone: string
    direction: string
    message: string
    intent: string | null
    auto_replied: boolean
    reply_message: string | null
    created_by: string
    created_at: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_phone?: boolean
    direction?: boolean
    message?: boolean
    intent?: boolean
    auto_replied?: boolean
    reply_message?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_phone?: boolean
    direction?: boolean
    message?: boolean
    intent?: boolean
    auto_replied?: boolean
    reply_message?: boolean
    created_by?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    customer_phone?: boolean
    direction?: boolean
    message?: boolean
    intent?: boolean
    auto_replied?: boolean
    reply_message?: boolean
    created_by?: boolean
    created_at?: boolean
  }


  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_phone: string
      direction: string
      message: string
      intent: string | null
      auto_replied: boolean
      reply_message: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly customer_phone: FieldRef<"ChatMessage", 'String'>
    readonly direction: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly intent: FieldRef<"ChatMessage", 'String'>
    readonly auto_replied: FieldRef<"ChatMessage", 'Boolean'>
    readonly reply_message: FieldRef<"ChatMessage", 'String'>
    readonly created_by: FieldRef<"ChatMessage", 'String'>
    readonly created_at: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    full_name: 'full_name',
    role: 'role',
    phone: 'phone',
    business_name: 'business_name',
    logo_url: 'logo_url',
    subscription_status: 'subscription_status',
    plan_type: 'plan_type',
    subscription_source: 'subscription_source',
    trial_ends_at: 'trial_ends_at',
    trial_cancelled_at: 'trial_cancelled_at',
    subscription_ends_at: 'subscription_ends_at',
    current_period_end: 'current_period_end',
    next_billing_date: 'next_billing_date',
    cancel_at_period_end: 'cancel_at_period_end',
    cancellation_reason: 'cancellation_reason',
    cancelled_at: 'cancelled_at',
    is_paid: 'is_paid',
    last_payment_status: 'last_payment_status',
    stripe_customer_id: 'stripe_customer_id',
    stripe_subscription_id: 'stripe_subscription_id',
    stripe_connect_account_id: 'stripe_connect_account_id',
    payment_account_connected: 'payment_account_connected',
    payment_verification_status: 'payment_verification_status',
    fee_consent_accepted: 'fee_consent_accepted',
    fee_percentage: 'fee_percentage',
    whatsapp_sent_count: 'whatsapp_sent_count',
    whatsapp_limit: 'whatsapp_limit',
    whatsapp_notifications_enabled: 'whatsapp_notifications_enabled',
    whatsapp_number: 'whatsapp_number',
    currency: 'currency',
    language: 'language',
    seasonal_mode: 'seasonal_mode',
    seasonal_mode_start: 'seasonal_mode_start',
    seasonal_mode_end: 'seasonal_mode_end',
    ramadan_lunch_time: 'ramadan_lunch_time',
    ramadan_dinner_time: 'ramadan_dinner_time',
    ramadan_suhoor_time: 'ramadan_suhoor_time',
    ramadan_iftar_time: 'ramadan_iftar_time',
    is_super_admin: 'is_super_admin',
    special_access_type: 'special_access_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    phone_number: 'phone_number',
    address: 'address',
    area: 'area',
    meal_type: 'meal_type',
    payment_amount: 'payment_amount',
    payment_status: 'payment_status',
    due_date: 'due_date',
    last_payment_date: 'last_payment_date',
    last_payment_amount: 'last_payment_amount',
    active: 'active',
    status: 'status',
    inactive_reason: 'inactive_reason',
    start_date: 'start_date',
    end_date: 'end_date',
    paid_days: 'paid_days',
    delivered_days: 'delivered_days',
    days_remaining: 'days_remaining',
    meals_delivered: 'meals_delivered',
    tiffin_balance: 'tiffin_balance',
    roti_quantity: 'roti_quantity',
    rice_type: 'rice_type',
    special_notes: 'special_notes',
    dietary_preference: 'dietary_preference',
    skip_weekends: 'skip_weekends',
    pause_start: 'pause_start',
    pause_end: 'pause_end',
    pause_start_date: 'pause_start_date',
    pause_resume_date: 'pause_resume_date',
    original_end_date: 'original_end_date',
    total_pause_days: 'total_pause_days',
    pause_history: 'pause_history',
    notification_sent: 'notification_sent',
    reminder_before_sent: 'reminder_before_sent',
    reminder_after_sent: 'reminder_after_sent',
    notes: 'notes',
    is_trial: 'is_trial',
    trial_end_date: 'trial_end_date',
    trial_converted: 'trial_converted',
    is_paused: 'is_paused',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    portal_token: 'portal_token',
    referral_code: 'referral_code',
    referred_by: 'referred_by',
    family_group_id: 'family_group_id',
    kitchen_id: 'kitchen_id',
    registration_source: 'registration_source',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    meal_type: 'meal_type',
    delivery_date: 'delivery_date',
    order_date: 'order_date',
    delivery_status: 'delivery_status',
    status: 'status',
    out_for_delivery_time: 'out_for_delivery_time',
    delivery_photo: 'delivery_photo',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    category: 'category',
    image_url: 'image_url',
    meal_type: 'meal_type',
    is_active: 'is_active',
    day_of_week: 'day_of_week',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const TiffinSkipScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    skip_date: 'skip_date',
    meal_type: 'meal_type',
    reason: 'reason',
    status: 'status',
    carry_forward_applied: 'carry_forward_applied',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TiffinSkipScalarFieldEnum = (typeof TiffinSkipScalarFieldEnum)[keyof typeof TiffinSkipScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    title: 'title',
    message: 'message',
    read: 'read',
    is_read: 'is_read',
    type: 'type',
    notification_type: 'notification_type',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    days_left: 'days_left',
    amount_to_collect: 'amount_to_collect',
    phone_number: 'phone_number',
    email_sent: 'email_sent',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    user_name: 'user_name',
    action_type: 'action_type',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    description: 'description',
    metadata: 'metadata',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    unit: 'unit',
    current_stock: 'current_stock',
    min_stock_threshold: 'min_stock_threshold',
    cost_per_unit: 'cost_per_unit',
    total_value: 'total_value',
    is_critical: 'is_critical',
    last_purchase_date: 'last_purchase_date',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    meal_type: 'meal_type',
    ingredients: 'ingredients',
    is_active: 'is_active',
    total_cost: 'total_cost',
    cost_per_serving: 'cost_per_serving',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    address: 'address',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    ingredient_id: 'ingredient_id',
    ingredient_name: 'ingredient_name',
    quantity: 'quantity',
    unit: 'unit',
    cost_per_unit: 'cost_per_unit',
    total_cost: 'total_cost',
    supplier_id: 'supplier_id',
    supplier_name: 'supplier_name',
    purchase_date: 'purchase_date',
    expiry_date: 'expiry_date',
    bill_image_url: 'bill_image_url',
    notes: 'notes',
    is_deleted: 'is_deleted',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const WastageScalarFieldEnum: {
    id: 'id',
    ingredient_id: 'ingredient_id',
    ingredient_name: 'ingredient_name',
    quantity: 'quantity',
    unit: 'unit',
    reason: 'reason',
    cost_value: 'cost_value',
    wastage_date: 'wastage_date',
    notes: 'notes',
    is_deleted: 'is_deleted',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WastageScalarFieldEnum = (typeof WastageScalarFieldEnum)[keyof typeof WastageScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    subject: 'subject',
    message: 'message',
    status: 'status',
    priority: 'priority',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    plan_name: 'plan_name',
    status: 'status',
    subscription_start_date: 'subscription_start_date',
    next_billing_date: 'next_billing_date',
    current_period_end: 'current_period_end',
    amount: 'amount',
    stripe_customer_id: 'stripe_customer_id',
    stripe_subscription_id: 'stripe_subscription_id',
    payment_method_last4: 'payment_method_last4',
    payment_method_brand: 'payment_method_brand',
    cancelled_at: 'cancelled_at',
    cancel_reason: 'cancel_reason',
    reminder_before_sent: 'reminder_before_sent',
    reminder_after_sent: 'reminder_after_sent',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentHistoryScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    subscription_id: 'subscription_id',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    payment_date: 'payment_date',
    stripe_payment_id: 'stripe_payment_id',
    payment_method_last4: 'payment_method_last4',
    error_message: 'error_message',
    created_at: 'created_at'
  };

  export type PaymentHistoryScalarFieldEnum = (typeof PaymentHistoryScalarFieldEnum)[keyof typeof PaymentHistoryScalarFieldEnum]


  export const PaymentLinkScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    status: 'status',
    stripe_checkout_session_id: 'stripe_checkout_session_id',
    stripe_payment_intent_id: 'stripe_payment_intent_id',
    checkout_url: 'checkout_url',
    expires_at: 'expires_at',
    paid_at: 'paid_at',
    platform_fee_amount: 'platform_fee_amount',
    net_amount: 'net_amount',
    payment_metadata: 'payment_metadata',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentLinkScalarFieldEnum = (typeof PaymentLinkScalarFieldEnum)[keyof typeof PaymentLinkScalarFieldEnum]


  export const ConsumptionLogScalarFieldEnum: {
    id: 'id',
    date: 'date',
    recipe_id: 'recipe_id',
    recipe_name: 'recipe_name',
    meal_type: 'meal_type',
    quantity_prepared: 'quantity_prepared',
    ingredients_used: 'ingredients_used',
    total_cost: 'total_cost',
    cost_per_meal: 'cost_per_meal',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ConsumptionLogScalarFieldEnum = (typeof ConsumptionLogScalarFieldEnum)[keyof typeof ConsumptionLogScalarFieldEnum]


  export const MealRatingScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    order_id: 'order_id',
    rating: 'rating',
    feedback: 'feedback',
    meal_type: 'meal_type',
    meal_date: 'meal_date',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type MealRatingScalarFieldEnum = (typeof MealRatingScalarFieldEnum)[keyof typeof MealRatingScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    customer_phone: 'customer_phone',
    customer_address: 'customer_address',
    amount: 'amount',
    tax_amount: 'tax_amount',
    total_amount: 'total_amount',
    currency: 'currency',
    period_start: 'period_start',
    period_end: 'period_end',
    status: 'status',
    trn_number: 'trn_number',
    business_name: 'business_name',
    business_address: 'business_address',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrer_id: 'referrer_id',
    referrer_name: 'referrer_name',
    referred_id: 'referred_id',
    referred_name: 'referred_name',
    referral_code: 'referral_code',
    status: 'status',
    discount_amount: 'discount_amount',
    discount_applied: 'discount_applied',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const FamilyGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    primary_contact: 'primary_contact',
    primary_phone: 'primary_phone',
    billing_amount: 'billing_amount',
    billing_status: 'billing_status',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FamilyGroupScalarFieldEnum = (typeof FamilyGroupScalarFieldEnum)[keyof typeof FamilyGroupScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    vehicle_number: 'vehicle_number',
    is_active: 'is_active',
    access_code: 'access_code',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const DeliveryBatchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    area: 'area',
    driver_id: 'driver_id',
    driver_name: 'driver_name',
    delivery_date: 'delivery_date',
    status: 'status',
    total_orders: 'total_orders',
    delivered_count: 'delivered_count',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type DeliveryBatchScalarFieldEnum = (typeof DeliveryBatchScalarFieldEnum)[keyof typeof DeliveryBatchScalarFieldEnum]


  export const DeliveryItemScalarFieldEnum: {
    id: 'id',
    batch_id: 'batch_id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    customer_phone: 'customer_phone',
    customer_address: 'customer_address',
    area: 'area',
    meal_type: 'meal_type',
    roti_quantity: 'roti_quantity',
    rice_type: 'rice_type',
    special_notes: 'special_notes',
    status: 'status',
    delivered_at: 'delivered_at',
    delivery_photo: 'delivery_photo',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type DeliveryItemScalarFieldEnum = (typeof DeliveryItemScalarFieldEnum)[keyof typeof DeliveryItemScalarFieldEnum]


  export const ContainerScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    customer_name: 'customer_name',
    container_type: 'container_type',
    given_date: 'given_date',
    given_count: 'given_count',
    returned_count: 'returned_count',
    outstanding: 'outstanding',
    deposit_amount: 'deposit_amount',
    deposit_paid: 'deposit_paid',
    last_reminder: 'last_reminder',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ContainerScalarFieldEnum = (typeof ContainerScalarFieldEnum)[keyof typeof ContainerScalarFieldEnum]


  export const ContainerLogScalarFieldEnum: {
    id: 'id',
    container_id: 'container_id',
    customer_id: 'customer_id',
    action: 'action',
    count: 'count',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ContainerLogScalarFieldEnum = (typeof ContainerLogScalarFieldEnum)[keyof typeof ContainerLogScalarFieldEnum]


  export const KitchenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    manager_name: 'manager_name',
    capacity: 'capacity',
    areas_served: 'areas_served',
    is_active: 'is_active',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type KitchenScalarFieldEnum = (typeof KitchenScalarFieldEnum)[keyof typeof KitchenScalarFieldEnum]


  export const PrepItemScalarFieldEnum: {
    id: 'id',
    kitchen_id: 'kitchen_id',
    meal_type: 'meal_type',
    prep_date: 'prep_date',
    item_name: 'item_name',
    quantity: 'quantity',
    unit: 'unit',
    status: 'status',
    prepared_by: 'prepared_by',
    prepared_at: 'prepared_at',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type PrepItemScalarFieldEnum = (typeof PrepItemScalarFieldEnum)[keyof typeof PrepItemScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    customer_phone: 'customer_phone',
    direction: 'direction',
    message: 'message',
    intent: 'intent',
    auto_replied: 'auto_replied',
    reply_message: 'reply_message',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    full_name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    business_name?: StringNullableFilter<"User"> | string | null
    logo_url?: StringNullableFilter<"User"> | string | null
    subscription_status?: StringNullableFilter<"User"> | string | null
    plan_type?: StringNullableFilter<"User"> | string | null
    subscription_source?: StringNullableFilter<"User"> | string | null
    trial_ends_at?: DateTimeNullableFilter<"User"> | Date | string | null
    trial_cancelled_at?: DateTimeNullableFilter<"User"> | Date | string | null
    subscription_ends_at?: DateTimeNullableFilter<"User"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"User"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"User"> | Date | string | null
    cancel_at_period_end?: BoolNullableFilter<"User"> | boolean | null
    cancellation_reason?: StringNullableFilter<"User"> | string | null
    cancelled_at?: DateTimeNullableFilter<"User"> | Date | string | null
    is_paid?: BoolFilter<"User"> | boolean
    last_payment_status?: StringNullableFilter<"User"> | string | null
    stripe_customer_id?: StringNullableFilter<"User"> | string | null
    stripe_subscription_id?: StringNullableFilter<"User"> | string | null
    stripe_connect_account_id?: StringNullableFilter<"User"> | string | null
    payment_account_connected?: BoolNullableFilter<"User"> | boolean | null
    payment_verification_status?: StringNullableFilter<"User"> | string | null
    fee_consent_accepted?: BoolNullableFilter<"User"> | boolean | null
    fee_percentage?: FloatNullableFilter<"User"> | number | null
    whatsapp_sent_count?: IntFilter<"User"> | number
    whatsapp_limit?: IntFilter<"User"> | number
    whatsapp_notifications_enabled?: BoolNullableFilter<"User"> | boolean | null
    whatsapp_number?: StringNullableFilter<"User"> | string | null
    currency?: StringNullableFilter<"User"> | string | null
    language?: StringNullableFilter<"User"> | string | null
    seasonal_mode?: StringNullableFilter<"User"> | string | null
    seasonal_mode_start?: StringNullableFilter<"User"> | string | null
    seasonal_mode_end?: StringNullableFilter<"User"> | string | null
    ramadan_lunch_time?: StringNullableFilter<"User"> | string | null
    ramadan_dinner_time?: StringNullableFilter<"User"> | string | null
    ramadan_suhoor_time?: StringNullableFilter<"User"> | string | null
    ramadan_iftar_time?: StringNullableFilter<"User"> | string | null
    is_super_admin?: BoolFilter<"User"> | boolean
    special_access_type?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    customers?: CustomerListRelationFilter
    orders?: OrderListRelationFilter
    menuItems?: MenuItemListRelationFilter
    tiffinSkips?: TiffinSkipListRelationFilter
    ingredients?: IngredientListRelationFilter
    recipes?: RecipeListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchases?: PurchaseListRelationFilter
    wastages?: WastageListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    paymentLinks?: PaymentLinkListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    subscription_status?: SortOrderInput | SortOrder
    plan_type?: SortOrderInput | SortOrder
    subscription_source?: SortOrderInput | SortOrder
    trial_ends_at?: SortOrderInput | SortOrder
    trial_cancelled_at?: SortOrderInput | SortOrder
    subscription_ends_at?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    is_paid?: SortOrder
    last_payment_status?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_connect_account_id?: SortOrderInput | SortOrder
    payment_account_connected?: SortOrderInput | SortOrder
    payment_verification_status?: SortOrderInput | SortOrder
    fee_consent_accepted?: SortOrderInput | SortOrder
    fee_percentage?: SortOrderInput | SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
    whatsapp_notifications_enabled?: SortOrderInput | SortOrder
    whatsapp_number?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    seasonal_mode?: SortOrderInput | SortOrder
    seasonal_mode_start?: SortOrderInput | SortOrder
    seasonal_mode_end?: SortOrderInput | SortOrder
    ramadan_lunch_time?: SortOrderInput | SortOrder
    ramadan_dinner_time?: SortOrderInput | SortOrder
    ramadan_suhoor_time?: SortOrderInput | SortOrder
    ramadan_iftar_time?: SortOrderInput | SortOrder
    is_super_admin?: SortOrder
    special_access_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    menuItems?: MenuItemOrderByRelationAggregateInput
    tiffinSkips?: TiffinSkipOrderByRelationAggregateInput
    ingredients?: IngredientOrderByRelationAggregateInput
    recipes?: RecipeOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    purchases?: PurchaseOrderByRelationAggregateInput
    wastages?: WastageOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    paymentLinks?: PaymentLinkOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    full_name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    business_name?: StringNullableFilter<"User"> | string | null
    logo_url?: StringNullableFilter<"User"> | string | null
    subscription_status?: StringNullableFilter<"User"> | string | null
    plan_type?: StringNullableFilter<"User"> | string | null
    subscription_source?: StringNullableFilter<"User"> | string | null
    trial_ends_at?: DateTimeNullableFilter<"User"> | Date | string | null
    trial_cancelled_at?: DateTimeNullableFilter<"User"> | Date | string | null
    subscription_ends_at?: DateTimeNullableFilter<"User"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"User"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"User"> | Date | string | null
    cancel_at_period_end?: BoolNullableFilter<"User"> | boolean | null
    cancellation_reason?: StringNullableFilter<"User"> | string | null
    cancelled_at?: DateTimeNullableFilter<"User"> | Date | string | null
    is_paid?: BoolFilter<"User"> | boolean
    last_payment_status?: StringNullableFilter<"User"> | string | null
    stripe_customer_id?: StringNullableFilter<"User"> | string | null
    stripe_subscription_id?: StringNullableFilter<"User"> | string | null
    stripe_connect_account_id?: StringNullableFilter<"User"> | string | null
    payment_account_connected?: BoolNullableFilter<"User"> | boolean | null
    payment_verification_status?: StringNullableFilter<"User"> | string | null
    fee_consent_accepted?: BoolNullableFilter<"User"> | boolean | null
    fee_percentage?: FloatNullableFilter<"User"> | number | null
    whatsapp_sent_count?: IntFilter<"User"> | number
    whatsapp_limit?: IntFilter<"User"> | number
    whatsapp_notifications_enabled?: BoolNullableFilter<"User"> | boolean | null
    whatsapp_number?: StringNullableFilter<"User"> | string | null
    currency?: StringNullableFilter<"User"> | string | null
    language?: StringNullableFilter<"User"> | string | null
    seasonal_mode?: StringNullableFilter<"User"> | string | null
    seasonal_mode_start?: StringNullableFilter<"User"> | string | null
    seasonal_mode_end?: StringNullableFilter<"User"> | string | null
    ramadan_lunch_time?: StringNullableFilter<"User"> | string | null
    ramadan_dinner_time?: StringNullableFilter<"User"> | string | null
    ramadan_suhoor_time?: StringNullableFilter<"User"> | string | null
    ramadan_iftar_time?: StringNullableFilter<"User"> | string | null
    is_super_admin?: BoolFilter<"User"> | boolean
    special_access_type?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    customers?: CustomerListRelationFilter
    orders?: OrderListRelationFilter
    menuItems?: MenuItemListRelationFilter
    tiffinSkips?: TiffinSkipListRelationFilter
    ingredients?: IngredientListRelationFilter
    recipes?: RecipeListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchases?: PurchaseListRelationFilter
    wastages?: WastageListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    paymentLinks?: PaymentLinkListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    subscription_status?: SortOrderInput | SortOrder
    plan_type?: SortOrderInput | SortOrder
    subscription_source?: SortOrderInput | SortOrder
    trial_ends_at?: SortOrderInput | SortOrder
    trial_cancelled_at?: SortOrderInput | SortOrder
    subscription_ends_at?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    cancel_at_period_end?: SortOrderInput | SortOrder
    cancellation_reason?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    is_paid?: SortOrder
    last_payment_status?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    stripe_connect_account_id?: SortOrderInput | SortOrder
    payment_account_connected?: SortOrderInput | SortOrder
    payment_verification_status?: SortOrderInput | SortOrder
    fee_consent_accepted?: SortOrderInput | SortOrder
    fee_percentage?: SortOrderInput | SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
    whatsapp_notifications_enabled?: SortOrderInput | SortOrder
    whatsapp_number?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    seasonal_mode?: SortOrderInput | SortOrder
    seasonal_mode_start?: SortOrderInput | SortOrder
    seasonal_mode_end?: SortOrderInput | SortOrder
    ramadan_lunch_time?: SortOrderInput | SortOrder
    ramadan_dinner_time?: SortOrderInput | SortOrder
    ramadan_suhoor_time?: SortOrderInput | SortOrder
    ramadan_iftar_time?: SortOrderInput | SortOrder
    is_super_admin?: SortOrder
    special_access_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    full_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscription_status?: StringNullableWithAggregatesFilter<"User"> | string | null
    plan_type?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscription_source?: StringNullableWithAggregatesFilter<"User"> | string | null
    trial_ends_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    trial_cancelled_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscription_ends_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    current_period_end?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    next_billing_date?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    cancel_at_period_end?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    cancellation_reason?: StringNullableWithAggregatesFilter<"User"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    is_paid?: BoolWithAggregatesFilter<"User"> | boolean
    last_payment_status?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripe_subscription_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripe_connect_account_id?: StringNullableWithAggregatesFilter<"User"> | string | null
    payment_account_connected?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    payment_verification_status?: StringNullableWithAggregatesFilter<"User"> | string | null
    fee_consent_accepted?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    fee_percentage?: FloatNullableWithAggregatesFilter<"User"> | number | null
    whatsapp_sent_count?: IntWithAggregatesFilter<"User"> | number
    whatsapp_limit?: IntWithAggregatesFilter<"User"> | number
    whatsapp_notifications_enabled?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    whatsapp_number?: StringNullableWithAggregatesFilter<"User"> | string | null
    currency?: StringNullableWithAggregatesFilter<"User"> | string | null
    language?: StringNullableWithAggregatesFilter<"User"> | string | null
    seasonal_mode?: StringNullableWithAggregatesFilter<"User"> | string | null
    seasonal_mode_start?: StringNullableWithAggregatesFilter<"User"> | string | null
    seasonal_mode_end?: StringNullableWithAggregatesFilter<"User"> | string | null
    ramadan_lunch_time?: StringNullableWithAggregatesFilter<"User"> | string | null
    ramadan_dinner_time?: StringNullableWithAggregatesFilter<"User"> | string | null
    ramadan_suhoor_time?: StringNullableWithAggregatesFilter<"User"> | string | null
    ramadan_iftar_time?: StringNullableWithAggregatesFilter<"User"> | string | null
    is_super_admin?: BoolWithAggregatesFilter<"User"> | boolean
    special_access_type?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    full_name?: StringFilter<"Customer"> | string
    phone_number?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    area?: StringNullableFilter<"Customer"> | string | null
    meal_type?: StringNullableFilter<"Customer"> | string | null
    payment_amount?: FloatNullableFilter<"Customer"> | number | null
    payment_status?: StringNullableFilter<"Customer"> | string | null
    due_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_amount?: FloatNullableFilter<"Customer"> | number | null
    active?: BoolFilter<"Customer"> | boolean
    status?: StringNullableFilter<"Customer"> | string | null
    inactive_reason?: StringNullableFilter<"Customer"> | string | null
    start_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    paid_days?: IntNullableFilter<"Customer"> | number | null
    delivered_days?: IntNullableFilter<"Customer"> | number | null
    days_remaining?: IntNullableFilter<"Customer"> | number | null
    meals_delivered?: IntNullableFilter<"Customer"> | number | null
    tiffin_balance?: IntNullableFilter<"Customer"> | number | null
    roti_quantity?: IntNullableFilter<"Customer"> | number | null
    rice_type?: StringNullableFilter<"Customer"> | string | null
    special_notes?: StringNullableFilter<"Customer"> | string | null
    dietary_preference?: StringNullableFilter<"Customer"> | string | null
    skip_weekends?: BoolNullableFilter<"Customer"> | boolean | null
    pause_start?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_end?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_start_date?: StringNullableFilter<"Customer"> | string | null
    pause_resume_date?: StringNullableFilter<"Customer"> | string | null
    original_end_date?: StringNullableFilter<"Customer"> | string | null
    total_pause_days?: IntNullableFilter<"Customer"> | number | null
    pause_history?: JsonNullableFilter<"Customer">
    notification_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_before_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_after_sent?: BoolNullableFilter<"Customer"> | boolean | null
    notes?: StringNullableFilter<"Customer"> | string | null
    is_trial?: BoolNullableFilter<"Customer"> | boolean | null
    trial_end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    trial_converted?: BoolNullableFilter<"Customer"> | boolean | null
    is_paused?: BoolNullableFilter<"Customer"> | boolean | null
    is_deleted?: BoolFilter<"Customer"> | boolean
    deleted_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    portal_token?: StringNullableFilter<"Customer"> | string | null
    referral_code?: StringNullableFilter<"Customer"> | string | null
    referred_by?: StringNullableFilter<"Customer"> | string | null
    family_group_id?: StringNullableFilter<"Customer"> | string | null
    kitchen_id?: StringNullableFilter<"Customer"> | string | null
    registration_source?: StringNullableFilter<"Customer"> | string | null
    created_by?: StringFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    tiffinSkips?: TiffinSkipListRelationFilter
    paymentLinks?: PaymentLinkListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    payment_amount?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    last_payment_amount?: SortOrderInput | SortOrder
    active?: SortOrder
    status?: SortOrderInput | SortOrder
    inactive_reason?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    paid_days?: SortOrderInput | SortOrder
    delivered_days?: SortOrderInput | SortOrder
    days_remaining?: SortOrderInput | SortOrder
    meals_delivered?: SortOrderInput | SortOrder
    tiffin_balance?: SortOrderInput | SortOrder
    roti_quantity?: SortOrderInput | SortOrder
    rice_type?: SortOrderInput | SortOrder
    special_notes?: SortOrderInput | SortOrder
    dietary_preference?: SortOrderInput | SortOrder
    skip_weekends?: SortOrderInput | SortOrder
    pause_start?: SortOrderInput | SortOrder
    pause_end?: SortOrderInput | SortOrder
    pause_start_date?: SortOrderInput | SortOrder
    pause_resume_date?: SortOrderInput | SortOrder
    original_end_date?: SortOrderInput | SortOrder
    total_pause_days?: SortOrderInput | SortOrder
    pause_history?: SortOrderInput | SortOrder
    notification_sent?: SortOrderInput | SortOrder
    reminder_before_sent?: SortOrderInput | SortOrder
    reminder_after_sent?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_trial?: SortOrderInput | SortOrder
    trial_end_date?: SortOrderInput | SortOrder
    trial_converted?: SortOrderInput | SortOrder
    is_paused?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    portal_token?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    referred_by?: SortOrderInput | SortOrder
    family_group_id?: SortOrderInput | SortOrder
    kitchen_id?: SortOrderInput | SortOrder
    registration_source?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    tiffinSkips?: TiffinSkipOrderByRelationAggregateInput
    paymentLinks?: PaymentLinkOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portal_token?: string
    referral_code?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    full_name?: StringFilter<"Customer"> | string
    phone_number?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    area?: StringNullableFilter<"Customer"> | string | null
    meal_type?: StringNullableFilter<"Customer"> | string | null
    payment_amount?: FloatNullableFilter<"Customer"> | number | null
    payment_status?: StringNullableFilter<"Customer"> | string | null
    due_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_amount?: FloatNullableFilter<"Customer"> | number | null
    active?: BoolFilter<"Customer"> | boolean
    status?: StringNullableFilter<"Customer"> | string | null
    inactive_reason?: StringNullableFilter<"Customer"> | string | null
    start_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    paid_days?: IntNullableFilter<"Customer"> | number | null
    delivered_days?: IntNullableFilter<"Customer"> | number | null
    days_remaining?: IntNullableFilter<"Customer"> | number | null
    meals_delivered?: IntNullableFilter<"Customer"> | number | null
    tiffin_balance?: IntNullableFilter<"Customer"> | number | null
    roti_quantity?: IntNullableFilter<"Customer"> | number | null
    rice_type?: StringNullableFilter<"Customer"> | string | null
    special_notes?: StringNullableFilter<"Customer"> | string | null
    dietary_preference?: StringNullableFilter<"Customer"> | string | null
    skip_weekends?: BoolNullableFilter<"Customer"> | boolean | null
    pause_start?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_end?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_start_date?: StringNullableFilter<"Customer"> | string | null
    pause_resume_date?: StringNullableFilter<"Customer"> | string | null
    original_end_date?: StringNullableFilter<"Customer"> | string | null
    total_pause_days?: IntNullableFilter<"Customer"> | number | null
    pause_history?: JsonNullableFilter<"Customer">
    notification_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_before_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_after_sent?: BoolNullableFilter<"Customer"> | boolean | null
    notes?: StringNullableFilter<"Customer"> | string | null
    is_trial?: BoolNullableFilter<"Customer"> | boolean | null
    trial_end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    trial_converted?: BoolNullableFilter<"Customer"> | boolean | null
    is_paused?: BoolNullableFilter<"Customer"> | boolean | null
    is_deleted?: BoolFilter<"Customer"> | boolean
    deleted_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    referred_by?: StringNullableFilter<"Customer"> | string | null
    family_group_id?: StringNullableFilter<"Customer"> | string | null
    kitchen_id?: StringNullableFilter<"Customer"> | string | null
    registration_source?: StringNullableFilter<"Customer"> | string | null
    created_by?: StringFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    tiffinSkips?: TiffinSkipListRelationFilter
    paymentLinks?: PaymentLinkListRelationFilter
  }, "id" | "portal_token" | "referral_code">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    payment_amount?: SortOrderInput | SortOrder
    payment_status?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    last_payment_date?: SortOrderInput | SortOrder
    last_payment_amount?: SortOrderInput | SortOrder
    active?: SortOrder
    status?: SortOrderInput | SortOrder
    inactive_reason?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    paid_days?: SortOrderInput | SortOrder
    delivered_days?: SortOrderInput | SortOrder
    days_remaining?: SortOrderInput | SortOrder
    meals_delivered?: SortOrderInput | SortOrder
    tiffin_balance?: SortOrderInput | SortOrder
    roti_quantity?: SortOrderInput | SortOrder
    rice_type?: SortOrderInput | SortOrder
    special_notes?: SortOrderInput | SortOrder
    dietary_preference?: SortOrderInput | SortOrder
    skip_weekends?: SortOrderInput | SortOrder
    pause_start?: SortOrderInput | SortOrder
    pause_end?: SortOrderInput | SortOrder
    pause_start_date?: SortOrderInput | SortOrder
    pause_resume_date?: SortOrderInput | SortOrder
    original_end_date?: SortOrderInput | SortOrder
    total_pause_days?: SortOrderInput | SortOrder
    pause_history?: SortOrderInput | SortOrder
    notification_sent?: SortOrderInput | SortOrder
    reminder_before_sent?: SortOrderInput | SortOrder
    reminder_after_sent?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_trial?: SortOrderInput | SortOrder
    trial_end_date?: SortOrderInput | SortOrder
    trial_converted?: SortOrderInput | SortOrder
    is_paused?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    portal_token?: SortOrderInput | SortOrder
    referral_code?: SortOrderInput | SortOrder
    referred_by?: SortOrderInput | SortOrder
    family_group_id?: SortOrderInput | SortOrder
    kitchen_id?: SortOrderInput | SortOrder
    registration_source?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    full_name?: StringWithAggregatesFilter<"Customer"> | string
    phone_number?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    area?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    payment_amount?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    payment_status?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    last_payment_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    last_payment_amount?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    active?: BoolWithAggregatesFilter<"Customer"> | boolean
    status?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    inactive_reason?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    paid_days?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    delivered_days?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    days_remaining?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    meals_delivered?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    tiffin_balance?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    roti_quantity?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    rice_type?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    special_notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dietary_preference?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    skip_weekends?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    pause_start?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    pause_end?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    pause_start_date?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    pause_resume_date?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    original_end_date?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    total_pause_days?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    pause_history?: JsonNullableWithAggregatesFilter<"Customer">
    notification_sent?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    reminder_before_sent?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    reminder_after_sent?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    is_trial?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    trial_end_date?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    trial_converted?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    is_paused?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    is_deleted?: BoolWithAggregatesFilter<"Customer"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    portal_token?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    referral_code?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    referred_by?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    family_group_id?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    kitchen_id?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    registration_source?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    created_by?: StringWithAggregatesFilter<"Customer"> | string
    created_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    customer_id?: StringFilter<"Order"> | string
    customer_name?: StringNullableFilter<"Order"> | string | null
    meal_type?: StringNullableFilter<"Order"> | string | null
    delivery_date?: StringNullableFilter<"Order"> | string | null
    order_date?: StringNullableFilter<"Order"> | string | null
    delivery_status?: StringNullableFilter<"Order"> | string | null
    status?: StringFilter<"Order"> | string
    out_for_delivery_time?: StringNullableFilter<"Order"> | string | null
    delivery_photo?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_by?: StringFilter<"Order"> | string
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    customerRef?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    delivery_date?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    delivery_status?: SortOrderInput | SortOrder
    status?: SortOrder
    out_for_delivery_time?: SortOrderInput | SortOrder
    delivery_photo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: UserOrderByWithRelationInput
    customerRef?: CustomerOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customer_id?: StringFilter<"Order"> | string
    customer_name?: StringNullableFilter<"Order"> | string | null
    meal_type?: StringNullableFilter<"Order"> | string | null
    delivery_date?: StringNullableFilter<"Order"> | string | null
    order_date?: StringNullableFilter<"Order"> | string | null
    delivery_status?: StringNullableFilter<"Order"> | string | null
    status?: StringFilter<"Order"> | string
    out_for_delivery_time?: StringNullableFilter<"Order"> | string | null
    delivery_photo?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_by?: StringFilter<"Order"> | string
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    customerRef?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    delivery_date?: SortOrderInput | SortOrder
    order_date?: SortOrderInput | SortOrder
    delivery_status?: SortOrderInput | SortOrder
    status?: SortOrder
    out_for_delivery_time?: SortOrderInput | SortOrder
    delivery_photo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    customer_id?: StringWithAggregatesFilter<"Order"> | string
    customer_name?: StringNullableWithAggregatesFilter<"Order"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"Order"> | string | null
    delivery_date?: StringNullableWithAggregatesFilter<"Order"> | string | null
    order_date?: StringNullableWithAggregatesFilter<"Order"> | string | null
    delivery_status?: StringNullableWithAggregatesFilter<"Order"> | string | null
    status?: StringWithAggregatesFilter<"Order"> | string
    out_for_delivery_time?: StringNullableWithAggregatesFilter<"Order"> | string | null
    delivery_photo?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    created_by?: StringWithAggregatesFilter<"Order"> | string
    created_at?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatNullableFilter<"MenuItem"> | number | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    image_url?: StringNullableFilter<"MenuItem"> | string | null
    meal_type?: StringNullableFilter<"MenuItem"> | string | null
    is_active?: BoolFilter<"MenuItem"> | boolean
    day_of_week?: StringNullableFilter<"MenuItem"> | string | null
    created_by?: StringFilter<"MenuItem"> | string
    created_at?: DateTimeFilter<"MenuItem"> | Date | string
    updated_at?: DateTimeFilter<"MenuItem"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    is_active?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatNullableFilter<"MenuItem"> | number | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    image_url?: StringNullableFilter<"MenuItem"> | string | null
    meal_type?: StringNullableFilter<"MenuItem"> | string | null
    is_active?: BoolFilter<"MenuItem"> | boolean
    day_of_week?: StringNullableFilter<"MenuItem"> | string | null
    created_by?: StringFilter<"MenuItem"> | string
    created_at?: DateTimeFilter<"MenuItem"> | Date | string
    updated_at?: DateTimeFilter<"MenuItem"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    is_active?: SortOrder
    day_of_week?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenuItem"> | string
    name?: StringWithAggregatesFilter<"MenuItem"> | string
    description?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    price?: FloatNullableWithAggregatesFilter<"MenuItem"> | number | null
    category?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    is_active?: BoolWithAggregatesFilter<"MenuItem"> | boolean
    day_of_week?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    created_by?: StringWithAggregatesFilter<"MenuItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type TiffinSkipWhereInput = {
    AND?: TiffinSkipWhereInput | TiffinSkipWhereInput[]
    OR?: TiffinSkipWhereInput[]
    NOT?: TiffinSkipWhereInput | TiffinSkipWhereInput[]
    id?: StringFilter<"TiffinSkip"> | string
    customer_id?: StringFilter<"TiffinSkip"> | string
    customer_name?: StringNullableFilter<"TiffinSkip"> | string | null
    skip_date?: StringFilter<"TiffinSkip"> | string
    meal_type?: StringNullableFilter<"TiffinSkip"> | string | null
    reason?: StringNullableFilter<"TiffinSkip"> | string | null
    status?: StringFilter<"TiffinSkip"> | string
    carry_forward_applied?: BoolFilter<"TiffinSkip"> | boolean
    created_by?: StringFilter<"TiffinSkip"> | string
    created_at?: DateTimeFilter<"TiffinSkip"> | Date | string
    updated_at?: DateTimeFilter<"TiffinSkip"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TiffinSkipOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    skip_date?: SortOrder
    meal_type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    carry_forward_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TiffinSkipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TiffinSkipWhereInput | TiffinSkipWhereInput[]
    OR?: TiffinSkipWhereInput[]
    NOT?: TiffinSkipWhereInput | TiffinSkipWhereInput[]
    customer_id?: StringFilter<"TiffinSkip"> | string
    customer_name?: StringNullableFilter<"TiffinSkip"> | string | null
    skip_date?: StringFilter<"TiffinSkip"> | string
    meal_type?: StringNullableFilter<"TiffinSkip"> | string | null
    reason?: StringNullableFilter<"TiffinSkip"> | string | null
    status?: StringFilter<"TiffinSkip"> | string
    carry_forward_applied?: BoolFilter<"TiffinSkip"> | boolean
    created_by?: StringFilter<"TiffinSkip"> | string
    created_at?: DateTimeFilter<"TiffinSkip"> | Date | string
    updated_at?: DateTimeFilter<"TiffinSkip"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TiffinSkipOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    skip_date?: SortOrder
    meal_type?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    carry_forward_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TiffinSkipCountOrderByAggregateInput
    _max?: TiffinSkipMaxOrderByAggregateInput
    _min?: TiffinSkipMinOrderByAggregateInput
  }

  export type TiffinSkipScalarWhereWithAggregatesInput = {
    AND?: TiffinSkipScalarWhereWithAggregatesInput | TiffinSkipScalarWhereWithAggregatesInput[]
    OR?: TiffinSkipScalarWhereWithAggregatesInput[]
    NOT?: TiffinSkipScalarWhereWithAggregatesInput | TiffinSkipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TiffinSkip"> | string
    customer_id?: StringWithAggregatesFilter<"TiffinSkip"> | string
    customer_name?: StringNullableWithAggregatesFilter<"TiffinSkip"> | string | null
    skip_date?: StringWithAggregatesFilter<"TiffinSkip"> | string
    meal_type?: StringNullableWithAggregatesFilter<"TiffinSkip"> | string | null
    reason?: StringNullableWithAggregatesFilter<"TiffinSkip"> | string | null
    status?: StringWithAggregatesFilter<"TiffinSkip"> | string
    carry_forward_applied?: BoolWithAggregatesFilter<"TiffinSkip"> | boolean
    created_by?: StringWithAggregatesFilter<"TiffinSkip"> | string
    created_at?: DateTimeWithAggregatesFilter<"TiffinSkip"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TiffinSkip"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    user_email?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    is_read?: BoolFilter<"Notification"> | boolean
    type?: StringNullableFilter<"Notification"> | string | null
    notification_type?: StringNullableFilter<"Notification"> | string | null
    customer_id?: StringNullableFilter<"Notification"> | string | null
    customer_name?: StringNullableFilter<"Notification"> | string | null
    days_left?: IntNullableFilter<"Notification"> | number | null
    amount_to_collect?: FloatNullableFilter<"Notification"> | number | null
    phone_number?: StringNullableFilter<"Notification"> | string | null
    email_sent?: BoolNullableFilter<"Notification"> | boolean | null
    created_at?: DateTimeFilter<"Notification"> | Date | string
    updated_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    read?: SortOrder
    is_read?: SortOrder
    type?: SortOrderInput | SortOrder
    notification_type?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    customer_name?: SortOrderInput | SortOrder
    days_left?: SortOrderInput | SortOrder
    amount_to_collect?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email_sent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    user_email?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    is_read?: BoolFilter<"Notification"> | boolean
    type?: StringNullableFilter<"Notification"> | string | null
    notification_type?: StringNullableFilter<"Notification"> | string | null
    customer_id?: StringNullableFilter<"Notification"> | string | null
    customer_name?: StringNullableFilter<"Notification"> | string | null
    days_left?: IntNullableFilter<"Notification"> | number | null
    amount_to_collect?: FloatNullableFilter<"Notification"> | number | null
    phone_number?: StringNullableFilter<"Notification"> | string | null
    email_sent?: BoolNullableFilter<"Notification"> | boolean | null
    created_at?: DateTimeFilter<"Notification"> | Date | string
    updated_at?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    read?: SortOrder
    is_read?: SortOrder
    type?: SortOrderInput | SortOrder
    notification_type?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    customer_name?: SortOrderInput | SortOrder
    days_left?: SortOrderInput | SortOrder
    amount_to_collect?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    email_sent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    user_email?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    type?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    notification_type?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    customer_id?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    customer_name?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    days_left?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    amount_to_collect?: FloatNullableWithAggregatesFilter<"Notification"> | number | null
    phone_number?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    email_sent?: BoolNullableWithAggregatesFilter<"Notification"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    user_email?: StringFilter<"ActivityLog"> | string
    user_name?: StringNullableFilter<"ActivityLog"> | string | null
    action_type?: StringFilter<"ActivityLog"> | string
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    created_by?: StringFilter<"ActivityLog"> | string
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrderInput | SortOrder
    action_type?: SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    user_email?: StringFilter<"ActivityLog"> | string
    user_name?: StringNullableFilter<"ActivityLog"> | string | null
    action_type?: StringFilter<"ActivityLog"> | string
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    created_by?: StringFilter<"ActivityLog"> | string
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrderInput | SortOrder
    action_type?: SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    user_email?: StringWithAggregatesFilter<"ActivityLog"> | string
    user_name?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action_type?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity_type?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    entity_id?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    description?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">
    created_by?: StringWithAggregatesFilter<"ActivityLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type IngredientWhereInput = {
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    unit?: StringNullableFilter<"Ingredient"> | string | null
    current_stock?: FloatNullableFilter<"Ingredient"> | number | null
    min_stock_threshold?: FloatNullableFilter<"Ingredient"> | number | null
    cost_per_unit?: FloatNullableFilter<"Ingredient"> | number | null
    total_value?: FloatNullableFilter<"Ingredient"> | number | null
    is_critical?: BoolFilter<"Ingredient"> | boolean
    last_purchase_date?: StringNullableFilter<"Ingredient"> | string | null
    created_by?: StringFilter<"Ingredient"> | string
    created_at?: DateTimeFilter<"Ingredient"> | Date | string
    updated_at?: DateTimeFilter<"Ingredient"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    wastages?: WastageListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    current_stock?: SortOrderInput | SortOrder
    min_stock_threshold?: SortOrderInput | SortOrder
    cost_per_unit?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    is_critical?: SortOrder
    last_purchase_date?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
    wastages?: WastageOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    name?: StringFilter<"Ingredient"> | string
    unit?: StringNullableFilter<"Ingredient"> | string | null
    current_stock?: FloatNullableFilter<"Ingredient"> | number | null
    min_stock_threshold?: FloatNullableFilter<"Ingredient"> | number | null
    cost_per_unit?: FloatNullableFilter<"Ingredient"> | number | null
    total_value?: FloatNullableFilter<"Ingredient"> | number | null
    is_critical?: BoolFilter<"Ingredient"> | boolean
    last_purchase_date?: StringNullableFilter<"Ingredient"> | string | null
    created_by?: StringFilter<"Ingredient"> | string
    created_at?: DateTimeFilter<"Ingredient"> | Date | string
    updated_at?: DateTimeFilter<"Ingredient"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    wastages?: WastageListRelationFilter
  }, "id">

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    current_stock?: SortOrderInput | SortOrder
    min_stock_threshold?: SortOrderInput | SortOrder
    cost_per_unit?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    is_critical?: SortOrder
    last_purchase_date?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _avg?: IngredientAvgOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
    _sum?: IngredientSumOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    OR?: IngredientScalarWhereWithAggregatesInput[]
    NOT?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ingredient"> | string
    name?: StringWithAggregatesFilter<"Ingredient"> | string
    unit?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
    current_stock?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    min_stock_threshold?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    cost_per_unit?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    total_value?: FloatNullableWithAggregatesFilter<"Ingredient"> | number | null
    is_critical?: BoolWithAggregatesFilter<"Ingredient"> | boolean
    last_purchase_date?: StringNullableWithAggregatesFilter<"Ingredient"> | string | null
    created_by?: StringWithAggregatesFilter<"Ingredient"> | string
    created_at?: DateTimeWithAggregatesFilter<"Ingredient"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Ingredient"> | Date | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    meal_type?: StringNullableFilter<"Recipe"> | string | null
    ingredients?: JsonNullableFilter<"Recipe">
    is_active?: BoolFilter<"Recipe"> | boolean
    total_cost?: FloatNullableFilter<"Recipe"> | number | null
    cost_per_serving?: FloatNullableFilter<"Recipe"> | number | null
    created_by?: StringFilter<"Recipe"> | string
    created_at?: DateTimeFilter<"Recipe"> | Date | string
    updated_at?: DateTimeFilter<"Recipe"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    ingredients?: SortOrderInput | SortOrder
    is_active?: SortOrder
    total_cost?: SortOrderInput | SortOrder
    cost_per_serving?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    meal_type?: StringNullableFilter<"Recipe"> | string | null
    ingredients?: JsonNullableFilter<"Recipe">
    is_active?: BoolFilter<"Recipe"> | boolean
    total_cost?: FloatNullableFilter<"Recipe"> | number | null
    cost_per_serving?: FloatNullableFilter<"Recipe"> | number | null
    created_by?: StringFilter<"Recipe"> | string
    created_at?: DateTimeFilter<"Recipe"> | Date | string
    updated_at?: DateTimeFilter<"Recipe"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    ingredients?: SortOrderInput | SortOrder
    is_active?: SortOrder
    total_cost?: SortOrderInput | SortOrder
    cost_per_serving?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    ingredients?: JsonNullableWithAggregatesFilter<"Recipe">
    is_active?: BoolWithAggregatesFilter<"Recipe"> | boolean
    total_cost?: FloatNullableWithAggregatesFilter<"Recipe"> | number | null
    cost_per_serving?: FloatNullableWithAggregatesFilter<"Recipe"> | number | null
    created_by?: StringWithAggregatesFilter<"Recipe"> | string
    created_at?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    created_by?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    created_by?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    created_by?: StringWithAggregatesFilter<"Supplier"> | string
    created_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    ingredient_id?: StringNullableFilter<"Purchase"> | string | null
    ingredient_name?: StringNullableFilter<"Purchase"> | string | null
    quantity?: FloatNullableFilter<"Purchase"> | number | null
    unit?: StringNullableFilter<"Purchase"> | string | null
    cost_per_unit?: FloatNullableFilter<"Purchase"> | number | null
    total_cost?: FloatNullableFilter<"Purchase"> | number | null
    supplier_id?: StringNullableFilter<"Purchase"> | string | null
    supplier_name?: StringNullableFilter<"Purchase"> | string | null
    purchase_date?: StringNullableFilter<"Purchase"> | string | null
    expiry_date?: StringNullableFilter<"Purchase"> | string | null
    bill_image_url?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    is_deleted?: BoolFilter<"Purchase"> | boolean
    created_by?: StringFilter<"Purchase"> | string
    created_at?: DateTimeFilter<"Purchase"> | Date | string
    updated_at?: DateTimeFilter<"Purchase"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    ingredient_id?: SortOrderInput | SortOrder
    ingredient_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    cost_per_unit?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    purchase_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    bill_image_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    ingredient_id?: StringNullableFilter<"Purchase"> | string | null
    ingredient_name?: StringNullableFilter<"Purchase"> | string | null
    quantity?: FloatNullableFilter<"Purchase"> | number | null
    unit?: StringNullableFilter<"Purchase"> | string | null
    cost_per_unit?: FloatNullableFilter<"Purchase"> | number | null
    total_cost?: FloatNullableFilter<"Purchase"> | number | null
    supplier_id?: StringNullableFilter<"Purchase"> | string | null
    supplier_name?: StringNullableFilter<"Purchase"> | string | null
    purchase_date?: StringNullableFilter<"Purchase"> | string | null
    expiry_date?: StringNullableFilter<"Purchase"> | string | null
    bill_image_url?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    is_deleted?: BoolFilter<"Purchase"> | boolean
    created_by?: StringFilter<"Purchase"> | string
    created_at?: DateTimeFilter<"Purchase"> | Date | string
    updated_at?: DateTimeFilter<"Purchase"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    ingredient_id?: SortOrderInput | SortOrder
    ingredient_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    cost_per_unit?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    supplier_id?: SortOrderInput | SortOrder
    supplier_name?: SortOrderInput | SortOrder
    purchase_date?: SortOrderInput | SortOrder
    expiry_date?: SortOrderInput | SortOrder
    bill_image_url?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    ingredient_id?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    ingredient_name?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    quantity?: FloatNullableWithAggregatesFilter<"Purchase"> | number | null
    unit?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    cost_per_unit?: FloatNullableWithAggregatesFilter<"Purchase"> | number | null
    total_cost?: FloatNullableWithAggregatesFilter<"Purchase"> | number | null
    supplier_id?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    supplier_name?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    purchase_date?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    expiry_date?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    bill_image_url?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"Purchase"> | boolean
    created_by?: StringWithAggregatesFilter<"Purchase"> | string
    created_at?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type WastageWhereInput = {
    AND?: WastageWhereInput | WastageWhereInput[]
    OR?: WastageWhereInput[]
    NOT?: WastageWhereInput | WastageWhereInput[]
    id?: StringFilter<"Wastage"> | string
    ingredient_id?: StringFilter<"Wastage"> | string
    ingredient_name?: StringNullableFilter<"Wastage"> | string | null
    quantity?: FloatNullableFilter<"Wastage"> | number | null
    unit?: StringNullableFilter<"Wastage"> | string | null
    reason?: StringNullableFilter<"Wastage"> | string | null
    cost_value?: FloatNullableFilter<"Wastage"> | number | null
    wastage_date?: StringNullableFilter<"Wastage"> | string | null
    notes?: StringNullableFilter<"Wastage"> | string | null
    is_deleted?: BoolFilter<"Wastage"> | boolean
    created_by?: StringFilter<"Wastage"> | string
    created_at?: DateTimeFilter<"Wastage"> | Date | string
    updated_at?: DateTimeFilter<"Wastage"> | Date | string
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WastageOrderByWithRelationInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    cost_value?: SortOrderInput | SortOrder
    wastage_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type WastageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WastageWhereInput | WastageWhereInput[]
    OR?: WastageWhereInput[]
    NOT?: WastageWhereInput | WastageWhereInput[]
    ingredient_id?: StringFilter<"Wastage"> | string
    ingredient_name?: StringNullableFilter<"Wastage"> | string | null
    quantity?: FloatNullableFilter<"Wastage"> | number | null
    unit?: StringNullableFilter<"Wastage"> | string | null
    reason?: StringNullableFilter<"Wastage"> | string | null
    cost_value?: FloatNullableFilter<"Wastage"> | number | null
    wastage_date?: StringNullableFilter<"Wastage"> | string | null
    notes?: StringNullableFilter<"Wastage"> | string | null
    is_deleted?: BoolFilter<"Wastage"> | boolean
    created_by?: StringFilter<"Wastage"> | string
    created_at?: DateTimeFilter<"Wastage"> | Date | string
    updated_at?: DateTimeFilter<"Wastage"> | Date | string
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WastageOrderByWithAggregationInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    cost_value?: SortOrderInput | SortOrder
    wastage_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: WastageCountOrderByAggregateInput
    _avg?: WastageAvgOrderByAggregateInput
    _max?: WastageMaxOrderByAggregateInput
    _min?: WastageMinOrderByAggregateInput
    _sum?: WastageSumOrderByAggregateInput
  }

  export type WastageScalarWhereWithAggregatesInput = {
    AND?: WastageScalarWhereWithAggregatesInput | WastageScalarWhereWithAggregatesInput[]
    OR?: WastageScalarWhereWithAggregatesInput[]
    NOT?: WastageScalarWhereWithAggregatesInput | WastageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wastage"> | string
    ingredient_id?: StringWithAggregatesFilter<"Wastage"> | string
    ingredient_name?: StringNullableWithAggregatesFilter<"Wastage"> | string | null
    quantity?: FloatNullableWithAggregatesFilter<"Wastage"> | number | null
    unit?: StringNullableWithAggregatesFilter<"Wastage"> | string | null
    reason?: StringNullableWithAggregatesFilter<"Wastage"> | string | null
    cost_value?: FloatNullableWithAggregatesFilter<"Wastage"> | number | null
    wastage_date?: StringNullableWithAggregatesFilter<"Wastage"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Wastage"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"Wastage"> | boolean
    created_by?: StringWithAggregatesFilter<"Wastage"> | string
    created_at?: DateTimeWithAggregatesFilter<"Wastage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Wastage"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    user_email?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringNullableFilter<"SupportTicket"> | string | null
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringNullableFilter<"SupportTicket"> | string | null
    created_at?: DateTimeFilter<"SupportTicket"> | Date | string
    updated_at?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    subject?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    user_email?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringNullableFilter<"SupportTicket"> | string | null
    status?: StringFilter<"SupportTicket"> | string
    priority?: StringNullableFilter<"SupportTicket"> | string | null
    created_at?: DateTimeFilter<"SupportTicket"> | Date | string
    updated_at?: DateTimeFilter<"SupportTicket"> | Date | string
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    subject?: SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    user_email?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    message?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    user_email?: StringFilter<"Subscription"> | string
    plan_name?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    subscription_start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    amount?: FloatNullableFilter<"Subscription"> | number | null
    stripe_customer_id?: StringNullableFilter<"Subscription"> | string | null
    stripe_subscription_id?: StringNullableFilter<"Subscription"> | string | null
    payment_method_last4?: StringNullableFilter<"Subscription"> | string | null
    payment_method_brand?: StringNullableFilter<"Subscription"> | string | null
    cancelled_at?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancel_reason?: StringNullableFilter<"Subscription"> | string | null
    reminder_before_sent?: BoolNullableFilter<"Subscription"> | boolean | null
    reminder_after_sent?: BoolNullableFilter<"Subscription"> | boolean | null
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    plan_name?: SortOrderInput | SortOrder
    status?: SortOrder
    subscription_start_date?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    payment_method_last4?: SortOrderInput | SortOrder
    payment_method_brand?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancel_reason?: SortOrderInput | SortOrder
    reminder_before_sent?: SortOrderInput | SortOrder
    reminder_after_sent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    user_email?: StringFilter<"Subscription"> | string
    plan_name?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    subscription_start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    next_billing_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    current_period_end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    amount?: FloatNullableFilter<"Subscription"> | number | null
    stripe_customer_id?: StringNullableFilter<"Subscription"> | string | null
    stripe_subscription_id?: StringNullableFilter<"Subscription"> | string | null
    payment_method_last4?: StringNullableFilter<"Subscription"> | string | null
    payment_method_brand?: StringNullableFilter<"Subscription"> | string | null
    cancelled_at?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancel_reason?: StringNullableFilter<"Subscription"> | string | null
    reminder_before_sent?: BoolNullableFilter<"Subscription"> | boolean | null
    reminder_after_sent?: BoolNullableFilter<"Subscription"> | boolean | null
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    plan_name?: SortOrderInput | SortOrder
    status?: SortOrder
    subscription_start_date?: SortOrderInput | SortOrder
    next_billing_date?: SortOrderInput | SortOrder
    current_period_end?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_id?: SortOrderInput | SortOrder
    payment_method_last4?: SortOrderInput | SortOrder
    payment_method_brand?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancel_reason?: SortOrderInput | SortOrder
    reminder_before_sent?: SortOrderInput | SortOrder
    reminder_after_sent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    user_email?: StringWithAggregatesFilter<"Subscription"> | string
    plan_name?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    subscription_start_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    next_billing_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    current_period_end?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    amount?: FloatNullableWithAggregatesFilter<"Subscription"> | number | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripe_subscription_id?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    payment_method_last4?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    payment_method_brand?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancel_reason?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    reminder_before_sent?: BoolNullableWithAggregatesFilter<"Subscription"> | boolean | null
    reminder_after_sent?: BoolNullableWithAggregatesFilter<"Subscription"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentHistoryWhereInput = {
    AND?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    OR?: PaymentHistoryWhereInput[]
    NOT?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    id?: StringFilter<"PaymentHistory"> | string
    user_email?: StringFilter<"PaymentHistory"> | string
    subscription_id?: StringNullableFilter<"PaymentHistory"> | string | null
    amount?: FloatNullableFilter<"PaymentHistory"> | number | null
    currency?: StringNullableFilter<"PaymentHistory"> | string | null
    status?: StringNullableFilter<"PaymentHistory"> | string | null
    payment_date?: DateTimeNullableFilter<"PaymentHistory"> | Date | string | null
    stripe_payment_id?: StringNullableFilter<"PaymentHistory"> | string | null
    payment_method_last4?: StringNullableFilter<"PaymentHistory"> | string | null
    error_message?: StringNullableFilter<"PaymentHistory"> | string | null
    created_at?: DateTimeFilter<"PaymentHistory"> | Date | string
  }

  export type PaymentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    subscription_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    stripe_payment_id?: SortOrderInput | SortOrder
    payment_method_last4?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
  }

  export type PaymentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    OR?: PaymentHistoryWhereInput[]
    NOT?: PaymentHistoryWhereInput | PaymentHistoryWhereInput[]
    user_email?: StringFilter<"PaymentHistory"> | string
    subscription_id?: StringNullableFilter<"PaymentHistory"> | string | null
    amount?: FloatNullableFilter<"PaymentHistory"> | number | null
    currency?: StringNullableFilter<"PaymentHistory"> | string | null
    status?: StringNullableFilter<"PaymentHistory"> | string | null
    payment_date?: DateTimeNullableFilter<"PaymentHistory"> | Date | string | null
    stripe_payment_id?: StringNullableFilter<"PaymentHistory"> | string | null
    payment_method_last4?: StringNullableFilter<"PaymentHistory"> | string | null
    error_message?: StringNullableFilter<"PaymentHistory"> | string | null
    created_at?: DateTimeFilter<"PaymentHistory"> | Date | string
  }, "id">

  export type PaymentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    subscription_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    stripe_payment_id?: SortOrderInput | SortOrder
    payment_method_last4?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PaymentHistoryCountOrderByAggregateInput
    _avg?: PaymentHistoryAvgOrderByAggregateInput
    _max?: PaymentHistoryMaxOrderByAggregateInput
    _min?: PaymentHistoryMinOrderByAggregateInput
    _sum?: PaymentHistorySumOrderByAggregateInput
  }

  export type PaymentHistoryScalarWhereWithAggregatesInput = {
    AND?: PaymentHistoryScalarWhereWithAggregatesInput | PaymentHistoryScalarWhereWithAggregatesInput[]
    OR?: PaymentHistoryScalarWhereWithAggregatesInput[]
    NOT?: PaymentHistoryScalarWhereWithAggregatesInput | PaymentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentHistory"> | string
    user_email?: StringWithAggregatesFilter<"PaymentHistory"> | string
    subscription_id?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"PaymentHistory"> | number | null
    currency?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    status?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    payment_date?: DateTimeNullableWithAggregatesFilter<"PaymentHistory"> | Date | string | null
    stripe_payment_id?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    payment_method_last4?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    error_message?: StringNullableWithAggregatesFilter<"PaymentHistory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PaymentHistory"> | Date | string
  }

  export type PaymentLinkWhereInput = {
    AND?: PaymentLinkWhereInput | PaymentLinkWhereInput[]
    OR?: PaymentLinkWhereInput[]
    NOT?: PaymentLinkWhereInput | PaymentLinkWhereInput[]
    id?: StringFilter<"PaymentLink"> | string
    customer_id?: StringFilter<"PaymentLink"> | string
    customer_name?: StringNullableFilter<"PaymentLink"> | string | null
    amount?: FloatNullableFilter<"PaymentLink"> | number | null
    currency?: StringNullableFilter<"PaymentLink"> | string | null
    description?: StringNullableFilter<"PaymentLink"> | string | null
    status?: StringFilter<"PaymentLink"> | string
    stripe_checkout_session_id?: StringNullableFilter<"PaymentLink"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"PaymentLink"> | string | null
    checkout_url?: StringNullableFilter<"PaymentLink"> | string | null
    expires_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    platform_fee_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    net_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    payment_metadata?: JsonNullableFilter<"PaymentLink">
    created_by?: StringFilter<"PaymentLink"> | string
    created_at?: DateTimeFilter<"PaymentLink"> | Date | string
    updated_at?: DateTimeFilter<"PaymentLink"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentLinkOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    stripe_checkout_session_id?: SortOrderInput | SortOrder
    stripe_payment_intent_id?: SortOrderInput | SortOrder
    checkout_url?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    platform_fee_amount?: SortOrderInput | SortOrder
    net_amount?: SortOrderInput | SortOrder
    payment_metadata?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type PaymentLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentLinkWhereInput | PaymentLinkWhereInput[]
    OR?: PaymentLinkWhereInput[]
    NOT?: PaymentLinkWhereInput | PaymentLinkWhereInput[]
    customer_id?: StringFilter<"PaymentLink"> | string
    customer_name?: StringNullableFilter<"PaymentLink"> | string | null
    amount?: FloatNullableFilter<"PaymentLink"> | number | null
    currency?: StringNullableFilter<"PaymentLink"> | string | null
    description?: StringNullableFilter<"PaymentLink"> | string | null
    status?: StringFilter<"PaymentLink"> | string
    stripe_checkout_session_id?: StringNullableFilter<"PaymentLink"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"PaymentLink"> | string | null
    checkout_url?: StringNullableFilter<"PaymentLink"> | string | null
    expires_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    platform_fee_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    net_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    payment_metadata?: JsonNullableFilter<"PaymentLink">
    created_by?: StringFilter<"PaymentLink"> | string
    created_at?: DateTimeFilter<"PaymentLink"> | Date | string
    updated_at?: DateTimeFilter<"PaymentLink"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentLinkOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    stripe_checkout_session_id?: SortOrderInput | SortOrder
    stripe_payment_intent_id?: SortOrderInput | SortOrder
    checkout_url?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    platform_fee_amount?: SortOrderInput | SortOrder
    net_amount?: SortOrderInput | SortOrder
    payment_metadata?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentLinkCountOrderByAggregateInput
    _avg?: PaymentLinkAvgOrderByAggregateInput
    _max?: PaymentLinkMaxOrderByAggregateInput
    _min?: PaymentLinkMinOrderByAggregateInput
    _sum?: PaymentLinkSumOrderByAggregateInput
  }

  export type PaymentLinkScalarWhereWithAggregatesInput = {
    AND?: PaymentLinkScalarWhereWithAggregatesInput | PaymentLinkScalarWhereWithAggregatesInput[]
    OR?: PaymentLinkScalarWhereWithAggregatesInput[]
    NOT?: PaymentLinkScalarWhereWithAggregatesInput | PaymentLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentLink"> | string
    customer_id?: StringWithAggregatesFilter<"PaymentLink"> | string
    customer_name?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"PaymentLink"> | number | null
    currency?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    description?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    status?: StringWithAggregatesFilter<"PaymentLink"> | string
    stripe_checkout_session_id?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    stripe_payment_intent_id?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    checkout_url?: StringNullableWithAggregatesFilter<"PaymentLink"> | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"PaymentLink"> | Date | string | null
    paid_at?: DateTimeNullableWithAggregatesFilter<"PaymentLink"> | Date | string | null
    platform_fee_amount?: FloatNullableWithAggregatesFilter<"PaymentLink"> | number | null
    net_amount?: FloatNullableWithAggregatesFilter<"PaymentLink"> | number | null
    payment_metadata?: JsonNullableWithAggregatesFilter<"PaymentLink">
    created_by?: StringWithAggregatesFilter<"PaymentLink"> | string
    created_at?: DateTimeWithAggregatesFilter<"PaymentLink"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PaymentLink"> | Date | string
  }

  export type ConsumptionLogWhereInput = {
    AND?: ConsumptionLogWhereInput | ConsumptionLogWhereInput[]
    OR?: ConsumptionLogWhereInput[]
    NOT?: ConsumptionLogWhereInput | ConsumptionLogWhereInput[]
    id?: StringFilter<"ConsumptionLog"> | string
    date?: StringNullableFilter<"ConsumptionLog"> | string | null
    recipe_id?: StringNullableFilter<"ConsumptionLog"> | string | null
    recipe_name?: StringNullableFilter<"ConsumptionLog"> | string | null
    meal_type?: StringNullableFilter<"ConsumptionLog"> | string | null
    quantity_prepared?: IntNullableFilter<"ConsumptionLog"> | number | null
    ingredients_used?: JsonNullableFilter<"ConsumptionLog">
    total_cost?: FloatNullableFilter<"ConsumptionLog"> | number | null
    cost_per_meal?: FloatNullableFilter<"ConsumptionLog"> | number | null
    created_by?: StringNullableFilter<"ConsumptionLog"> | string | null
    created_at?: DateTimeFilter<"ConsumptionLog"> | Date | string
  }

  export type ConsumptionLogOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    recipe_id?: SortOrderInput | SortOrder
    recipe_name?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    quantity_prepared?: SortOrderInput | SortOrder
    ingredients_used?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    cost_per_meal?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
  }

  export type ConsumptionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsumptionLogWhereInput | ConsumptionLogWhereInput[]
    OR?: ConsumptionLogWhereInput[]
    NOT?: ConsumptionLogWhereInput | ConsumptionLogWhereInput[]
    date?: StringNullableFilter<"ConsumptionLog"> | string | null
    recipe_id?: StringNullableFilter<"ConsumptionLog"> | string | null
    recipe_name?: StringNullableFilter<"ConsumptionLog"> | string | null
    meal_type?: StringNullableFilter<"ConsumptionLog"> | string | null
    quantity_prepared?: IntNullableFilter<"ConsumptionLog"> | number | null
    ingredients_used?: JsonNullableFilter<"ConsumptionLog">
    total_cost?: FloatNullableFilter<"ConsumptionLog"> | number | null
    cost_per_meal?: FloatNullableFilter<"ConsumptionLog"> | number | null
    created_by?: StringNullableFilter<"ConsumptionLog"> | string | null
    created_at?: DateTimeFilter<"ConsumptionLog"> | Date | string
  }, "id">

  export type ConsumptionLogOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    recipe_id?: SortOrderInput | SortOrder
    recipe_name?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    quantity_prepared?: SortOrderInput | SortOrder
    ingredients_used?: SortOrderInput | SortOrder
    total_cost?: SortOrderInput | SortOrder
    cost_per_meal?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ConsumptionLogCountOrderByAggregateInput
    _avg?: ConsumptionLogAvgOrderByAggregateInput
    _max?: ConsumptionLogMaxOrderByAggregateInput
    _min?: ConsumptionLogMinOrderByAggregateInput
    _sum?: ConsumptionLogSumOrderByAggregateInput
  }

  export type ConsumptionLogScalarWhereWithAggregatesInput = {
    AND?: ConsumptionLogScalarWhereWithAggregatesInput | ConsumptionLogScalarWhereWithAggregatesInput[]
    OR?: ConsumptionLogScalarWhereWithAggregatesInput[]
    NOT?: ConsumptionLogScalarWhereWithAggregatesInput | ConsumptionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsumptionLog"> | string
    date?: StringNullableWithAggregatesFilter<"ConsumptionLog"> | string | null
    recipe_id?: StringNullableWithAggregatesFilter<"ConsumptionLog"> | string | null
    recipe_name?: StringNullableWithAggregatesFilter<"ConsumptionLog"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"ConsumptionLog"> | string | null
    quantity_prepared?: IntNullableWithAggregatesFilter<"ConsumptionLog"> | number | null
    ingredients_used?: JsonNullableWithAggregatesFilter<"ConsumptionLog">
    total_cost?: FloatNullableWithAggregatesFilter<"ConsumptionLog"> | number | null
    cost_per_meal?: FloatNullableWithAggregatesFilter<"ConsumptionLog"> | number | null
    created_by?: StringNullableWithAggregatesFilter<"ConsumptionLog"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ConsumptionLog"> | Date | string
  }

  export type MealRatingWhereInput = {
    AND?: MealRatingWhereInput | MealRatingWhereInput[]
    OR?: MealRatingWhereInput[]
    NOT?: MealRatingWhereInput | MealRatingWhereInput[]
    id?: StringFilter<"MealRating"> | string
    customer_id?: StringFilter<"MealRating"> | string
    customer_name?: StringNullableFilter<"MealRating"> | string | null
    order_id?: StringNullableFilter<"MealRating"> | string | null
    rating?: IntFilter<"MealRating"> | number
    feedback?: StringNullableFilter<"MealRating"> | string | null
    meal_type?: StringNullableFilter<"MealRating"> | string | null
    meal_date?: StringNullableFilter<"MealRating"> | string | null
    created_by?: StringFilter<"MealRating"> | string
    created_at?: DateTimeFilter<"MealRating"> | Date | string
  }

  export type MealRatingOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    meal_date?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MealRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealRatingWhereInput | MealRatingWhereInput[]
    OR?: MealRatingWhereInput[]
    NOT?: MealRatingWhereInput | MealRatingWhereInput[]
    customer_id?: StringFilter<"MealRating"> | string
    customer_name?: StringNullableFilter<"MealRating"> | string | null
    order_id?: StringNullableFilter<"MealRating"> | string | null
    rating?: IntFilter<"MealRating"> | number
    feedback?: StringNullableFilter<"MealRating"> | string | null
    meal_type?: StringNullableFilter<"MealRating"> | string | null
    meal_date?: StringNullableFilter<"MealRating"> | string | null
    created_by?: StringFilter<"MealRating"> | string
    created_at?: DateTimeFilter<"MealRating"> | Date | string
  }, "id">

  export type MealRatingOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    rating?: SortOrder
    feedback?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    meal_date?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: MealRatingCountOrderByAggregateInput
    _avg?: MealRatingAvgOrderByAggregateInput
    _max?: MealRatingMaxOrderByAggregateInput
    _min?: MealRatingMinOrderByAggregateInput
    _sum?: MealRatingSumOrderByAggregateInput
  }

  export type MealRatingScalarWhereWithAggregatesInput = {
    AND?: MealRatingScalarWhereWithAggregatesInput | MealRatingScalarWhereWithAggregatesInput[]
    OR?: MealRatingScalarWhereWithAggregatesInput[]
    NOT?: MealRatingScalarWhereWithAggregatesInput | MealRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MealRating"> | string
    customer_id?: StringWithAggregatesFilter<"MealRating"> | string
    customer_name?: StringNullableWithAggregatesFilter<"MealRating"> | string | null
    order_id?: StringNullableWithAggregatesFilter<"MealRating"> | string | null
    rating?: IntWithAggregatesFilter<"MealRating"> | number
    feedback?: StringNullableWithAggregatesFilter<"MealRating"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"MealRating"> | string | null
    meal_date?: StringNullableWithAggregatesFilter<"MealRating"> | string | null
    created_by?: StringWithAggregatesFilter<"MealRating"> | string
    created_at?: DateTimeWithAggregatesFilter<"MealRating"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoice_number?: StringFilter<"Invoice"> | string
    customer_id?: StringFilter<"Invoice"> | string
    customer_name?: StringNullableFilter<"Invoice"> | string | null
    customer_phone?: StringNullableFilter<"Invoice"> | string | null
    customer_address?: StringNullableFilter<"Invoice"> | string | null
    amount?: FloatFilter<"Invoice"> | number
    tax_amount?: FloatNullableFilter<"Invoice"> | number | null
    total_amount?: FloatFilter<"Invoice"> | number
    currency?: StringNullableFilter<"Invoice"> | string | null
    period_start?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    period_end?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    trn_number?: StringNullableFilter<"Invoice"> | string | null
    business_name?: StringNullableFilter<"Invoice"> | string | null
    business_address?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    created_by?: StringFilter<"Invoice"> | string
    created_at?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_phone?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    period_start?: SortOrderInput | SortOrder
    period_end?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    trn_number?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoice_number?: StringFilter<"Invoice"> | string
    customer_id?: StringFilter<"Invoice"> | string
    customer_name?: StringNullableFilter<"Invoice"> | string | null
    customer_phone?: StringNullableFilter<"Invoice"> | string | null
    customer_address?: StringNullableFilter<"Invoice"> | string | null
    amount?: FloatFilter<"Invoice"> | number
    tax_amount?: FloatNullableFilter<"Invoice"> | number | null
    total_amount?: FloatFilter<"Invoice"> | number
    currency?: StringNullableFilter<"Invoice"> | string | null
    period_start?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    period_end?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    status?: StringNullableFilter<"Invoice"> | string | null
    trn_number?: StringNullableFilter<"Invoice"> | string | null
    business_name?: StringNullableFilter<"Invoice"> | string | null
    business_address?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    created_by?: StringFilter<"Invoice"> | string
    created_at?: DateTimeFilter<"Invoice"> | Date | string
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_phone?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    period_start?: SortOrderInput | SortOrder
    period_end?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    trn_number?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoice_number?: StringWithAggregatesFilter<"Invoice"> | string
    customer_id?: StringWithAggregatesFilter<"Invoice"> | string
    customer_name?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customer_phone?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customer_address?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    tax_amount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    total_amount?: FloatWithAggregatesFilter<"Invoice"> | number
    currency?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    period_start?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    period_end?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    trn_number?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    business_address?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    created_by?: StringWithAggregatesFilter<"Invoice"> | string
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrer_id?: StringFilter<"Referral"> | string
    referrer_name?: StringNullableFilter<"Referral"> | string | null
    referred_id?: StringNullableFilter<"Referral"> | string | null
    referred_name?: StringNullableFilter<"Referral"> | string | null
    referral_code?: StringFilter<"Referral"> | string
    status?: StringNullableFilter<"Referral"> | string | null
    discount_amount?: FloatNullableFilter<"Referral"> | number | null
    discount_applied?: BoolNullableFilter<"Referral"> | boolean | null
    created_by?: StringFilter<"Referral"> | string
    created_at?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrer_id?: SortOrder
    referrer_name?: SortOrderInput | SortOrder
    referred_id?: SortOrderInput | SortOrder
    referred_name?: SortOrderInput | SortOrder
    referral_code?: SortOrder
    status?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    discount_applied?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrer_id?: StringFilter<"Referral"> | string
    referrer_name?: StringNullableFilter<"Referral"> | string | null
    referred_id?: StringNullableFilter<"Referral"> | string | null
    referred_name?: StringNullableFilter<"Referral"> | string | null
    referral_code?: StringFilter<"Referral"> | string
    status?: StringNullableFilter<"Referral"> | string | null
    discount_amount?: FloatNullableFilter<"Referral"> | number | null
    discount_applied?: BoolNullableFilter<"Referral"> | boolean | null
    created_by?: StringFilter<"Referral"> | string
    created_at?: DateTimeFilter<"Referral"> | Date | string
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrer_id?: SortOrder
    referrer_name?: SortOrderInput | SortOrder
    referred_id?: SortOrderInput | SortOrder
    referred_name?: SortOrderInput | SortOrder
    referral_code?: SortOrder
    status?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    discount_applied?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrer_id?: StringWithAggregatesFilter<"Referral"> | string
    referrer_name?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referred_id?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referred_name?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referral_code?: StringWithAggregatesFilter<"Referral"> | string
    status?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    discount_amount?: FloatNullableWithAggregatesFilter<"Referral"> | number | null
    discount_applied?: BoolNullableWithAggregatesFilter<"Referral"> | boolean | null
    created_by?: StringWithAggregatesFilter<"Referral"> | string
    created_at?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type FamilyGroupWhereInput = {
    AND?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    OR?: FamilyGroupWhereInput[]
    NOT?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    id?: StringFilter<"FamilyGroup"> | string
    name?: StringFilter<"FamilyGroup"> | string
    primary_contact?: StringNullableFilter<"FamilyGroup"> | string | null
    primary_phone?: StringNullableFilter<"FamilyGroup"> | string | null
    billing_amount?: FloatNullableFilter<"FamilyGroup"> | number | null
    billing_status?: StringNullableFilter<"FamilyGroup"> | string | null
    notes?: StringNullableFilter<"FamilyGroup"> | string | null
    created_by?: StringFilter<"FamilyGroup"> | string
    created_at?: DateTimeFilter<"FamilyGroup"> | Date | string
    updated_at?: DateTimeFilter<"FamilyGroup"> | Date | string
  }

  export type FamilyGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    primary_contact?: SortOrderInput | SortOrder
    primary_phone?: SortOrderInput | SortOrder
    billing_amount?: SortOrderInput | SortOrder
    billing_status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FamilyGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    OR?: FamilyGroupWhereInput[]
    NOT?: FamilyGroupWhereInput | FamilyGroupWhereInput[]
    name?: StringFilter<"FamilyGroup"> | string
    primary_contact?: StringNullableFilter<"FamilyGroup"> | string | null
    primary_phone?: StringNullableFilter<"FamilyGroup"> | string | null
    billing_amount?: FloatNullableFilter<"FamilyGroup"> | number | null
    billing_status?: StringNullableFilter<"FamilyGroup"> | string | null
    notes?: StringNullableFilter<"FamilyGroup"> | string | null
    created_by?: StringFilter<"FamilyGroup"> | string
    created_at?: DateTimeFilter<"FamilyGroup"> | Date | string
    updated_at?: DateTimeFilter<"FamilyGroup"> | Date | string
  }, "id">

  export type FamilyGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    primary_contact?: SortOrderInput | SortOrder
    primary_phone?: SortOrderInput | SortOrder
    billing_amount?: SortOrderInput | SortOrder
    billing_status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FamilyGroupCountOrderByAggregateInput
    _avg?: FamilyGroupAvgOrderByAggregateInput
    _max?: FamilyGroupMaxOrderByAggregateInput
    _min?: FamilyGroupMinOrderByAggregateInput
    _sum?: FamilyGroupSumOrderByAggregateInput
  }

  export type FamilyGroupScalarWhereWithAggregatesInput = {
    AND?: FamilyGroupScalarWhereWithAggregatesInput | FamilyGroupScalarWhereWithAggregatesInput[]
    OR?: FamilyGroupScalarWhereWithAggregatesInput[]
    NOT?: FamilyGroupScalarWhereWithAggregatesInput | FamilyGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyGroup"> | string
    name?: StringWithAggregatesFilter<"FamilyGroup"> | string
    primary_contact?: StringNullableWithAggregatesFilter<"FamilyGroup"> | string | null
    primary_phone?: StringNullableWithAggregatesFilter<"FamilyGroup"> | string | null
    billing_amount?: FloatNullableWithAggregatesFilter<"FamilyGroup"> | number | null
    billing_status?: StringNullableWithAggregatesFilter<"FamilyGroup"> | string | null
    notes?: StringNullableWithAggregatesFilter<"FamilyGroup"> | string | null
    created_by?: StringWithAggregatesFilter<"FamilyGroup"> | string
    created_at?: DateTimeWithAggregatesFilter<"FamilyGroup"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"FamilyGroup"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: StringFilter<"Driver"> | string
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    vehicle_number?: StringNullableFilter<"Driver"> | string | null
    is_active?: BoolFilter<"Driver"> | boolean
    access_code?: StringNullableFilter<"Driver"> | string | null
    created_by?: StringFilter<"Driver"> | string
    created_at?: DateTimeFilter<"Driver"> | Date | string
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    vehicle_number?: SortOrderInput | SortOrder
    is_active?: SortOrder
    access_code?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    access_code?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    vehicle_number?: StringNullableFilter<"Driver"> | string | null
    is_active?: BoolFilter<"Driver"> | boolean
    created_by?: StringFilter<"Driver"> | string
    created_at?: DateTimeFilter<"Driver"> | Date | string
  }, "id" | "access_code">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    vehicle_number?: SortOrderInput | SortOrder
    is_active?: SortOrder
    access_code?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Driver"> | string
    name?: StringWithAggregatesFilter<"Driver"> | string
    phone?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    vehicle_number?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    is_active?: BoolWithAggregatesFilter<"Driver"> | boolean
    access_code?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    created_by?: StringWithAggregatesFilter<"Driver"> | string
    created_at?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type DeliveryBatchWhereInput = {
    AND?: DeliveryBatchWhereInput | DeliveryBatchWhereInput[]
    OR?: DeliveryBatchWhereInput[]
    NOT?: DeliveryBatchWhereInput | DeliveryBatchWhereInput[]
    id?: StringFilter<"DeliveryBatch"> | string
    name?: StringNullableFilter<"DeliveryBatch"> | string | null
    area?: StringNullableFilter<"DeliveryBatch"> | string | null
    driver_id?: StringNullableFilter<"DeliveryBatch"> | string | null
    driver_name?: StringNullableFilter<"DeliveryBatch"> | string | null
    delivery_date?: StringFilter<"DeliveryBatch"> | string
    status?: StringNullableFilter<"DeliveryBatch"> | string | null
    total_orders?: IntNullableFilter<"DeliveryBatch"> | number | null
    delivered_count?: IntNullableFilter<"DeliveryBatch"> | number | null
    created_by?: StringFilter<"DeliveryBatch"> | string
    created_at?: DateTimeFilter<"DeliveryBatch"> | Date | string
  }

  export type DeliveryBatchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    driver_id?: SortOrderInput | SortOrder
    driver_name?: SortOrderInput | SortOrder
    delivery_date?: SortOrder
    status?: SortOrderInput | SortOrder
    total_orders?: SortOrderInput | SortOrder
    delivered_count?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryBatchWhereInput | DeliveryBatchWhereInput[]
    OR?: DeliveryBatchWhereInput[]
    NOT?: DeliveryBatchWhereInput | DeliveryBatchWhereInput[]
    name?: StringNullableFilter<"DeliveryBatch"> | string | null
    area?: StringNullableFilter<"DeliveryBatch"> | string | null
    driver_id?: StringNullableFilter<"DeliveryBatch"> | string | null
    driver_name?: StringNullableFilter<"DeliveryBatch"> | string | null
    delivery_date?: StringFilter<"DeliveryBatch"> | string
    status?: StringNullableFilter<"DeliveryBatch"> | string | null
    total_orders?: IntNullableFilter<"DeliveryBatch"> | number | null
    delivered_count?: IntNullableFilter<"DeliveryBatch"> | number | null
    created_by?: StringFilter<"DeliveryBatch"> | string
    created_at?: DateTimeFilter<"DeliveryBatch"> | Date | string
  }, "id">

  export type DeliveryBatchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    driver_id?: SortOrderInput | SortOrder
    driver_name?: SortOrderInput | SortOrder
    delivery_date?: SortOrder
    status?: SortOrderInput | SortOrder
    total_orders?: SortOrderInput | SortOrder
    delivered_count?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: DeliveryBatchCountOrderByAggregateInput
    _avg?: DeliveryBatchAvgOrderByAggregateInput
    _max?: DeliveryBatchMaxOrderByAggregateInput
    _min?: DeliveryBatchMinOrderByAggregateInput
    _sum?: DeliveryBatchSumOrderByAggregateInput
  }

  export type DeliveryBatchScalarWhereWithAggregatesInput = {
    AND?: DeliveryBatchScalarWhereWithAggregatesInput | DeliveryBatchScalarWhereWithAggregatesInput[]
    OR?: DeliveryBatchScalarWhereWithAggregatesInput[]
    NOT?: DeliveryBatchScalarWhereWithAggregatesInput | DeliveryBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryBatch"> | string
    name?: StringNullableWithAggregatesFilter<"DeliveryBatch"> | string | null
    area?: StringNullableWithAggregatesFilter<"DeliveryBatch"> | string | null
    driver_id?: StringNullableWithAggregatesFilter<"DeliveryBatch"> | string | null
    driver_name?: StringNullableWithAggregatesFilter<"DeliveryBatch"> | string | null
    delivery_date?: StringWithAggregatesFilter<"DeliveryBatch"> | string
    status?: StringNullableWithAggregatesFilter<"DeliveryBatch"> | string | null
    total_orders?: IntNullableWithAggregatesFilter<"DeliveryBatch"> | number | null
    delivered_count?: IntNullableWithAggregatesFilter<"DeliveryBatch"> | number | null
    created_by?: StringWithAggregatesFilter<"DeliveryBatch"> | string
    created_at?: DateTimeWithAggregatesFilter<"DeliveryBatch"> | Date | string
  }

  export type DeliveryItemWhereInput = {
    AND?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    OR?: DeliveryItemWhereInput[]
    NOT?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    id?: StringFilter<"DeliveryItem"> | string
    batch_id?: StringFilter<"DeliveryItem"> | string
    customer_id?: StringFilter<"DeliveryItem"> | string
    customer_name?: StringNullableFilter<"DeliveryItem"> | string | null
    customer_phone?: StringNullableFilter<"DeliveryItem"> | string | null
    customer_address?: StringNullableFilter<"DeliveryItem"> | string | null
    area?: StringNullableFilter<"DeliveryItem"> | string | null
    meal_type?: StringNullableFilter<"DeliveryItem"> | string | null
    roti_quantity?: IntNullableFilter<"DeliveryItem"> | number | null
    rice_type?: StringNullableFilter<"DeliveryItem"> | string | null
    special_notes?: StringNullableFilter<"DeliveryItem"> | string | null
    status?: StringNullableFilter<"DeliveryItem"> | string | null
    delivered_at?: DateTimeNullableFilter<"DeliveryItem"> | Date | string | null
    delivery_photo?: StringNullableFilter<"DeliveryItem"> | string | null
    notes?: StringNullableFilter<"DeliveryItem"> | string | null
    created_by?: StringFilter<"DeliveryItem"> | string
    created_at?: DateTimeFilter<"DeliveryItem"> | Date | string
  }

  export type DeliveryItemOrderByWithRelationInput = {
    id?: SortOrder
    batch_id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_phone?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    roti_quantity?: SortOrderInput | SortOrder
    rice_type?: SortOrderInput | SortOrder
    special_notes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    delivery_photo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    OR?: DeliveryItemWhereInput[]
    NOT?: DeliveryItemWhereInput | DeliveryItemWhereInput[]
    batch_id?: StringFilter<"DeliveryItem"> | string
    customer_id?: StringFilter<"DeliveryItem"> | string
    customer_name?: StringNullableFilter<"DeliveryItem"> | string | null
    customer_phone?: StringNullableFilter<"DeliveryItem"> | string | null
    customer_address?: StringNullableFilter<"DeliveryItem"> | string | null
    area?: StringNullableFilter<"DeliveryItem"> | string | null
    meal_type?: StringNullableFilter<"DeliveryItem"> | string | null
    roti_quantity?: IntNullableFilter<"DeliveryItem"> | number | null
    rice_type?: StringNullableFilter<"DeliveryItem"> | string | null
    special_notes?: StringNullableFilter<"DeliveryItem"> | string | null
    status?: StringNullableFilter<"DeliveryItem"> | string | null
    delivered_at?: DateTimeNullableFilter<"DeliveryItem"> | Date | string | null
    delivery_photo?: StringNullableFilter<"DeliveryItem"> | string | null
    notes?: StringNullableFilter<"DeliveryItem"> | string | null
    created_by?: StringFilter<"DeliveryItem"> | string
    created_at?: DateTimeFilter<"DeliveryItem"> | Date | string
  }, "id">

  export type DeliveryItemOrderByWithAggregationInput = {
    id?: SortOrder
    batch_id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    customer_phone?: SortOrderInput | SortOrder
    customer_address?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    roti_quantity?: SortOrderInput | SortOrder
    rice_type?: SortOrderInput | SortOrder
    special_notes?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    delivery_photo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: DeliveryItemCountOrderByAggregateInput
    _avg?: DeliveryItemAvgOrderByAggregateInput
    _max?: DeliveryItemMaxOrderByAggregateInput
    _min?: DeliveryItemMinOrderByAggregateInput
    _sum?: DeliveryItemSumOrderByAggregateInput
  }

  export type DeliveryItemScalarWhereWithAggregatesInput = {
    AND?: DeliveryItemScalarWhereWithAggregatesInput | DeliveryItemScalarWhereWithAggregatesInput[]
    OR?: DeliveryItemScalarWhereWithAggregatesInput[]
    NOT?: DeliveryItemScalarWhereWithAggregatesInput | DeliveryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryItem"> | string
    batch_id?: StringWithAggregatesFilter<"DeliveryItem"> | string
    customer_id?: StringWithAggregatesFilter<"DeliveryItem"> | string
    customer_name?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    customer_phone?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    customer_address?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    area?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    roti_quantity?: IntNullableWithAggregatesFilter<"DeliveryItem"> | number | null
    rice_type?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    special_notes?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    status?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    delivered_at?: DateTimeNullableWithAggregatesFilter<"DeliveryItem"> | Date | string | null
    delivery_photo?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"DeliveryItem"> | string | null
    created_by?: StringWithAggregatesFilter<"DeliveryItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"DeliveryItem"> | Date | string
  }

  export type ContainerWhereInput = {
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    id?: StringFilter<"Container"> | string
    customer_id?: StringFilter<"Container"> | string
    customer_name?: StringNullableFilter<"Container"> | string | null
    container_type?: StringNullableFilter<"Container"> | string | null
    given_date?: DateTimeNullableFilter<"Container"> | Date | string | null
    given_count?: IntFilter<"Container"> | number
    returned_count?: IntFilter<"Container"> | number
    outstanding?: IntFilter<"Container"> | number
    deposit_amount?: FloatNullableFilter<"Container"> | number | null
    deposit_paid?: BoolNullableFilter<"Container"> | boolean | null
    last_reminder?: DateTimeNullableFilter<"Container"> | Date | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    created_by?: StringFilter<"Container"> | string
    created_at?: DateTimeFilter<"Container"> | Date | string
    updated_at?: DateTimeFilter<"Container"> | Date | string
  }

  export type ContainerOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    container_type?: SortOrderInput | SortOrder
    given_date?: SortOrderInput | SortOrder
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrderInput | SortOrder
    deposit_paid?: SortOrderInput | SortOrder
    last_reminder?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ContainerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContainerWhereInput | ContainerWhereInput[]
    OR?: ContainerWhereInput[]
    NOT?: ContainerWhereInput | ContainerWhereInput[]
    customer_id?: StringFilter<"Container"> | string
    customer_name?: StringNullableFilter<"Container"> | string | null
    container_type?: StringNullableFilter<"Container"> | string | null
    given_date?: DateTimeNullableFilter<"Container"> | Date | string | null
    given_count?: IntFilter<"Container"> | number
    returned_count?: IntFilter<"Container"> | number
    outstanding?: IntFilter<"Container"> | number
    deposit_amount?: FloatNullableFilter<"Container"> | number | null
    deposit_paid?: BoolNullableFilter<"Container"> | boolean | null
    last_reminder?: DateTimeNullableFilter<"Container"> | Date | string | null
    notes?: StringNullableFilter<"Container"> | string | null
    created_by?: StringFilter<"Container"> | string
    created_at?: DateTimeFilter<"Container"> | Date | string
    updated_at?: DateTimeFilter<"Container"> | Date | string
  }, "id">

  export type ContainerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    container_type?: SortOrderInput | SortOrder
    given_date?: SortOrderInput | SortOrder
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrderInput | SortOrder
    deposit_paid?: SortOrderInput | SortOrder
    last_reminder?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ContainerCountOrderByAggregateInput
    _avg?: ContainerAvgOrderByAggregateInput
    _max?: ContainerMaxOrderByAggregateInput
    _min?: ContainerMinOrderByAggregateInput
    _sum?: ContainerSumOrderByAggregateInput
  }

  export type ContainerScalarWhereWithAggregatesInput = {
    AND?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    OR?: ContainerScalarWhereWithAggregatesInput[]
    NOT?: ContainerScalarWhereWithAggregatesInput | ContainerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Container"> | string
    customer_id?: StringWithAggregatesFilter<"Container"> | string
    customer_name?: StringNullableWithAggregatesFilter<"Container"> | string | null
    container_type?: StringNullableWithAggregatesFilter<"Container"> | string | null
    given_date?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    given_count?: IntWithAggregatesFilter<"Container"> | number
    returned_count?: IntWithAggregatesFilter<"Container"> | number
    outstanding?: IntWithAggregatesFilter<"Container"> | number
    deposit_amount?: FloatNullableWithAggregatesFilter<"Container"> | number | null
    deposit_paid?: BoolNullableWithAggregatesFilter<"Container"> | boolean | null
    last_reminder?: DateTimeNullableWithAggregatesFilter<"Container"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Container"> | string | null
    created_by?: StringWithAggregatesFilter<"Container"> | string
    created_at?: DateTimeWithAggregatesFilter<"Container"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Container"> | Date | string
  }

  export type ContainerLogWhereInput = {
    AND?: ContainerLogWhereInput | ContainerLogWhereInput[]
    OR?: ContainerLogWhereInput[]
    NOT?: ContainerLogWhereInput | ContainerLogWhereInput[]
    id?: StringFilter<"ContainerLog"> | string
    container_id?: StringFilter<"ContainerLog"> | string
    customer_id?: StringFilter<"ContainerLog"> | string
    action?: StringFilter<"ContainerLog"> | string
    count?: IntFilter<"ContainerLog"> | number
    notes?: StringNullableFilter<"ContainerLog"> | string | null
    created_by?: StringFilter<"ContainerLog"> | string
    created_at?: DateTimeFilter<"ContainerLog"> | Date | string
  }

  export type ContainerLogOrderByWithRelationInput = {
    id?: SortOrder
    container_id?: SortOrder
    customer_id?: SortOrder
    action?: SortOrder
    count?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ContainerLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContainerLogWhereInput | ContainerLogWhereInput[]
    OR?: ContainerLogWhereInput[]
    NOT?: ContainerLogWhereInput | ContainerLogWhereInput[]
    container_id?: StringFilter<"ContainerLog"> | string
    customer_id?: StringFilter<"ContainerLog"> | string
    action?: StringFilter<"ContainerLog"> | string
    count?: IntFilter<"ContainerLog"> | number
    notes?: StringNullableFilter<"ContainerLog"> | string | null
    created_by?: StringFilter<"ContainerLog"> | string
    created_at?: DateTimeFilter<"ContainerLog"> | Date | string
  }, "id">

  export type ContainerLogOrderByWithAggregationInput = {
    id?: SortOrder
    container_id?: SortOrder
    customer_id?: SortOrder
    action?: SortOrder
    count?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ContainerLogCountOrderByAggregateInput
    _avg?: ContainerLogAvgOrderByAggregateInput
    _max?: ContainerLogMaxOrderByAggregateInput
    _min?: ContainerLogMinOrderByAggregateInput
    _sum?: ContainerLogSumOrderByAggregateInput
  }

  export type ContainerLogScalarWhereWithAggregatesInput = {
    AND?: ContainerLogScalarWhereWithAggregatesInput | ContainerLogScalarWhereWithAggregatesInput[]
    OR?: ContainerLogScalarWhereWithAggregatesInput[]
    NOT?: ContainerLogScalarWhereWithAggregatesInput | ContainerLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContainerLog"> | string
    container_id?: StringWithAggregatesFilter<"ContainerLog"> | string
    customer_id?: StringWithAggregatesFilter<"ContainerLog"> | string
    action?: StringWithAggregatesFilter<"ContainerLog"> | string
    count?: IntWithAggregatesFilter<"ContainerLog"> | number
    notes?: StringNullableWithAggregatesFilter<"ContainerLog"> | string | null
    created_by?: StringWithAggregatesFilter<"ContainerLog"> | string
    created_at?: DateTimeWithAggregatesFilter<"ContainerLog"> | Date | string
  }

  export type KitchenWhereInput = {
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    id?: StringFilter<"Kitchen"> | string
    name?: StringFilter<"Kitchen"> | string
    address?: StringNullableFilter<"Kitchen"> | string | null
    phone?: StringNullableFilter<"Kitchen"> | string | null
    manager_name?: StringNullableFilter<"Kitchen"> | string | null
    capacity?: IntNullableFilter<"Kitchen"> | number | null
    areas_served?: StringNullableFilter<"Kitchen"> | string | null
    is_active?: BoolFilter<"Kitchen"> | boolean
    created_by?: StringFilter<"Kitchen"> | string
    created_at?: DateTimeFilter<"Kitchen"> | Date | string
  }

  export type KitchenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    manager_name?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    areas_served?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type KitchenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    name?: StringFilter<"Kitchen"> | string
    address?: StringNullableFilter<"Kitchen"> | string | null
    phone?: StringNullableFilter<"Kitchen"> | string | null
    manager_name?: StringNullableFilter<"Kitchen"> | string | null
    capacity?: IntNullableFilter<"Kitchen"> | number | null
    areas_served?: StringNullableFilter<"Kitchen"> | string | null
    is_active?: BoolFilter<"Kitchen"> | boolean
    created_by?: StringFilter<"Kitchen"> | string
    created_at?: DateTimeFilter<"Kitchen"> | Date | string
  }, "id">

  export type KitchenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    manager_name?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    areas_served?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: KitchenCountOrderByAggregateInput
    _avg?: KitchenAvgOrderByAggregateInput
    _max?: KitchenMaxOrderByAggregateInput
    _min?: KitchenMinOrderByAggregateInput
    _sum?: KitchenSumOrderByAggregateInput
  }

  export type KitchenScalarWhereWithAggregatesInput = {
    AND?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    OR?: KitchenScalarWhereWithAggregatesInput[]
    NOT?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kitchen"> | string
    name?: StringWithAggregatesFilter<"Kitchen"> | string
    address?: StringNullableWithAggregatesFilter<"Kitchen"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Kitchen"> | string | null
    manager_name?: StringNullableWithAggregatesFilter<"Kitchen"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"Kitchen"> | number | null
    areas_served?: StringNullableWithAggregatesFilter<"Kitchen"> | string | null
    is_active?: BoolWithAggregatesFilter<"Kitchen"> | boolean
    created_by?: StringWithAggregatesFilter<"Kitchen"> | string
    created_at?: DateTimeWithAggregatesFilter<"Kitchen"> | Date | string
  }

  export type PrepItemWhereInput = {
    AND?: PrepItemWhereInput | PrepItemWhereInput[]
    OR?: PrepItemWhereInput[]
    NOT?: PrepItemWhereInput | PrepItemWhereInput[]
    id?: StringFilter<"PrepItem"> | string
    kitchen_id?: StringNullableFilter<"PrepItem"> | string | null
    meal_type?: StringNullableFilter<"PrepItem"> | string | null
    prep_date?: StringFilter<"PrepItem"> | string
    item_name?: StringFilter<"PrepItem"> | string
    quantity?: IntFilter<"PrepItem"> | number
    unit?: StringNullableFilter<"PrepItem"> | string | null
    status?: StringNullableFilter<"PrepItem"> | string | null
    prepared_by?: StringNullableFilter<"PrepItem"> | string | null
    prepared_at?: DateTimeNullableFilter<"PrepItem"> | Date | string | null
    notes?: StringNullableFilter<"PrepItem"> | string | null
    created_by?: StringFilter<"PrepItem"> | string
    created_at?: DateTimeFilter<"PrepItem"> | Date | string
  }

  export type PrepItemOrderByWithRelationInput = {
    id?: SortOrder
    kitchen_id?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    prep_date?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    prepared_by?: SortOrderInput | SortOrder
    prepared_at?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type PrepItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrepItemWhereInput | PrepItemWhereInput[]
    OR?: PrepItemWhereInput[]
    NOT?: PrepItemWhereInput | PrepItemWhereInput[]
    kitchen_id?: StringNullableFilter<"PrepItem"> | string | null
    meal_type?: StringNullableFilter<"PrepItem"> | string | null
    prep_date?: StringFilter<"PrepItem"> | string
    item_name?: StringFilter<"PrepItem"> | string
    quantity?: IntFilter<"PrepItem"> | number
    unit?: StringNullableFilter<"PrepItem"> | string | null
    status?: StringNullableFilter<"PrepItem"> | string | null
    prepared_by?: StringNullableFilter<"PrepItem"> | string | null
    prepared_at?: DateTimeNullableFilter<"PrepItem"> | Date | string | null
    notes?: StringNullableFilter<"PrepItem"> | string | null
    created_by?: StringFilter<"PrepItem"> | string
    created_at?: DateTimeFilter<"PrepItem"> | Date | string
  }, "id">

  export type PrepItemOrderByWithAggregationInput = {
    id?: SortOrder
    kitchen_id?: SortOrderInput | SortOrder
    meal_type?: SortOrderInput | SortOrder
    prep_date?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    prepared_by?: SortOrderInput | SortOrder
    prepared_at?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: PrepItemCountOrderByAggregateInput
    _avg?: PrepItemAvgOrderByAggregateInput
    _max?: PrepItemMaxOrderByAggregateInput
    _min?: PrepItemMinOrderByAggregateInput
    _sum?: PrepItemSumOrderByAggregateInput
  }

  export type PrepItemScalarWhereWithAggregatesInput = {
    AND?: PrepItemScalarWhereWithAggregatesInput | PrepItemScalarWhereWithAggregatesInput[]
    OR?: PrepItemScalarWhereWithAggregatesInput[]
    NOT?: PrepItemScalarWhereWithAggregatesInput | PrepItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrepItem"> | string
    kitchen_id?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    meal_type?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    prep_date?: StringWithAggregatesFilter<"PrepItem"> | string
    item_name?: StringWithAggregatesFilter<"PrepItem"> | string
    quantity?: IntWithAggregatesFilter<"PrepItem"> | number
    unit?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    status?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    prepared_by?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    prepared_at?: DateTimeNullableWithAggregatesFilter<"PrepItem"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PrepItem"> | string | null
    created_by?: StringWithAggregatesFilter<"PrepItem"> | string
    created_at?: DateTimeWithAggregatesFilter<"PrepItem"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    customer_phone?: StringFilter<"ChatMessage"> | string
    direction?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    intent?: StringNullableFilter<"ChatMessage"> | string | null
    auto_replied?: BoolFilter<"ChatMessage"> | boolean
    reply_message?: StringNullableFilter<"ChatMessage"> | string | null
    created_by?: StringFilter<"ChatMessage"> | string
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    customer_phone?: SortOrder
    direction?: SortOrder
    message?: SortOrder
    intent?: SortOrderInput | SortOrder
    auto_replied?: SortOrder
    reply_message?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    customer_phone?: StringFilter<"ChatMessage"> | string
    direction?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    intent?: StringNullableFilter<"ChatMessage"> | string | null
    auto_replied?: BoolFilter<"ChatMessage"> | boolean
    reply_message?: StringNullableFilter<"ChatMessage"> | string | null
    created_by?: StringFilter<"ChatMessage"> | string
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    customer_phone?: SortOrder
    direction?: SortOrder
    message?: SortOrder
    intent?: SortOrderInput | SortOrder
    auto_replied?: SortOrder
    reply_message?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    customer_phone?: StringWithAggregatesFilter<"ChatMessage"> | string
    direction?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    intent?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    auto_replied?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    reply_message?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    created_by?: StringWithAggregatesFilter<"ChatMessage"> | string
    created_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    customerRef: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    customerRef?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenuItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipCreateInput = {
    id?: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutTiffinSkipsInput
    creator: UserCreateNestedOneWithoutTiffinSkipsInput
  }

  export type TiffinSkipUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTiffinSkipsNestedInput
    creator?: UserUpdateOneRequiredWithoutTiffinSkipsNestedInput
  }

  export type TiffinSkipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipCreateManyInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    user_email: string
    title: string
    message?: string | null
    read?: boolean
    is_read?: boolean
    type?: string | null
    notification_type?: string | null
    customer_id?: string | null
    customer_name?: string | null
    days_left?: number | null
    amount_to_collect?: number | null
    phone_number?: string | null
    email_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    user_email: string
    title: string
    message?: string | null
    read?: boolean
    is_read?: boolean
    type?: string | null
    notification_type?: string | null
    customer_id?: string | null
    customer_name?: string | null
    days_left?: number | null
    amount_to_collect?: number | null
    phone_number?: string | null
    email_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    is_read?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    days_left?: NullableIntFieldUpdateOperationsInput | number | null
    amount_to_collect?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    is_read?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    days_left?: NullableIntFieldUpdateOperationsInput | number | null
    amount_to_collect?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    user_email: string
    title: string
    message?: string | null
    read?: boolean
    is_read?: boolean
    type?: string | null
    notification_type?: string | null
    customer_id?: string | null
    customer_name?: string | null
    days_left?: number | null
    amount_to_collect?: number | null
    phone_number?: string | null
    email_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    is_read?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    days_left?: NullableIntFieldUpdateOperationsInput | number | null
    amount_to_collect?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    is_read?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    notification_type?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    days_left?: NullableIntFieldUpdateOperationsInput | number | null
    amount_to_collect?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    email_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    creator: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientCreateInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutIngredientsInput
    wastages?: WastageCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    wastages?: WastageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutIngredientsNestedInput
    wastages?: WastageUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wastages?: WastageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientCreateManyInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeCreateInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutRecipesInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutPurchasesInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageCreateInput = {
    id?: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    ingredient: IngredientCreateNestedOneWithoutWastagesInput
    creator: UserCreateNestedOneWithoutWastagesInput
  }

  export type WastageUncheckedCreateInput = {
    id?: string
    ingredient_id: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneRequiredWithoutWastagesNestedInput
    creator?: UserUpdateOneRequiredWithoutWastagesNestedInput
  }

  export type WastageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageCreateManyInput = {
    id?: string
    ingredient_id: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    user_email: string
    subject: string
    message?: string | null
    status?: string
    priority?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    user_email: string
    subject: string
    message?: string | null
    status?: string
    priority?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    user_email: string
    subject: string
    message?: string | null
    status?: string
    priority?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    user_email: string
    plan_name?: string | null
    status?: string
    subscription_start_date?: Date | string | null
    next_billing_date?: Date | string | null
    current_period_end?: Date | string | null
    amount?: number | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_method_last4?: string | null
    payment_method_brand?: string | null
    cancelled_at?: Date | string | null
    cancel_reason?: string | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    user_email: string
    plan_name?: string | null
    status?: string
    subscription_start_date?: Date | string | null
    next_billing_date?: Date | string | null
    current_period_end?: Date | string | null
    amount?: number | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_method_last4?: string | null
    payment_method_brand?: string | null
    cancelled_at?: Date | string | null
    cancel_reason?: string | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    plan_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    subscription_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_brand?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    plan_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    subscription_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_brand?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    user_email: string
    plan_name?: string | null
    status?: string
    subscription_start_date?: Date | string | null
    next_billing_date?: Date | string | null
    current_period_end?: Date | string | null
    amount?: number | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    payment_method_last4?: string | null
    payment_method_brand?: string | null
    cancelled_at?: Date | string | null
    cancel_reason?: string | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    plan_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    subscription_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_brand?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    plan_name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    subscription_start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_brand?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryCreateInput = {
    id?: string
    user_email: string
    subscription_id?: string | null
    amount?: number | null
    currency?: string | null
    status?: string | null
    payment_date?: Date | string | null
    stripe_payment_id?: string | null
    payment_method_last4?: string | null
    error_message?: string | null
    created_at?: Date | string
  }

  export type PaymentHistoryUncheckedCreateInput = {
    id?: string
    user_email: string
    subscription_id?: string | null
    amount?: number | null
    currency?: string | null
    status?: string | null
    payment_date?: Date | string | null
    stripe_payment_id?: string | null
    payment_method_last4?: string | null
    error_message?: string | null
    created_at?: Date | string
  }

  export type PaymentHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryCreateManyInput = {
    id?: string
    user_email: string
    subscription_id?: string | null
    amount?: number | null
    currency?: string | null
    status?: string | null
    payment_date?: Date | string | null
    stripe_payment_id?: string | null
    payment_method_last4?: string | null
    error_message?: string | null
    created_at?: Date | string
  }

  export type PaymentHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripe_payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method_last4?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkCreateInput = {
    id?: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentLinksInput
    creator: UserCreateNestedOneWithoutPaymentLinksInput
  }

  export type PaymentLinkUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentLinksNestedInput
    creator?: UserUpdateOneRequiredWithoutPaymentLinksNestedInput
  }

  export type PaymentLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkCreateManyInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionLogCreateInput = {
    id?: string
    date?: string | null
    recipe_id?: string | null
    recipe_name?: string | null
    meal_type?: string | null
    quantity_prepared?: number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: number | null
    cost_per_meal?: number | null
    created_by?: string | null
    created_at?: Date | string
  }

  export type ConsumptionLogUncheckedCreateInput = {
    id?: string
    date?: string | null
    recipe_id?: string | null
    recipe_name?: string | null
    meal_type?: string | null
    quantity_prepared?: number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: number | null
    cost_per_meal?: number | null
    created_by?: string | null
    created_at?: Date | string
  }

  export type ConsumptionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_id?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_prepared?: NullableIntFieldUpdateOperationsInput | number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_meal?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_id?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_prepared?: NullableIntFieldUpdateOperationsInput | number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_meal?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionLogCreateManyInput = {
    id?: string
    date?: string | null
    recipe_id?: string | null
    recipe_name?: string | null
    meal_type?: string | null
    quantity_prepared?: number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: number | null
    cost_per_meal?: number | null
    created_by?: string | null
    created_at?: Date | string
  }

  export type ConsumptionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_id?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_prepared?: NullableIntFieldUpdateOperationsInput | number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_meal?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsumptionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_id?: NullableStringFieldUpdateOperationsInput | string | null
    recipe_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_prepared?: NullableIntFieldUpdateOperationsInput | number | null
    ingredients_used?: NullableJsonNullValueInput | InputJsonValue
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_meal?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealRatingCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    order_id?: string | null
    rating?: number
    feedback?: string | null
    meal_type?: string | null
    meal_date?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type MealRatingUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    order_id?: string | null
    rating?: number
    feedback?: string | null
    meal_type?: string | null
    meal_date?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type MealRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    meal_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    meal_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealRatingCreateManyInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    order_id?: string | null
    rating?: number
    feedback?: string | null
    meal_type?: string | null
    meal_date?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type MealRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    meal_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    order_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    meal_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoice_number: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    amount?: number
    tax_amount?: number | null
    total_amount?: number
    currency?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    status?: string | null
    trn_number?: string | null
    business_name?: string | null
    business_address?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoice_number: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    amount?: number
    tax_amount?: number | null
    total_amount?: number
    currency?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    status?: string | null
    trn_number?: string | null
    business_name?: string | null
    business_address?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_amount?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    trn_number?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_amount?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    trn_number?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoice_number: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    amount?: number
    tax_amount?: number | null
    total_amount?: number
    currency?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    status?: string | null
    trn_number?: string | null
    business_name?: string | null
    business_address?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_amount?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    trn_number?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_amount?: FloatFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    trn_number?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    referrer_id: string
    referrer_name?: string | null
    referred_id?: string | null
    referred_name?: string | null
    referral_code: string
    status?: string | null
    discount_amount?: number | null
    discount_applied?: boolean | null
    created_by: string
    created_at?: Date | string
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrer_id: string
    referrer_name?: string | null
    referred_id?: string | null
    referred_name?: string | null
    referral_code: string
    status?: string | null
    discount_amount?: number | null
    discount_applied?: boolean | null
    created_by: string
    created_at?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrer_id?: StringFieldUpdateOperationsInput | string
    referrer_name?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: NullableStringFieldUpdateOperationsInput | string | null
    referred_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_applied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrer_id?: StringFieldUpdateOperationsInput | string
    referrer_name?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: NullableStringFieldUpdateOperationsInput | string | null
    referred_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_applied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrer_id: string
    referrer_name?: string | null
    referred_id?: string | null
    referred_name?: string | null
    referral_code: string
    status?: string | null
    discount_amount?: number | null
    discount_applied?: boolean | null
    created_by: string
    created_at?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrer_id?: StringFieldUpdateOperationsInput | string
    referrer_name?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: NullableStringFieldUpdateOperationsInput | string | null
    referred_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_applied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrer_id?: StringFieldUpdateOperationsInput | string
    referrer_name?: NullableStringFieldUpdateOperationsInput | string | null
    referred_id?: NullableStringFieldUpdateOperationsInput | string | null
    referred_name?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_applied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupCreateInput = {
    id?: string
    name: string
    primary_contact?: string | null
    primary_phone?: string | null
    billing_amount?: number | null
    billing_status?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FamilyGroupUncheckedCreateInput = {
    id?: string
    name: string
    primary_contact?: string | null
    primary_phone?: string | null
    billing_amount?: number | null
    billing_status?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FamilyGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    primary_contact?: NullableStringFieldUpdateOperationsInput | string | null
    primary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    billing_status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    primary_contact?: NullableStringFieldUpdateOperationsInput | string | null
    primary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    billing_status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupCreateManyInput = {
    id?: string
    name: string
    primary_contact?: string | null
    primary_phone?: string | null
    billing_amount?: number | null
    billing_status?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FamilyGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    primary_contact?: NullableStringFieldUpdateOperationsInput | string | null
    primary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    billing_status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    primary_contact?: NullableStringFieldUpdateOperationsInput | string | null
    primary_phone?: NullableStringFieldUpdateOperationsInput | string | null
    billing_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    billing_status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    id?: string
    name: string
    phone?: string | null
    vehicle_number?: string | null
    is_active?: boolean
    access_code?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DriverUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    vehicle_number?: string | null
    is_active?: boolean
    access_code?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    access_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    access_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    vehicle_number?: string | null
    is_active?: boolean
    access_code?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    access_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    access_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBatchCreateInput = {
    id?: string
    name?: string | null
    area?: string | null
    driver_id?: string | null
    driver_name?: string | null
    delivery_date: string
    status?: string | null
    total_orders?: number | null
    delivered_count?: number | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryBatchUncheckedCreateInput = {
    id?: string
    name?: string | null
    area?: string | null
    driver_id?: string | null
    driver_name?: string | null
    delivery_date: string
    status?: string | null
    total_orders?: number | null
    delivered_count?: number | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    driver_id?: NullableStringFieldUpdateOperationsInput | string | null
    driver_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_orders?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    driver_id?: NullableStringFieldUpdateOperationsInput | string | null
    driver_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_orders?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBatchCreateManyInput = {
    id?: string
    name?: string | null
    area?: string | null
    driver_id?: string | null
    driver_name?: string | null
    delivery_date: string
    status?: string | null
    total_orders?: number | null
    delivered_count?: number | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    driver_id?: NullableStringFieldUpdateOperationsInput | string | null
    driver_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_orders?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    driver_id?: NullableStringFieldUpdateOperationsInput | string | null
    driver_name?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_orders?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_count?: NullableIntFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemCreateInput = {
    id?: string
    batch_id: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    area?: string | null
    meal_type?: string | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    status?: string | null
    delivered_at?: Date | string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryItemUncheckedCreateInput = {
    id?: string
    batch_id: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    area?: string | null
    meal_type?: string | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    status?: string | null
    delivered_at?: Date | string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemCreateManyInput = {
    id?: string
    batch_id: string
    customer_id: string
    customer_name?: string | null
    customer_phone?: string | null
    customer_address?: string | null
    area?: string | null
    meal_type?: string | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    status?: string | null
    delivered_at?: Date | string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type DeliveryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    container_type?: string | null
    given_date?: Date | string | null
    given_count?: number
    returned_count?: number
    outstanding?: number
    deposit_amount?: number | null
    deposit_paid?: boolean | null
    last_reminder?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ContainerUncheckedCreateInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    container_type?: string | null
    given_date?: Date | string | null
    given_count?: number
    returned_count?: number
    outstanding?: number
    deposit_amount?: number | null
    deposit_paid?: boolean | null
    last_reminder?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ContainerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    given_count?: IntFieldUpdateOperationsInput | number
    returned_count?: IntFieldUpdateOperationsInput | number
    outstanding?: IntFieldUpdateOperationsInput | number
    deposit_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_reminder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    given_count?: IntFieldUpdateOperationsInput | number
    returned_count?: IntFieldUpdateOperationsInput | number
    outstanding?: IntFieldUpdateOperationsInput | number
    deposit_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_reminder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerCreateManyInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    container_type?: string | null
    given_date?: Date | string | null
    given_count?: number
    returned_count?: number
    outstanding?: number
    deposit_amount?: number | null
    deposit_paid?: boolean | null
    last_reminder?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ContainerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    given_count?: IntFieldUpdateOperationsInput | number
    returned_count?: IntFieldUpdateOperationsInput | number
    outstanding?: IntFieldUpdateOperationsInput | number
    deposit_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_reminder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    container_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    given_count?: IntFieldUpdateOperationsInput | number
    returned_count?: IntFieldUpdateOperationsInput | number
    outstanding?: IntFieldUpdateOperationsInput | number
    deposit_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    deposit_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_reminder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerLogCreateInput = {
    id?: string
    container_id: string
    customer_id: string
    action: string
    count?: number
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ContainerLogUncheckedCreateInput = {
    id?: string
    container_id: string
    customer_id: string
    action: string
    count?: number
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ContainerLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    container_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    container_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerLogCreateManyInput = {
    id?: string
    container_id: string
    customer_id: string
    action: string
    count?: number
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ContainerLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    container_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContainerLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    container_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    manager_name?: string | null
    capacity?: number | null
    areas_served?: string | null
    is_active?: boolean
    created_by: string
    created_at?: Date | string
  }

  export type KitchenUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    manager_name?: string | null
    capacity?: number | null
    areas_served?: string | null
    is_active?: boolean
    created_by: string
    created_at?: Date | string
  }

  export type KitchenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    areas_served?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    areas_served?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    manager_name?: string | null
    capacity?: number | null
    areas_served?: string | null
    is_active?: boolean
    created_by: string
    created_at?: Date | string
  }

  export type KitchenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    areas_served?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    manager_name?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    areas_served?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrepItemCreateInput = {
    id?: string
    kitchen_id?: string | null
    meal_type?: string | null
    prep_date: string
    item_name: string
    quantity?: number
    unit?: string | null
    status?: string | null
    prepared_by?: string | null
    prepared_at?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type PrepItemUncheckedCreateInput = {
    id?: string
    kitchen_id?: string | null
    meal_type?: string | null
    prep_date: string
    item_name: string
    quantity?: number
    unit?: string | null
    status?: string | null
    prepared_by?: string | null
    prepared_at?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type PrepItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    prep_date?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_by?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrepItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    prep_date?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_by?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrepItemCreateManyInput = {
    id?: string
    kitchen_id?: string | null
    meal_type?: string | null
    prep_date: string
    item_name: string
    quantity?: number
    unit?: string | null
    status?: string | null
    prepared_by?: string | null
    prepared_at?: Date | string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type PrepItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    prep_date?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_by?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrepItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    prep_date?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_by?: NullableStringFieldUpdateOperationsInput | string | null
    prepared_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    customer_phone: string
    direction?: string
    message: string
    intent?: string | null
    auto_replied?: boolean
    reply_message?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    customer_phone: string
    direction?: string
    message: string
    intent?: string | null
    auto_replied?: boolean
    reply_message?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    auto_replied?: BoolFieldUpdateOperationsInput | boolean
    reply_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    auto_replied?: BoolFieldUpdateOperationsInput | boolean
    reply_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    customer_phone: string
    direction?: string
    message: string
    intent?: string | null
    auto_replied?: boolean
    reply_message?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    auto_replied?: BoolFieldUpdateOperationsInput | boolean
    reply_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_phone?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    intent?: NullableStringFieldUpdateOperationsInput | string | null
    auto_replied?: BoolFieldUpdateOperationsInput | boolean
    reply_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type TiffinSkipListRelationFilter = {
    every?: TiffinSkipWhereInput
    some?: TiffinSkipWhereInput
    none?: TiffinSkipWhereInput
  }

  export type IngredientListRelationFilter = {
    every?: IngredientWhereInput
    some?: IngredientWhereInput
    none?: IngredientWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type WastageListRelationFilter = {
    every?: WastageWhereInput
    some?: WastageWhereInput
    none?: WastageWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type PaymentLinkListRelationFilter = {
    every?: PaymentLinkWhereInput
    some?: PaymentLinkWhereInput
    none?: PaymentLinkWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TiffinSkipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WastageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    business_name?: SortOrder
    logo_url?: SortOrder
    subscription_status?: SortOrder
    plan_type?: SortOrder
    subscription_source?: SortOrder
    trial_ends_at?: SortOrder
    trial_cancelled_at?: SortOrder
    subscription_ends_at?: SortOrder
    current_period_end?: SortOrder
    next_billing_date?: SortOrder
    cancel_at_period_end?: SortOrder
    cancellation_reason?: SortOrder
    cancelled_at?: SortOrder
    is_paid?: SortOrder
    last_payment_status?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_connect_account_id?: SortOrder
    payment_account_connected?: SortOrder
    payment_verification_status?: SortOrder
    fee_consent_accepted?: SortOrder
    fee_percentage?: SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
    whatsapp_notifications_enabled?: SortOrder
    whatsapp_number?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    seasonal_mode?: SortOrder
    seasonal_mode_start?: SortOrder
    seasonal_mode_end?: SortOrder
    ramadan_lunch_time?: SortOrder
    ramadan_dinner_time?: SortOrder
    ramadan_suhoor_time?: SortOrder
    ramadan_iftar_time?: SortOrder
    is_super_admin?: SortOrder
    special_access_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    fee_percentage?: SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    business_name?: SortOrder
    logo_url?: SortOrder
    subscription_status?: SortOrder
    plan_type?: SortOrder
    subscription_source?: SortOrder
    trial_ends_at?: SortOrder
    trial_cancelled_at?: SortOrder
    subscription_ends_at?: SortOrder
    current_period_end?: SortOrder
    next_billing_date?: SortOrder
    cancel_at_period_end?: SortOrder
    cancellation_reason?: SortOrder
    cancelled_at?: SortOrder
    is_paid?: SortOrder
    last_payment_status?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_connect_account_id?: SortOrder
    payment_account_connected?: SortOrder
    payment_verification_status?: SortOrder
    fee_consent_accepted?: SortOrder
    fee_percentage?: SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
    whatsapp_notifications_enabled?: SortOrder
    whatsapp_number?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    seasonal_mode?: SortOrder
    seasonal_mode_start?: SortOrder
    seasonal_mode_end?: SortOrder
    ramadan_lunch_time?: SortOrder
    ramadan_dinner_time?: SortOrder
    ramadan_suhoor_time?: SortOrder
    ramadan_iftar_time?: SortOrder
    is_super_admin?: SortOrder
    special_access_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    business_name?: SortOrder
    logo_url?: SortOrder
    subscription_status?: SortOrder
    plan_type?: SortOrder
    subscription_source?: SortOrder
    trial_ends_at?: SortOrder
    trial_cancelled_at?: SortOrder
    subscription_ends_at?: SortOrder
    current_period_end?: SortOrder
    next_billing_date?: SortOrder
    cancel_at_period_end?: SortOrder
    cancellation_reason?: SortOrder
    cancelled_at?: SortOrder
    is_paid?: SortOrder
    last_payment_status?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    stripe_connect_account_id?: SortOrder
    payment_account_connected?: SortOrder
    payment_verification_status?: SortOrder
    fee_consent_accepted?: SortOrder
    fee_percentage?: SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
    whatsapp_notifications_enabled?: SortOrder
    whatsapp_number?: SortOrder
    currency?: SortOrder
    language?: SortOrder
    seasonal_mode?: SortOrder
    seasonal_mode_start?: SortOrder
    seasonal_mode_end?: SortOrder
    ramadan_lunch_time?: SortOrder
    ramadan_dinner_time?: SortOrder
    ramadan_suhoor_time?: SortOrder
    ramadan_iftar_time?: SortOrder
    is_super_admin?: SortOrder
    special_access_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    fee_percentage?: SortOrder
    whatsapp_sent_count?: SortOrder
    whatsapp_limit?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    due_date?: SortOrder
    last_payment_date?: SortOrder
    last_payment_amount?: SortOrder
    active?: SortOrder
    status?: SortOrder
    inactive_reason?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    paid_days?: SortOrder
    delivered_days?: SortOrder
    days_remaining?: SortOrder
    meals_delivered?: SortOrder
    tiffin_balance?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    dietary_preference?: SortOrder
    skip_weekends?: SortOrder
    pause_start?: SortOrder
    pause_end?: SortOrder
    pause_start_date?: SortOrder
    pause_resume_date?: SortOrder
    original_end_date?: SortOrder
    total_pause_days?: SortOrder
    pause_history?: SortOrder
    notification_sent?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    notes?: SortOrder
    is_trial?: SortOrder
    trial_end_date?: SortOrder
    trial_converted?: SortOrder
    is_paused?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    portal_token?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    family_group_id?: SortOrder
    kitchen_id?: SortOrder
    registration_source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    payment_amount?: SortOrder
    last_payment_amount?: SortOrder
    paid_days?: SortOrder
    delivered_days?: SortOrder
    days_remaining?: SortOrder
    meals_delivered?: SortOrder
    tiffin_balance?: SortOrder
    roti_quantity?: SortOrder
    total_pause_days?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    due_date?: SortOrder
    last_payment_date?: SortOrder
    last_payment_amount?: SortOrder
    active?: SortOrder
    status?: SortOrder
    inactive_reason?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    paid_days?: SortOrder
    delivered_days?: SortOrder
    days_remaining?: SortOrder
    meals_delivered?: SortOrder
    tiffin_balance?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    dietary_preference?: SortOrder
    skip_weekends?: SortOrder
    pause_start?: SortOrder
    pause_end?: SortOrder
    pause_start_date?: SortOrder
    pause_resume_date?: SortOrder
    original_end_date?: SortOrder
    total_pause_days?: SortOrder
    notification_sent?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    notes?: SortOrder
    is_trial?: SortOrder
    trial_end_date?: SortOrder
    trial_converted?: SortOrder
    is_paused?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    portal_token?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    family_group_id?: SortOrder
    kitchen_id?: SortOrder
    registration_source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    payment_amount?: SortOrder
    payment_status?: SortOrder
    due_date?: SortOrder
    last_payment_date?: SortOrder
    last_payment_amount?: SortOrder
    active?: SortOrder
    status?: SortOrder
    inactive_reason?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    paid_days?: SortOrder
    delivered_days?: SortOrder
    days_remaining?: SortOrder
    meals_delivered?: SortOrder
    tiffin_balance?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    dietary_preference?: SortOrder
    skip_weekends?: SortOrder
    pause_start?: SortOrder
    pause_end?: SortOrder
    pause_start_date?: SortOrder
    pause_resume_date?: SortOrder
    original_end_date?: SortOrder
    total_pause_days?: SortOrder
    notification_sent?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    notes?: SortOrder
    is_trial?: SortOrder
    trial_end_date?: SortOrder
    trial_converted?: SortOrder
    is_paused?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    portal_token?: SortOrder
    referral_code?: SortOrder
    referred_by?: SortOrder
    family_group_id?: SortOrder
    kitchen_id?: SortOrder
    registration_source?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    payment_amount?: SortOrder
    last_payment_amount?: SortOrder
    paid_days?: SortOrder
    delivered_days?: SortOrder
    days_remaining?: SortOrder
    meals_delivered?: SortOrder
    tiffin_balance?: SortOrder
    roti_quantity?: SortOrder
    total_pause_days?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    meal_type?: SortOrder
    delivery_date?: SortOrder
    order_date?: SortOrder
    delivery_status?: SortOrder
    status?: SortOrder
    out_for_delivery_time?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    meal_type?: SortOrder
    delivery_date?: SortOrder
    order_date?: SortOrder
    delivery_status?: SortOrder
    status?: SortOrder
    out_for_delivery_time?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    meal_type?: SortOrder
    delivery_date?: SortOrder
    order_date?: SortOrder
    delivery_status?: SortOrder
    status?: SortOrder
    out_for_delivery_time?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    image_url?: SortOrder
    meal_type?: SortOrder
    is_active?: SortOrder
    day_of_week?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    image_url?: SortOrder
    meal_type?: SortOrder
    is_active?: SortOrder
    day_of_week?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    image_url?: SortOrder
    meal_type?: SortOrder
    is_active?: SortOrder
    day_of_week?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type TiffinSkipCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    skip_date?: SortOrder
    meal_type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    carry_forward_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiffinSkipMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    skip_date?: SortOrder
    meal_type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    carry_forward_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiffinSkipMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    skip_date?: SortOrder
    meal_type?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    carry_forward_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    is_read?: SortOrder
    type?: SortOrder
    notification_type?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    days_left?: SortOrder
    amount_to_collect?: SortOrder
    phone_number?: SortOrder
    email_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    days_left?: SortOrder
    amount_to_collect?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    is_read?: SortOrder
    type?: SortOrder
    notification_type?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    days_left?: SortOrder
    amount_to_collect?: SortOrder
    phone_number?: SortOrder
    email_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    is_read?: SortOrder
    type?: SortOrder
    notification_type?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    days_left?: SortOrder
    amount_to_collect?: SortOrder
    phone_number?: SortOrder
    email_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    days_left?: SortOrder
    amount_to_collect?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    description?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    description?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock_threshold?: SortOrder
    cost_per_unit?: SortOrder
    total_value?: SortOrder
    is_critical?: SortOrder
    last_purchase_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IngredientAvgOrderByAggregateInput = {
    current_stock?: SortOrder
    min_stock_threshold?: SortOrder
    cost_per_unit?: SortOrder
    total_value?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock_threshold?: SortOrder
    cost_per_unit?: SortOrder
    total_value?: SortOrder
    is_critical?: SortOrder
    last_purchase_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock_threshold?: SortOrder
    cost_per_unit?: SortOrder
    total_value?: SortOrder
    is_critical?: SortOrder
    last_purchase_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IngredientSumOrderByAggregateInput = {
    current_stock?: SortOrder
    min_stock_threshold?: SortOrder
    cost_per_unit?: SortOrder
    total_value?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    meal_type?: SortOrder
    ingredients?: SortOrder
    is_active?: SortOrder
    total_cost?: SortOrder
    cost_per_serving?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    total_cost?: SortOrder
    cost_per_serving?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    meal_type?: SortOrder
    is_active?: SortOrder
    total_cost?: SortOrder
    cost_per_serving?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    meal_type?: SortOrder
    is_active?: SortOrder
    total_cost?: SortOrder
    cost_per_serving?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    total_cost?: SortOrder
    cost_per_serving?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost_per_unit?: SortOrder
    total_cost?: SortOrder
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    purchase_date?: SortOrder
    expiry_date?: SortOrder
    bill_image_url?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    quantity?: SortOrder
    cost_per_unit?: SortOrder
    total_cost?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost_per_unit?: SortOrder
    total_cost?: SortOrder
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    purchase_date?: SortOrder
    expiry_date?: SortOrder
    bill_image_url?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    cost_per_unit?: SortOrder
    total_cost?: SortOrder
    supplier_id?: SortOrder
    supplier_name?: SortOrder
    purchase_date?: SortOrder
    expiry_date?: SortOrder
    bill_image_url?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    quantity?: SortOrder
    cost_per_unit?: SortOrder
    total_cost?: SortOrder
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput
    isNot?: IngredientWhereInput
  }

  export type WastageCountOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    reason?: SortOrder
    cost_value?: SortOrder
    wastage_date?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WastageAvgOrderByAggregateInput = {
    quantity?: SortOrder
    cost_value?: SortOrder
  }

  export type WastageMaxOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    reason?: SortOrder
    cost_value?: SortOrder
    wastage_date?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WastageMinOrderByAggregateInput = {
    id?: SortOrder
    ingredient_id?: SortOrder
    ingredient_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    reason?: SortOrder
    cost_value?: SortOrder
    wastage_date?: SortOrder
    notes?: SortOrder
    is_deleted?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type WastageSumOrderByAggregateInput = {
    quantity?: SortOrder
    cost_value?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    subscription_start_date?: SortOrder
    next_billing_date?: SortOrder
    current_period_end?: SortOrder
    amount?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_method_last4?: SortOrder
    payment_method_brand?: SortOrder
    cancelled_at?: SortOrder
    cancel_reason?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    subscription_start_date?: SortOrder
    next_billing_date?: SortOrder
    current_period_end?: SortOrder
    amount?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_method_last4?: SortOrder
    payment_method_brand?: SortOrder
    cancelled_at?: SortOrder
    cancel_reason?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    subscription_start_date?: SortOrder
    next_billing_date?: SortOrder
    current_period_end?: SortOrder
    amount?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_id?: SortOrder
    payment_method_last4?: SortOrder
    payment_method_brand?: SortOrder
    cancelled_at?: SortOrder
    cancel_reason?: SortOrder
    reminder_before_sent?: SortOrder
    reminder_after_sent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    payment_date?: SortOrder
    stripe_payment_id?: SortOrder
    payment_method_last4?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    payment_date?: SortOrder
    stripe_payment_id?: SortOrder
    payment_method_last4?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    payment_date?: SortOrder
    stripe_payment_id?: SortOrder
    payment_method_last4?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentHistorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentLinkCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    stripe_checkout_session_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    checkout_url?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    platform_fee_amount?: SortOrder
    net_amount?: SortOrder
    payment_metadata?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentLinkAvgOrderByAggregateInput = {
    amount?: SortOrder
    platform_fee_amount?: SortOrder
    net_amount?: SortOrder
  }

  export type PaymentLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    stripe_checkout_session_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    checkout_url?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    platform_fee_amount?: SortOrder
    net_amount?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentLinkMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    stripe_checkout_session_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    checkout_url?: SortOrder
    expires_at?: SortOrder
    paid_at?: SortOrder
    platform_fee_amount?: SortOrder
    net_amount?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentLinkSumOrderByAggregateInput = {
    amount?: SortOrder
    platform_fee_amount?: SortOrder
    net_amount?: SortOrder
  }

  export type ConsumptionLogCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    recipe_id?: SortOrder
    recipe_name?: SortOrder
    meal_type?: SortOrder
    quantity_prepared?: SortOrder
    ingredients_used?: SortOrder
    total_cost?: SortOrder
    cost_per_meal?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ConsumptionLogAvgOrderByAggregateInput = {
    quantity_prepared?: SortOrder
    total_cost?: SortOrder
    cost_per_meal?: SortOrder
  }

  export type ConsumptionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    recipe_id?: SortOrder
    recipe_name?: SortOrder
    meal_type?: SortOrder
    quantity_prepared?: SortOrder
    total_cost?: SortOrder
    cost_per_meal?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ConsumptionLogMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    recipe_id?: SortOrder
    recipe_name?: SortOrder
    meal_type?: SortOrder
    quantity_prepared?: SortOrder
    total_cost?: SortOrder
    cost_per_meal?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ConsumptionLogSumOrderByAggregateInput = {
    quantity_prepared?: SortOrder
    total_cost?: SortOrder
    cost_per_meal?: SortOrder
  }

  export type MealRatingCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    order_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    meal_type?: SortOrder
    meal_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MealRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type MealRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    order_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    meal_type?: SortOrder
    meal_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MealRatingMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    order_id?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
    meal_type?: SortOrder
    meal_date?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type MealRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    status?: SortOrder
    trn_number?: SortOrder
    business_name?: SortOrder
    business_address?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    status?: SortOrder
    trn_number?: SortOrder
    business_name?: SortOrder
    business_address?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    status?: SortOrder
    trn_number?: SortOrder
    business_name?: SortOrder
    business_address?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrer_id?: SortOrder
    referrer_name?: SortOrder
    referred_id?: SortOrder
    referred_name?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    discount_amount?: SortOrder
    discount_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    discount_amount?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrer_id?: SortOrder
    referrer_name?: SortOrder
    referred_id?: SortOrder
    referred_name?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    discount_amount?: SortOrder
    discount_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrer_id?: SortOrder
    referrer_name?: SortOrder
    referred_id?: SortOrder
    referred_name?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    discount_amount?: SortOrder
    discount_applied?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    discount_amount?: SortOrder
  }

  export type FamilyGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primary_contact?: SortOrder
    primary_phone?: SortOrder
    billing_amount?: SortOrder
    billing_status?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FamilyGroupAvgOrderByAggregateInput = {
    billing_amount?: SortOrder
  }

  export type FamilyGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primary_contact?: SortOrder
    primary_phone?: SortOrder
    billing_amount?: SortOrder
    billing_status?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FamilyGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primary_contact?: SortOrder
    primary_phone?: SortOrder
    billing_amount?: SortOrder
    billing_status?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FamilyGroupSumOrderByAggregateInput = {
    billing_amount?: SortOrder
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicle_number?: SortOrder
    is_active?: SortOrder
    access_code?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicle_number?: SortOrder
    is_active?: SortOrder
    access_code?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    vehicle_number?: SortOrder
    is_active?: SortOrder
    access_code?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryBatchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    area?: SortOrder
    driver_id?: SortOrder
    driver_name?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_orders?: SortOrder
    delivered_count?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryBatchAvgOrderByAggregateInput = {
    total_orders?: SortOrder
    delivered_count?: SortOrder
  }

  export type DeliveryBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    area?: SortOrder
    driver_id?: SortOrder
    driver_name?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_orders?: SortOrder
    delivered_count?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryBatchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    area?: SortOrder
    driver_id?: SortOrder
    driver_name?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_orders?: SortOrder
    delivered_count?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryBatchSumOrderByAggregateInput = {
    total_orders?: SortOrder
    delivered_count?: SortOrder
  }

  export type DeliveryItemCountOrderByAggregateInput = {
    id?: SortOrder
    batch_id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    status?: SortOrder
    delivered_at?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryItemAvgOrderByAggregateInput = {
    roti_quantity?: SortOrder
  }

  export type DeliveryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    batch_id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    status?: SortOrder
    delivered_at?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryItemMinOrderByAggregateInput = {
    id?: SortOrder
    batch_id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    customer_phone?: SortOrder
    customer_address?: SortOrder
    area?: SortOrder
    meal_type?: SortOrder
    roti_quantity?: SortOrder
    rice_type?: SortOrder
    special_notes?: SortOrder
    status?: SortOrder
    delivered_at?: SortOrder
    delivery_photo?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type DeliveryItemSumOrderByAggregateInput = {
    roti_quantity?: SortOrder
  }

  export type ContainerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    container_type?: SortOrder
    given_date?: SortOrder
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    last_reminder?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ContainerAvgOrderByAggregateInput = {
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrder
  }

  export type ContainerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    container_type?: SortOrder
    given_date?: SortOrder
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    last_reminder?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ContainerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    customer_name?: SortOrder
    container_type?: SortOrder
    given_date?: SortOrder
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrder
    deposit_paid?: SortOrder
    last_reminder?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ContainerSumOrderByAggregateInput = {
    given_count?: SortOrder
    returned_count?: SortOrder
    outstanding?: SortOrder
    deposit_amount?: SortOrder
  }

  export type ContainerLogCountOrderByAggregateInput = {
    id?: SortOrder
    container_id?: SortOrder
    customer_id?: SortOrder
    action?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ContainerLogAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type ContainerLogMaxOrderByAggregateInput = {
    id?: SortOrder
    container_id?: SortOrder
    customer_id?: SortOrder
    action?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ContainerLogMinOrderByAggregateInput = {
    id?: SortOrder
    container_id?: SortOrder
    customer_id?: SortOrder
    action?: SortOrder
    count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ContainerLogSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type KitchenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    manager_name?: SortOrder
    capacity?: SortOrder
    areas_served?: SortOrder
    is_active?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type KitchenAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type KitchenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    manager_name?: SortOrder
    capacity?: SortOrder
    areas_served?: SortOrder
    is_active?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type KitchenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    manager_name?: SortOrder
    capacity?: SortOrder
    areas_served?: SortOrder
    is_active?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type KitchenSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type PrepItemCountOrderByAggregateInput = {
    id?: SortOrder
    kitchen_id?: SortOrder
    meal_type?: SortOrder
    prep_date?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    prepared_by?: SortOrder
    prepared_at?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type PrepItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PrepItemMaxOrderByAggregateInput = {
    id?: SortOrder
    kitchen_id?: SortOrder
    meal_type?: SortOrder
    prep_date?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    prepared_by?: SortOrder
    prepared_at?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type PrepItemMinOrderByAggregateInput = {
    id?: SortOrder
    kitchen_id?: SortOrder
    meal_type?: SortOrder
    prep_date?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    status?: SortOrder
    prepared_by?: SortOrder
    prepared_at?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type PrepItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    customer_phone?: SortOrder
    direction?: SortOrder
    message?: SortOrder
    intent?: SortOrder
    auto_replied?: SortOrder
    reply_message?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_phone?: SortOrder
    direction?: SortOrder
    message?: SortOrder
    intent?: SortOrder
    auto_replied?: SortOrder
    reply_message?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    customer_phone?: SortOrder
    direction?: SortOrder
    message?: SortOrder
    intent?: SortOrder
    auto_replied?: SortOrder
    reply_message?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type CustomerCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MenuItemCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput> | MenuItemCreateWithoutCreatorInput[] | MenuItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCreatorInput | MenuItemCreateOrConnectWithoutCreatorInput[]
    createMany?: MenuItemCreateManyCreatorInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type TiffinSkipCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput> | TiffinSkipCreateWithoutCreatorInput[] | TiffinSkipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCreatorInput | TiffinSkipCreateOrConnectWithoutCreatorInput[]
    createMany?: TiffinSkipCreateManyCreatorInputEnvelope
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
  }

  export type IngredientCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput> | IngredientCreateWithoutCreatorInput[] | IngredientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatorInput | IngredientCreateOrConnectWithoutCreatorInput[]
    createMany?: IngredientCreateManyCreatorInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput> | RecipeCreateWithoutCreatorInput[] | RecipeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatorInput | RecipeCreateOrConnectWithoutCreatorInput[]
    createMany?: RecipeCreateManyCreatorInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput> | SupplierCreateWithoutCreatorInput[] | SupplierUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCreatorInput | SupplierCreateOrConnectWithoutCreatorInput[]
    createMany?: SupplierCreateManyCreatorInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput> | PurchaseCreateWithoutCreatorInput[] | PurchaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatorInput | PurchaseCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseCreateManyCreatorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type WastageCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput> | WastageCreateWithoutCreatorInput[] | WastageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutCreatorInput | WastageCreateOrConnectWithoutCreatorInput[]
    createMany?: WastageCreateManyCreatorInputEnvelope
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput> | ActivityLogCreateWithoutCreatorInput[] | ActivityLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutCreatorInput | ActivityLogCreateOrConnectWithoutCreatorInput[]
    createMany?: ActivityLogCreateManyCreatorInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type PaymentLinkCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput> | PaymentLinkCreateWithoutCreatorInput[] | PaymentLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCreatorInput | PaymentLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: PaymentLinkCreateManyCreatorInputEnvelope
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput> | MenuItemCreateWithoutCreatorInput[] | MenuItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCreatorInput | MenuItemCreateOrConnectWithoutCreatorInput[]
    createMany?: MenuItemCreateManyCreatorInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput> | TiffinSkipCreateWithoutCreatorInput[] | TiffinSkipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCreatorInput | TiffinSkipCreateOrConnectWithoutCreatorInput[]
    createMany?: TiffinSkipCreateManyCreatorInputEnvelope
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
  }

  export type IngredientUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput> | IngredientCreateWithoutCreatorInput[] | IngredientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatorInput | IngredientCreateOrConnectWithoutCreatorInput[]
    createMany?: IngredientCreateManyCreatorInputEnvelope
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput> | RecipeCreateWithoutCreatorInput[] | RecipeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatorInput | RecipeCreateOrConnectWithoutCreatorInput[]
    createMany?: RecipeCreateManyCreatorInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput> | SupplierCreateWithoutCreatorInput[] | SupplierUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCreatorInput | SupplierCreateOrConnectWithoutCreatorInput[]
    createMany?: SupplierCreateManyCreatorInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput> | PurchaseCreateWithoutCreatorInput[] | PurchaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatorInput | PurchaseCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseCreateManyCreatorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type WastageUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput> | WastageCreateWithoutCreatorInput[] | WastageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutCreatorInput | WastageCreateOrConnectWithoutCreatorInput[]
    createMany?: WastageCreateManyCreatorInputEnvelope
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput> | ActivityLogCreateWithoutCreatorInput[] | ActivityLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutCreatorInput | ActivityLogCreateOrConnectWithoutCreatorInput[]
    createMany?: ActivityLogCreateManyCreatorInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput> | PaymentLinkCreateWithoutCreatorInput[] | PaymentLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCreatorInput | PaymentLinkCreateOrConnectWithoutCreatorInput[]
    createMany?: PaymentLinkCreateManyCreatorInputEnvelope
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatorInput | CustomerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatorInput | CustomerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatorInput | CustomerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MenuItemUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput> | MenuItemCreateWithoutCreatorInput[] | MenuItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCreatorInput | MenuItemCreateOrConnectWithoutCreatorInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutCreatorInput | MenuItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MenuItemCreateManyCreatorInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutCreatorInput | MenuItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutCreatorInput | MenuItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type TiffinSkipUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput> | TiffinSkipCreateWithoutCreatorInput[] | TiffinSkipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCreatorInput | TiffinSkipCreateOrConnectWithoutCreatorInput[]
    upsert?: TiffinSkipUpsertWithWhereUniqueWithoutCreatorInput | TiffinSkipUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TiffinSkipCreateManyCreatorInputEnvelope
    set?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    disconnect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    delete?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    update?: TiffinSkipUpdateWithWhereUniqueWithoutCreatorInput | TiffinSkipUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TiffinSkipUpdateManyWithWhereWithoutCreatorInput | TiffinSkipUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
  }

  export type IngredientUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput> | IngredientCreateWithoutCreatorInput[] | IngredientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatorInput | IngredientCreateOrConnectWithoutCreatorInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutCreatorInput | IngredientUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IngredientCreateManyCreatorInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutCreatorInput | IngredientUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutCreatorInput | IngredientUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput> | RecipeCreateWithoutCreatorInput[] | RecipeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatorInput | RecipeCreateOrConnectWithoutCreatorInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatorInput | RecipeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecipeCreateManyCreatorInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatorInput | RecipeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatorInput | RecipeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput> | SupplierCreateWithoutCreatorInput[] | SupplierUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCreatorInput | SupplierCreateOrConnectWithoutCreatorInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCreatorInput | SupplierUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SupplierCreateManyCreatorInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCreatorInput | SupplierUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCreatorInput | SupplierUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput> | PurchaseCreateWithoutCreatorInput[] | PurchaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatorInput | PurchaseCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatorInput | PurchaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseCreateManyCreatorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatorInput | PurchaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatorInput | PurchaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type WastageUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput> | WastageCreateWithoutCreatorInput[] | WastageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutCreatorInput | WastageCreateOrConnectWithoutCreatorInput[]
    upsert?: WastageUpsertWithWhereUniqueWithoutCreatorInput | WastageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WastageCreateManyCreatorInputEnvelope
    set?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    disconnect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    delete?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    update?: WastageUpdateWithWhereUniqueWithoutCreatorInput | WastageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WastageUpdateManyWithWhereWithoutCreatorInput | WastageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WastageScalarWhereInput | WastageScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput> | ActivityLogCreateWithoutCreatorInput[] | ActivityLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutCreatorInput | ActivityLogCreateOrConnectWithoutCreatorInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutCreatorInput | ActivityLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ActivityLogCreateManyCreatorInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutCreatorInput | ActivityLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutCreatorInput | ActivityLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type PaymentLinkUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput> | PaymentLinkCreateWithoutCreatorInput[] | PaymentLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCreatorInput | PaymentLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: PaymentLinkUpsertWithWhereUniqueWithoutCreatorInput | PaymentLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PaymentLinkCreateManyCreatorInputEnvelope
    set?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    disconnect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    delete?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    update?: PaymentLinkUpdateWithWhereUniqueWithoutCreatorInput | PaymentLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PaymentLinkUpdateManyWithWhereWithoutCreatorInput | PaymentLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput> | CustomerCreateWithoutCreatorInput[] | CustomerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatorInput | CustomerCreateOrConnectWithoutCreatorInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatorInput | CustomerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CustomerCreateManyCreatorInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatorInput | CustomerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatorInput | CustomerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput> | MenuItemCreateWithoutCreatorInput[] | MenuItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutCreatorInput | MenuItemCreateOrConnectWithoutCreatorInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutCreatorInput | MenuItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MenuItemCreateManyCreatorInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutCreatorInput | MenuItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutCreatorInput | MenuItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput> | TiffinSkipCreateWithoutCreatorInput[] | TiffinSkipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCreatorInput | TiffinSkipCreateOrConnectWithoutCreatorInput[]
    upsert?: TiffinSkipUpsertWithWhereUniqueWithoutCreatorInput | TiffinSkipUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TiffinSkipCreateManyCreatorInputEnvelope
    set?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    disconnect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    delete?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    update?: TiffinSkipUpdateWithWhereUniqueWithoutCreatorInput | TiffinSkipUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TiffinSkipUpdateManyWithWhereWithoutCreatorInput | TiffinSkipUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
  }

  export type IngredientUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput> | IngredientCreateWithoutCreatorInput[] | IngredientUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IngredientCreateOrConnectWithoutCreatorInput | IngredientCreateOrConnectWithoutCreatorInput[]
    upsert?: IngredientUpsertWithWhereUniqueWithoutCreatorInput | IngredientUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IngredientCreateManyCreatorInputEnvelope
    set?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    disconnect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    delete?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    connect?: IngredientWhereUniqueInput | IngredientWhereUniqueInput[]
    update?: IngredientUpdateWithWhereUniqueWithoutCreatorInput | IngredientUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IngredientUpdateManyWithWhereWithoutCreatorInput | IngredientUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput> | RecipeCreateWithoutCreatorInput[] | RecipeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutCreatorInput | RecipeCreateOrConnectWithoutCreatorInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutCreatorInput | RecipeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RecipeCreateManyCreatorInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutCreatorInput | RecipeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutCreatorInput | RecipeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput> | SupplierCreateWithoutCreatorInput[] | SupplierUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutCreatorInput | SupplierCreateOrConnectWithoutCreatorInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutCreatorInput | SupplierUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SupplierCreateManyCreatorInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutCreatorInput | SupplierUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutCreatorInput | SupplierUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput> | PurchaseCreateWithoutCreatorInput[] | PurchaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutCreatorInput | PurchaseCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutCreatorInput | PurchaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseCreateManyCreatorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutCreatorInput | PurchaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutCreatorInput | PurchaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type WastageUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput> | WastageCreateWithoutCreatorInput[] | WastageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutCreatorInput | WastageCreateOrConnectWithoutCreatorInput[]
    upsert?: WastageUpsertWithWhereUniqueWithoutCreatorInput | WastageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WastageCreateManyCreatorInputEnvelope
    set?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    disconnect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    delete?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    update?: WastageUpdateWithWhereUniqueWithoutCreatorInput | WastageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WastageUpdateManyWithWhereWithoutCreatorInput | WastageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WastageScalarWhereInput | WastageScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput> | ActivityLogCreateWithoutCreatorInput[] | ActivityLogUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutCreatorInput | ActivityLogCreateOrConnectWithoutCreatorInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutCreatorInput | ActivityLogUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ActivityLogCreateManyCreatorInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutCreatorInput | ActivityLogUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutCreatorInput | ActivityLogUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput> | PaymentLinkCreateWithoutCreatorInput[] | PaymentLinkUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCreatorInput | PaymentLinkCreateOrConnectWithoutCreatorInput[]
    upsert?: PaymentLinkUpsertWithWhereUniqueWithoutCreatorInput | PaymentLinkUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PaymentLinkCreateManyCreatorInputEnvelope
    set?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    disconnect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    delete?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    update?: PaymentLinkUpdateWithWhereUniqueWithoutCreatorInput | PaymentLinkUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PaymentLinkUpdateManyWithWhereWithoutCreatorInput | PaymentLinkUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCustomersInput = {
    create?: XOR<UserCreateWithoutCustomersInput, UserUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerRefInput = {
    create?: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput> | OrderCreateWithoutCustomerRefInput[] | OrderUncheckedCreateWithoutCustomerRefInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerRefInput | OrderCreateOrConnectWithoutCustomerRefInput[]
    createMany?: OrderCreateManyCustomerRefInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TiffinSkipCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput> | TiffinSkipCreateWithoutCustomerInput[] | TiffinSkipUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCustomerInput | TiffinSkipCreateOrConnectWithoutCustomerInput[]
    createMany?: TiffinSkipCreateManyCustomerInputEnvelope
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
  }

  export type PaymentLinkCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput> | PaymentLinkCreateWithoutCustomerInput[] | PaymentLinkUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCustomerInput | PaymentLinkCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentLinkCreateManyCustomerInputEnvelope
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerRefInput = {
    create?: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput> | OrderCreateWithoutCustomerRefInput[] | OrderUncheckedCreateWithoutCustomerRefInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerRefInput | OrderCreateOrConnectWithoutCustomerRefInput[]
    createMany?: OrderCreateManyCustomerRefInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TiffinSkipUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput> | TiffinSkipCreateWithoutCustomerInput[] | TiffinSkipUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCustomerInput | TiffinSkipCreateOrConnectWithoutCustomerInput[]
    createMany?: TiffinSkipCreateManyCustomerInputEnvelope
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
  }

  export type PaymentLinkUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput> | PaymentLinkCreateWithoutCustomerInput[] | PaymentLinkUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCustomerInput | PaymentLinkCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentLinkCreateManyCustomerInputEnvelope
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<UserCreateWithoutCustomersInput, UserUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomersInput
    upsert?: UserUpsertWithoutCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomersInput, UserUpdateWithoutCustomersInput>, UserUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderUpdateManyWithoutCustomerRefNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput> | OrderCreateWithoutCustomerRefInput[] | OrderUncheckedCreateWithoutCustomerRefInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerRefInput | OrderCreateOrConnectWithoutCustomerRefInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerRefInput | OrderUpsertWithWhereUniqueWithoutCustomerRefInput[]
    createMany?: OrderCreateManyCustomerRefInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerRefInput | OrderUpdateWithWhereUniqueWithoutCustomerRefInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerRefInput | OrderUpdateManyWithWhereWithoutCustomerRefInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TiffinSkipUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput> | TiffinSkipCreateWithoutCustomerInput[] | TiffinSkipUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCustomerInput | TiffinSkipCreateOrConnectWithoutCustomerInput[]
    upsert?: TiffinSkipUpsertWithWhereUniqueWithoutCustomerInput | TiffinSkipUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TiffinSkipCreateManyCustomerInputEnvelope
    set?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    disconnect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    delete?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    update?: TiffinSkipUpdateWithWhereUniqueWithoutCustomerInput | TiffinSkipUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TiffinSkipUpdateManyWithWhereWithoutCustomerInput | TiffinSkipUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
  }

  export type PaymentLinkUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput> | PaymentLinkCreateWithoutCustomerInput[] | PaymentLinkUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCustomerInput | PaymentLinkCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentLinkUpsertWithWhereUniqueWithoutCustomerInput | PaymentLinkUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentLinkCreateManyCustomerInputEnvelope
    set?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    disconnect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    delete?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    update?: PaymentLinkUpdateWithWhereUniqueWithoutCustomerInput | PaymentLinkUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentLinkUpdateManyWithWhereWithoutCustomerInput | PaymentLinkUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerRefNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput> | OrderCreateWithoutCustomerRefInput[] | OrderUncheckedCreateWithoutCustomerRefInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerRefInput | OrderCreateOrConnectWithoutCustomerRefInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerRefInput | OrderUpsertWithWhereUniqueWithoutCustomerRefInput[]
    createMany?: OrderCreateManyCustomerRefInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerRefInput | OrderUpdateWithWhereUniqueWithoutCustomerRefInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerRefInput | OrderUpdateManyWithWhereWithoutCustomerRefInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TiffinSkipUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput> | TiffinSkipCreateWithoutCustomerInput[] | TiffinSkipUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TiffinSkipCreateOrConnectWithoutCustomerInput | TiffinSkipCreateOrConnectWithoutCustomerInput[]
    upsert?: TiffinSkipUpsertWithWhereUniqueWithoutCustomerInput | TiffinSkipUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TiffinSkipCreateManyCustomerInputEnvelope
    set?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    disconnect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    delete?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    connect?: TiffinSkipWhereUniqueInput | TiffinSkipWhereUniqueInput[]
    update?: TiffinSkipUpdateWithWhereUniqueWithoutCustomerInput | TiffinSkipUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TiffinSkipUpdateManyWithWhereWithoutCustomerInput | TiffinSkipUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
  }

  export type PaymentLinkUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput> | PaymentLinkCreateWithoutCustomerInput[] | PaymentLinkUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentLinkCreateOrConnectWithoutCustomerInput | PaymentLinkCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentLinkUpsertWithWhereUniqueWithoutCustomerInput | PaymentLinkUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentLinkCreateManyCustomerInputEnvelope
    set?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    disconnect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    delete?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    connect?: PaymentLinkWhereUniqueInput | PaymentLinkWhereUniqueInput[]
    update?: PaymentLinkUpdateWithWhereUniqueWithoutCustomerInput | PaymentLinkUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentLinkUpdateManyWithWhereWithoutCustomerInput | PaymentLinkUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type UserCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<UserCreateWithoutMenuItemsInput, UserUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenuItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMenuItemsNestedInput = {
    create?: XOR<UserCreateWithoutMenuItemsInput, UserUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMenuItemsInput
    upsert?: UserUpsertWithoutMenuItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMenuItemsInput, UserUpdateWithoutMenuItemsInput>, UserUncheckedUpdateWithoutMenuItemsInput>
  }

  export type CustomerCreateNestedOneWithoutTiffinSkipsInput = {
    create?: XOR<CustomerCreateWithoutTiffinSkipsInput, CustomerUncheckedCreateWithoutTiffinSkipsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTiffinSkipsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTiffinSkipsInput = {
    create?: XOR<UserCreateWithoutTiffinSkipsInput, UserUncheckedCreateWithoutTiffinSkipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTiffinSkipsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutTiffinSkipsNestedInput = {
    create?: XOR<CustomerCreateWithoutTiffinSkipsInput, CustomerUncheckedCreateWithoutTiffinSkipsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTiffinSkipsInput
    upsert?: CustomerUpsertWithoutTiffinSkipsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTiffinSkipsInput, CustomerUpdateWithoutTiffinSkipsInput>, CustomerUncheckedUpdateWithoutTiffinSkipsInput>
  }

  export type UserUpdateOneRequiredWithoutTiffinSkipsNestedInput = {
    create?: XOR<UserCreateWithoutTiffinSkipsInput, UserUncheckedCreateWithoutTiffinSkipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTiffinSkipsInput
    upsert?: UserUpsertWithoutTiffinSkipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTiffinSkipsInput, UserUpdateWithoutTiffinSkipsInput>, UserUncheckedUpdateWithoutTiffinSkipsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<UserCreateWithoutIngredientsInput, UserUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientsInput
    connect?: UserWhereUniqueInput
  }

  export type WastageCreateNestedManyWithoutIngredientInput = {
    create?: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput> | WastageCreateWithoutIngredientInput[] | WastageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutIngredientInput | WastageCreateOrConnectWithoutIngredientInput[]
    createMany?: WastageCreateManyIngredientInputEnvelope
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
  }

  export type WastageUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput> | WastageCreateWithoutIngredientInput[] | WastageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutIngredientInput | WastageCreateOrConnectWithoutIngredientInput[]
    createMany?: WastageCreateManyIngredientInputEnvelope
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<UserCreateWithoutIngredientsInput, UserUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIngredientsInput
    upsert?: UserUpsertWithoutIngredientsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIngredientsInput, UserUpdateWithoutIngredientsInput>, UserUncheckedUpdateWithoutIngredientsInput>
  }

  export type WastageUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput> | WastageCreateWithoutIngredientInput[] | WastageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutIngredientInput | WastageCreateOrConnectWithoutIngredientInput[]
    upsert?: WastageUpsertWithWhereUniqueWithoutIngredientInput | WastageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: WastageCreateManyIngredientInputEnvelope
    set?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    disconnect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    delete?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    update?: WastageUpdateWithWhereUniqueWithoutIngredientInput | WastageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: WastageUpdateManyWithWhereWithoutIngredientInput | WastageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: WastageScalarWhereInput | WastageScalarWhereInput[]
  }

  export type WastageUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput> | WastageCreateWithoutIngredientInput[] | WastageUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: WastageCreateOrConnectWithoutIngredientInput | WastageCreateOrConnectWithoutIngredientInput[]
    upsert?: WastageUpsertWithWhereUniqueWithoutIngredientInput | WastageUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: WastageCreateManyIngredientInputEnvelope
    set?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    disconnect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    delete?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    connect?: WastageWhereUniqueInput | WastageWhereUniqueInput[]
    update?: WastageUpdateWithWhereUniqueWithoutIngredientInput | WastageUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: WastageUpdateManyWithWhereWithoutIngredientInput | WastageUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: WastageScalarWhereInput | WastageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRecipesInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    upsert?: UserUpsertWithoutRecipesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipesInput, UserUpdateWithoutRecipesInput>, UserUncheckedUpdateWithoutRecipesInput>
  }

  export type UserCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<UserCreateWithoutSuppliersInput, UserUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuppliersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<UserCreateWithoutSuppliersInput, UserUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuppliersInput
    upsert?: UserUpsertWithoutSuppliersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuppliersInput, UserUpdateWithoutSuppliersInput>, UserUncheckedUpdateWithoutSuppliersInput>
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasesInput, UserUpdateWithoutPurchasesInput>, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type IngredientCreateNestedOneWithoutWastagesInput = {
    create?: XOR<IngredientCreateWithoutWastagesInput, IngredientUncheckedCreateWithoutWastagesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutWastagesInput
    connect?: IngredientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWastagesInput = {
    create?: XOR<UserCreateWithoutWastagesInput, UserUncheckedCreateWithoutWastagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWastagesInput
    connect?: UserWhereUniqueInput
  }

  export type IngredientUpdateOneRequiredWithoutWastagesNestedInput = {
    create?: XOR<IngredientCreateWithoutWastagesInput, IngredientUncheckedCreateWithoutWastagesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutWastagesInput
    upsert?: IngredientUpsertWithoutWastagesInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutWastagesInput, IngredientUpdateWithoutWastagesInput>, IngredientUncheckedUpdateWithoutWastagesInput>
  }

  export type UserUpdateOneRequiredWithoutWastagesNestedInput = {
    create?: XOR<UserCreateWithoutWastagesInput, UserUncheckedCreateWithoutWastagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWastagesInput
    upsert?: UserUpsertWithoutWastagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWastagesInput, UserUpdateWithoutWastagesInput>, UserUncheckedUpdateWithoutWastagesInput>
  }

  export type CustomerCreateNestedOneWithoutPaymentLinksInput = {
    create?: XOR<CustomerCreateWithoutPaymentLinksInput, CustomerUncheckedCreateWithoutPaymentLinksInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentLinksInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentLinksInput = {
    create?: XOR<UserCreateWithoutPaymentLinksInput, UserUncheckedCreateWithoutPaymentLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentLinksInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutPaymentLinksNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentLinksInput, CustomerUncheckedCreateWithoutPaymentLinksInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentLinksInput
    upsert?: CustomerUpsertWithoutPaymentLinksInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentLinksInput, CustomerUpdateWithoutPaymentLinksInput>, CustomerUncheckedUpdateWithoutPaymentLinksInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentLinksNestedInput = {
    create?: XOR<UserCreateWithoutPaymentLinksInput, UserUncheckedCreateWithoutPaymentLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentLinksInput
    upsert?: UserUpsertWithoutPaymentLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentLinksInput, UserUpdateWithoutPaymentLinksInput>, UserUncheckedUpdateWithoutPaymentLinksInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CustomerCreateWithoutCreatorInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCreatorInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput>
  }

  export type CustomerCreateManyCreatorInputEnvelope = {
    data: CustomerCreateManyCreatorInput | CustomerCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customerRef: CustomerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenuItemUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenuItemCreateOrConnectWithoutCreatorInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput>
  }

  export type MenuItemCreateManyCreatorInputEnvelope = {
    data: MenuItemCreateManyCreatorInput | MenuItemCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TiffinSkipCreateWithoutCreatorInput = {
    id?: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutTiffinSkipsInput
  }

  export type TiffinSkipUncheckedCreateWithoutCreatorInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipCreateOrConnectWithoutCreatorInput = {
    where: TiffinSkipWhereUniqueInput
    create: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput>
  }

  export type TiffinSkipCreateManyCreatorInputEnvelope = {
    data: TiffinSkipCreateManyCreatorInput | TiffinSkipCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type IngredientCreateWithoutCreatorInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    wastages?: WastageCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    wastages?: WastageUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutCreatorInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput>
  }

  export type IngredientCreateManyCreatorInputEnvelope = {
    data: IngredientCreateManyCreatorInput | IngredientCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RecipeUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RecipeCreateOrConnectWithoutCreatorInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput>
  }

  export type RecipeCreateManyCreatorInputEnvelope = {
    data: RecipeCreateManyCreatorInput | RecipeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutCreatorInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierCreateOrConnectWithoutCreatorInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput>
  }

  export type SupplierCreateManyCreatorInputEnvelope = {
    data: SupplierCreateManyCreatorInput | SupplierCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutCreatorInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseUncheckedCreateWithoutCreatorInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutCreatorInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseCreateManyCreatorInputEnvelope = {
    data: PurchaseCreateManyCreatorInput | PurchaseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type WastageCreateWithoutCreatorInput = {
    id?: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    ingredient: IngredientCreateNestedOneWithoutWastagesInput
  }

  export type WastageUncheckedCreateWithoutCreatorInput = {
    id?: string
    ingredient_id: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageCreateOrConnectWithoutCreatorInput = {
    where: WastageWhereUniqueInput
    create: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput>
  }

  export type WastageCreateManyCreatorInputEnvelope = {
    data: WastageCreateManyCreatorInput | WastageCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutCreatorInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutCreatorInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutCreatorInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput>
  }

  export type ActivityLogCreateManyCreatorInputEnvelope = {
    data: ActivityLogCreateManyCreatorInput | ActivityLogCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentLinkCreateWithoutCreatorInput = {
    id?: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentLinksInput
  }

  export type PaymentLinkUncheckedCreateWithoutCreatorInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentLinkCreateOrConnectWithoutCreatorInput = {
    where: PaymentLinkWhereUniqueInput
    create: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput>
  }

  export type PaymentLinkCreateManyCreatorInputEnvelope = {
    data: PaymentLinkCreateManyCreatorInput | PaymentLinkCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCreatorInput, CustomerUncheckedUpdateWithoutCreatorInput>
    create: XOR<CustomerCreateWithoutCreatorInput, CustomerUncheckedCreateWithoutCreatorInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCreatorInput, CustomerUncheckedUpdateWithoutCreatorInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCreatorInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    full_name?: StringFilter<"Customer"> | string
    phone_number?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    area?: StringNullableFilter<"Customer"> | string | null
    meal_type?: StringNullableFilter<"Customer"> | string | null
    payment_amount?: FloatNullableFilter<"Customer"> | number | null
    payment_status?: StringNullableFilter<"Customer"> | string | null
    due_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    last_payment_amount?: FloatNullableFilter<"Customer"> | number | null
    active?: BoolFilter<"Customer"> | boolean
    status?: StringNullableFilter<"Customer"> | string | null
    inactive_reason?: StringNullableFilter<"Customer"> | string | null
    start_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    paid_days?: IntNullableFilter<"Customer"> | number | null
    delivered_days?: IntNullableFilter<"Customer"> | number | null
    days_remaining?: IntNullableFilter<"Customer"> | number | null
    meals_delivered?: IntNullableFilter<"Customer"> | number | null
    tiffin_balance?: IntNullableFilter<"Customer"> | number | null
    roti_quantity?: IntNullableFilter<"Customer"> | number | null
    rice_type?: StringNullableFilter<"Customer"> | string | null
    special_notes?: StringNullableFilter<"Customer"> | string | null
    dietary_preference?: StringNullableFilter<"Customer"> | string | null
    skip_weekends?: BoolNullableFilter<"Customer"> | boolean | null
    pause_start?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_end?: DateTimeNullableFilter<"Customer"> | Date | string | null
    pause_start_date?: StringNullableFilter<"Customer"> | string | null
    pause_resume_date?: StringNullableFilter<"Customer"> | string | null
    original_end_date?: StringNullableFilter<"Customer"> | string | null
    total_pause_days?: IntNullableFilter<"Customer"> | number | null
    pause_history?: JsonNullableFilter<"Customer">
    notification_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_before_sent?: BoolNullableFilter<"Customer"> | boolean | null
    reminder_after_sent?: BoolNullableFilter<"Customer"> | boolean | null
    notes?: StringNullableFilter<"Customer"> | string | null
    is_trial?: BoolNullableFilter<"Customer"> | boolean | null
    trial_end_date?: DateTimeNullableFilter<"Customer"> | Date | string | null
    trial_converted?: BoolNullableFilter<"Customer"> | boolean | null
    is_paused?: BoolNullableFilter<"Customer"> | boolean | null
    is_deleted?: BoolFilter<"Customer"> | boolean
    deleted_at?: DateTimeNullableFilter<"Customer"> | Date | string | null
    portal_token?: StringNullableFilter<"Customer"> | string | null
    referral_code?: StringNullableFilter<"Customer"> | string | null
    referred_by?: StringNullableFilter<"Customer"> | string | null
    family_group_id?: StringNullableFilter<"Customer"> | string | null
    kitchen_id?: StringNullableFilter<"Customer"> | string | null
    registration_source?: StringNullableFilter<"Customer"> | string | null
    created_by?: StringFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    customer_id?: StringFilter<"Order"> | string
    customer_name?: StringNullableFilter<"Order"> | string | null
    meal_type?: StringNullableFilter<"Order"> | string | null
    delivery_date?: StringNullableFilter<"Order"> | string | null
    order_date?: StringNullableFilter<"Order"> | string | null
    delivery_status?: StringNullableFilter<"Order"> | string | null
    status?: StringFilter<"Order"> | string
    out_for_delivery_time?: StringNullableFilter<"Order"> | string | null
    delivery_photo?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    created_by?: StringFilter<"Order"> | string
    created_at?: DateTimeFilter<"Order"> | Date | string
    updated_at?: DateTimeFilter<"Order"> | Date | string
  }

  export type MenuItemUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutCreatorInput, MenuItemUncheckedUpdateWithoutCreatorInput>
    create: XOR<MenuItemCreateWithoutCreatorInput, MenuItemUncheckedCreateWithoutCreatorInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutCreatorInput, MenuItemUncheckedUpdateWithoutCreatorInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutCreatorInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    price?: FloatNullableFilter<"MenuItem"> | number | null
    category?: StringNullableFilter<"MenuItem"> | string | null
    image_url?: StringNullableFilter<"MenuItem"> | string | null
    meal_type?: StringNullableFilter<"MenuItem"> | string | null
    is_active?: BoolFilter<"MenuItem"> | boolean
    day_of_week?: StringNullableFilter<"MenuItem"> | string | null
    created_by?: StringFilter<"MenuItem"> | string
    created_at?: DateTimeFilter<"MenuItem"> | Date | string
    updated_at?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type TiffinSkipUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TiffinSkipWhereUniqueInput
    update: XOR<TiffinSkipUpdateWithoutCreatorInput, TiffinSkipUncheckedUpdateWithoutCreatorInput>
    create: XOR<TiffinSkipCreateWithoutCreatorInput, TiffinSkipUncheckedCreateWithoutCreatorInput>
  }

  export type TiffinSkipUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TiffinSkipWhereUniqueInput
    data: XOR<TiffinSkipUpdateWithoutCreatorInput, TiffinSkipUncheckedUpdateWithoutCreatorInput>
  }

  export type TiffinSkipUpdateManyWithWhereWithoutCreatorInput = {
    where: TiffinSkipScalarWhereInput
    data: XOR<TiffinSkipUpdateManyMutationInput, TiffinSkipUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TiffinSkipScalarWhereInput = {
    AND?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
    OR?: TiffinSkipScalarWhereInput[]
    NOT?: TiffinSkipScalarWhereInput | TiffinSkipScalarWhereInput[]
    id?: StringFilter<"TiffinSkip"> | string
    customer_id?: StringFilter<"TiffinSkip"> | string
    customer_name?: StringNullableFilter<"TiffinSkip"> | string | null
    skip_date?: StringFilter<"TiffinSkip"> | string
    meal_type?: StringNullableFilter<"TiffinSkip"> | string | null
    reason?: StringNullableFilter<"TiffinSkip"> | string | null
    status?: StringFilter<"TiffinSkip"> | string
    carry_forward_applied?: BoolFilter<"TiffinSkip"> | boolean
    created_by?: StringFilter<"TiffinSkip"> | string
    created_at?: DateTimeFilter<"TiffinSkip"> | Date | string
    updated_at?: DateTimeFilter<"TiffinSkip"> | Date | string
  }

  export type IngredientUpsertWithWhereUniqueWithoutCreatorInput = {
    where: IngredientWhereUniqueInput
    update: XOR<IngredientUpdateWithoutCreatorInput, IngredientUncheckedUpdateWithoutCreatorInput>
    create: XOR<IngredientCreateWithoutCreatorInput, IngredientUncheckedCreateWithoutCreatorInput>
  }

  export type IngredientUpdateWithWhereUniqueWithoutCreatorInput = {
    where: IngredientWhereUniqueInput
    data: XOR<IngredientUpdateWithoutCreatorInput, IngredientUncheckedUpdateWithoutCreatorInput>
  }

  export type IngredientUpdateManyWithWhereWithoutCreatorInput = {
    where: IngredientScalarWhereInput
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyWithoutCreatorInput>
  }

  export type IngredientScalarWhereInput = {
    AND?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
    OR?: IngredientScalarWhereInput[]
    NOT?: IngredientScalarWhereInput | IngredientScalarWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    unit?: StringNullableFilter<"Ingredient"> | string | null
    current_stock?: FloatNullableFilter<"Ingredient"> | number | null
    min_stock_threshold?: FloatNullableFilter<"Ingredient"> | number | null
    cost_per_unit?: FloatNullableFilter<"Ingredient"> | number | null
    total_value?: FloatNullableFilter<"Ingredient"> | number | null
    is_critical?: BoolFilter<"Ingredient"> | boolean
    last_purchase_date?: StringNullableFilter<"Ingredient"> | string | null
    created_by?: StringFilter<"Ingredient"> | string
    created_at?: DateTimeFilter<"Ingredient"> | Date | string
    updated_at?: DateTimeFilter<"Ingredient"> | Date | string
  }

  export type RecipeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutCreatorInput, RecipeUncheckedUpdateWithoutCreatorInput>
    create: XOR<RecipeCreateWithoutCreatorInput, RecipeUncheckedCreateWithoutCreatorInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutCreatorInput, RecipeUncheckedUpdateWithoutCreatorInput>
  }

  export type RecipeUpdateManyWithWhereWithoutCreatorInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    meal_type?: StringNullableFilter<"Recipe"> | string | null
    ingredients?: JsonNullableFilter<"Recipe">
    is_active?: BoolFilter<"Recipe"> | boolean
    total_cost?: FloatNullableFilter<"Recipe"> | number | null
    cost_per_serving?: FloatNullableFilter<"Recipe"> | number | null
    created_by?: StringFilter<"Recipe"> | string
    created_at?: DateTimeFilter<"Recipe"> | Date | string
    updated_at?: DateTimeFilter<"Recipe"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutCreatorInput, SupplierUncheckedUpdateWithoutCreatorInput>
    create: XOR<SupplierCreateWithoutCreatorInput, SupplierUncheckedCreateWithoutCreatorInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutCreatorInput, SupplierUncheckedUpdateWithoutCreatorInput>
  }

  export type SupplierUpdateManyWithWhereWithoutCreatorInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    phone?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    created_by?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchaseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutCreatorInput, PurchaseUncheckedUpdateWithoutCreatorInput>
    create: XOR<PurchaseCreateWithoutCreatorInput, PurchaseUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutCreatorInput, PurchaseUncheckedUpdateWithoutCreatorInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutCreatorInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    ingredient_id?: StringNullableFilter<"Purchase"> | string | null
    ingredient_name?: StringNullableFilter<"Purchase"> | string | null
    quantity?: FloatNullableFilter<"Purchase"> | number | null
    unit?: StringNullableFilter<"Purchase"> | string | null
    cost_per_unit?: FloatNullableFilter<"Purchase"> | number | null
    total_cost?: FloatNullableFilter<"Purchase"> | number | null
    supplier_id?: StringNullableFilter<"Purchase"> | string | null
    supplier_name?: StringNullableFilter<"Purchase"> | string | null
    purchase_date?: StringNullableFilter<"Purchase"> | string | null
    expiry_date?: StringNullableFilter<"Purchase"> | string | null
    bill_image_url?: StringNullableFilter<"Purchase"> | string | null
    notes?: StringNullableFilter<"Purchase"> | string | null
    is_deleted?: BoolFilter<"Purchase"> | boolean
    created_by?: StringFilter<"Purchase"> | string
    created_at?: DateTimeFilter<"Purchase"> | Date | string
    updated_at?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type WastageUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WastageWhereUniqueInput
    update: XOR<WastageUpdateWithoutCreatorInput, WastageUncheckedUpdateWithoutCreatorInput>
    create: XOR<WastageCreateWithoutCreatorInput, WastageUncheckedCreateWithoutCreatorInput>
  }

  export type WastageUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WastageWhereUniqueInput
    data: XOR<WastageUpdateWithoutCreatorInput, WastageUncheckedUpdateWithoutCreatorInput>
  }

  export type WastageUpdateManyWithWhereWithoutCreatorInput = {
    where: WastageScalarWhereInput
    data: XOR<WastageUpdateManyMutationInput, WastageUncheckedUpdateManyWithoutCreatorInput>
  }

  export type WastageScalarWhereInput = {
    AND?: WastageScalarWhereInput | WastageScalarWhereInput[]
    OR?: WastageScalarWhereInput[]
    NOT?: WastageScalarWhereInput | WastageScalarWhereInput[]
    id?: StringFilter<"Wastage"> | string
    ingredient_id?: StringFilter<"Wastage"> | string
    ingredient_name?: StringNullableFilter<"Wastage"> | string | null
    quantity?: FloatNullableFilter<"Wastage"> | number | null
    unit?: StringNullableFilter<"Wastage"> | string | null
    reason?: StringNullableFilter<"Wastage"> | string | null
    cost_value?: FloatNullableFilter<"Wastage"> | number | null
    wastage_date?: StringNullableFilter<"Wastage"> | string | null
    notes?: StringNullableFilter<"Wastage"> | string | null
    is_deleted?: BoolFilter<"Wastage"> | boolean
    created_by?: StringFilter<"Wastage"> | string
    created_at?: DateTimeFilter<"Wastage"> | Date | string
    updated_at?: DateTimeFilter<"Wastage"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutCreatorInput, ActivityLogUncheckedUpdateWithoutCreatorInput>
    create: XOR<ActivityLogCreateWithoutCreatorInput, ActivityLogUncheckedCreateWithoutCreatorInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutCreatorInput, ActivityLogUncheckedUpdateWithoutCreatorInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutCreatorInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    user_email?: StringFilter<"ActivityLog"> | string
    user_name?: StringNullableFilter<"ActivityLog"> | string | null
    action_type?: StringFilter<"ActivityLog"> | string
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    metadata?: JsonNullableFilter<"ActivityLog">
    created_by?: StringFilter<"ActivityLog"> | string
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type PaymentLinkUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PaymentLinkWhereUniqueInput
    update: XOR<PaymentLinkUpdateWithoutCreatorInput, PaymentLinkUncheckedUpdateWithoutCreatorInput>
    create: XOR<PaymentLinkCreateWithoutCreatorInput, PaymentLinkUncheckedCreateWithoutCreatorInput>
  }

  export type PaymentLinkUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PaymentLinkWhereUniqueInput
    data: XOR<PaymentLinkUpdateWithoutCreatorInput, PaymentLinkUncheckedUpdateWithoutCreatorInput>
  }

  export type PaymentLinkUpdateManyWithWhereWithoutCreatorInput = {
    where: PaymentLinkScalarWhereInput
    data: XOR<PaymentLinkUpdateManyMutationInput, PaymentLinkUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PaymentLinkScalarWhereInput = {
    AND?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
    OR?: PaymentLinkScalarWhereInput[]
    NOT?: PaymentLinkScalarWhereInput | PaymentLinkScalarWhereInput[]
    id?: StringFilter<"PaymentLink"> | string
    customer_id?: StringFilter<"PaymentLink"> | string
    customer_name?: StringNullableFilter<"PaymentLink"> | string | null
    amount?: FloatNullableFilter<"PaymentLink"> | number | null
    currency?: StringNullableFilter<"PaymentLink"> | string | null
    description?: StringNullableFilter<"PaymentLink"> | string | null
    status?: StringFilter<"PaymentLink"> | string
    stripe_checkout_session_id?: StringNullableFilter<"PaymentLink"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"PaymentLink"> | string | null
    checkout_url?: StringNullableFilter<"PaymentLink"> | string | null
    expires_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    paid_at?: DateTimeNullableFilter<"PaymentLink"> | Date | string | null
    platform_fee_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    net_amount?: FloatNullableFilter<"PaymentLink"> | number | null
    payment_metadata?: JsonNullableFilter<"PaymentLink">
    created_by?: StringFilter<"PaymentLink"> | string
    created_at?: DateTimeFilter<"PaymentLink"> | Date | string
    updated_at?: DateTimeFilter<"PaymentLink"> | Date | string
  }

  export type UserCreateWithoutCustomersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCustomersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomersInput, UserUncheckedCreateWithoutCustomersInput>
  }

  export type OrderCreateWithoutCustomerRefInput = {
    id?: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutCustomerRefInput = {
    id?: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderCreateOrConnectWithoutCustomerRefInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput>
  }

  export type OrderCreateManyCustomerRefInputEnvelope = {
    data: OrderCreateManyCustomerRefInput | OrderCreateManyCustomerRefInput[]
    skipDuplicates?: boolean
  }

  export type TiffinSkipCreateWithoutCustomerInput = {
    id?: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutTiffinSkipsInput
  }

  export type TiffinSkipUncheckedCreateWithoutCustomerInput = {
    id?: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipCreateOrConnectWithoutCustomerInput = {
    where: TiffinSkipWhereUniqueInput
    create: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput>
  }

  export type TiffinSkipCreateManyCustomerInputEnvelope = {
    data: TiffinSkipCreateManyCustomerInput | TiffinSkipCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentLinkCreateWithoutCustomerInput = {
    id?: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutPaymentLinksInput
  }

  export type PaymentLinkUncheckedCreateWithoutCustomerInput = {
    id?: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentLinkCreateOrConnectWithoutCustomerInput = {
    where: PaymentLinkWhereUniqueInput
    create: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentLinkCreateManyCustomerInputEnvelope = {
    data: PaymentLinkCreateManyCustomerInput | PaymentLinkCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomersInput = {
    update: XOR<UserUpdateWithoutCustomersInput, UserUncheckedUpdateWithoutCustomersInput>
    create: XOR<UserCreateWithoutCustomersInput, UserUncheckedCreateWithoutCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomersInput, UserUncheckedUpdateWithoutCustomersInput>
  }

  export type UserUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerRefInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerRefInput, OrderUncheckedUpdateWithoutCustomerRefInput>
    create: XOR<OrderCreateWithoutCustomerRefInput, OrderUncheckedCreateWithoutCustomerRefInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerRefInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerRefInput, OrderUncheckedUpdateWithoutCustomerRefInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerRefInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerRefInput>
  }

  export type TiffinSkipUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TiffinSkipWhereUniqueInput
    update: XOR<TiffinSkipUpdateWithoutCustomerInput, TiffinSkipUncheckedUpdateWithoutCustomerInput>
    create: XOR<TiffinSkipCreateWithoutCustomerInput, TiffinSkipUncheckedCreateWithoutCustomerInput>
  }

  export type TiffinSkipUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TiffinSkipWhereUniqueInput
    data: XOR<TiffinSkipUpdateWithoutCustomerInput, TiffinSkipUncheckedUpdateWithoutCustomerInput>
  }

  export type TiffinSkipUpdateManyWithWhereWithoutCustomerInput = {
    where: TiffinSkipScalarWhereInput
    data: XOR<TiffinSkipUpdateManyMutationInput, TiffinSkipUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentLinkUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentLinkWhereUniqueInput
    update: XOR<PaymentLinkUpdateWithoutCustomerInput, PaymentLinkUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentLinkCreateWithoutCustomerInput, PaymentLinkUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentLinkUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentLinkWhereUniqueInput
    data: XOR<PaymentLinkUpdateWithoutCustomerInput, PaymentLinkUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentLinkUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentLinkScalarWhereInput
    data: XOR<PaymentLinkUpdateManyMutationInput, PaymentLinkUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutCustomersInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCustomerInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCustomersNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutMenuItemsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMenuItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMenuItemsInput, UserUncheckedCreateWithoutMenuItemsInput>
  }

  export type UserUpsertWithoutMenuItemsInput = {
    update: XOR<UserUpdateWithoutMenuItemsInput, UserUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<UserCreateWithoutMenuItemsInput, UserUncheckedCreateWithoutMenuItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMenuItemsInput, UserUncheckedUpdateWithoutMenuItemsInput>
  }

  export type UserUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerCreateWithoutTiffinSkipsInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerRefInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTiffinSkipsInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerRefInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTiffinSkipsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTiffinSkipsInput, CustomerUncheckedCreateWithoutTiffinSkipsInput>
  }

  export type UserCreateWithoutTiffinSkipsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTiffinSkipsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTiffinSkipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTiffinSkipsInput, UserUncheckedCreateWithoutTiffinSkipsInput>
  }

  export type CustomerUpsertWithoutTiffinSkipsInput = {
    update: XOR<CustomerUpdateWithoutTiffinSkipsInput, CustomerUncheckedUpdateWithoutTiffinSkipsInput>
    create: XOR<CustomerCreateWithoutTiffinSkipsInput, CustomerUncheckedCreateWithoutTiffinSkipsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTiffinSkipsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTiffinSkipsInput, CustomerUncheckedUpdateWithoutTiffinSkipsInput>
  }

  export type CustomerUpdateWithoutTiffinSkipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerRefNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTiffinSkipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerRefNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutTiffinSkipsInput = {
    update: XOR<UserUpdateWithoutTiffinSkipsInput, UserUncheckedUpdateWithoutTiffinSkipsInput>
    create: XOR<UserCreateWithoutTiffinSkipsInput, UserUncheckedCreateWithoutTiffinSkipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTiffinSkipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTiffinSkipsInput, UserUncheckedUpdateWithoutTiffinSkipsInput>
  }

  export type UserUpdateWithoutTiffinSkipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTiffinSkipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutIngredientsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutIngredientsInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutIngredientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIngredientsInput, UserUncheckedCreateWithoutIngredientsInput>
  }

  export type WastageCreateWithoutIngredientInput = {
    id?: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutWastagesInput
  }

  export type WastageUncheckedCreateWithoutIngredientInput = {
    id?: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageCreateOrConnectWithoutIngredientInput = {
    where: WastageWhereUniqueInput
    create: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput>
  }

  export type WastageCreateManyIngredientInputEnvelope = {
    data: WastageCreateManyIngredientInput | WastageCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIngredientsInput = {
    update: XOR<UserUpdateWithoutIngredientsInput, UserUncheckedUpdateWithoutIngredientsInput>
    create: XOR<UserCreateWithoutIngredientsInput, UserUncheckedCreateWithoutIngredientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIngredientsInput, UserUncheckedUpdateWithoutIngredientsInput>
  }

  export type UserUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type WastageUpsertWithWhereUniqueWithoutIngredientInput = {
    where: WastageWhereUniqueInput
    update: XOR<WastageUpdateWithoutIngredientInput, WastageUncheckedUpdateWithoutIngredientInput>
    create: XOR<WastageCreateWithoutIngredientInput, WastageUncheckedCreateWithoutIngredientInput>
  }

  export type WastageUpdateWithWhereUniqueWithoutIngredientInput = {
    where: WastageWhereUniqueInput
    data: XOR<WastageUpdateWithoutIngredientInput, WastageUncheckedUpdateWithoutIngredientInput>
  }

  export type WastageUpdateManyWithWhereWithoutIngredientInput = {
    where: WastageScalarWhereInput
    data: XOR<WastageUpdateManyMutationInput, WastageUncheckedUpdateManyWithoutIngredientInput>
  }

  export type UserCreateWithoutRecipesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRecipesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRecipesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
  }

  export type UserUpsertWithoutRecipesInput = {
    update: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
  }

  export type UserUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSuppliersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSuppliersInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSuppliersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuppliersInput, UserUncheckedCreateWithoutSuppliersInput>
  }

  export type UserUpsertWithoutSuppliersInput = {
    update: XOR<UserUpdateWithoutSuppliersInput, UserUncheckedUpdateWithoutSuppliersInput>
    create: XOR<UserCreateWithoutSuppliersInput, UserUncheckedCreateWithoutSuppliersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuppliersInput, UserUncheckedUpdateWithoutSuppliersInput>
  }

  export type UserUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type IngredientCreateWithoutWastagesInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutIngredientsInput
  }

  export type IngredientUncheckedCreateWithoutWastagesInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IngredientCreateOrConnectWithoutWastagesInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutWastagesInput, IngredientUncheckedCreateWithoutWastagesInput>
  }

  export type UserCreateWithoutWastagesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutWastagesInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
    paymentLinks?: PaymentLinkUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutWastagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWastagesInput, UserUncheckedCreateWithoutWastagesInput>
  }

  export type IngredientUpsertWithoutWastagesInput = {
    update: XOR<IngredientUpdateWithoutWastagesInput, IngredientUncheckedUpdateWithoutWastagesInput>
    create: XOR<IngredientCreateWithoutWastagesInput, IngredientUncheckedCreateWithoutWastagesInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutWastagesInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutWastagesInput, IngredientUncheckedUpdateWithoutWastagesInput>
  }

  export type IngredientUpdateWithoutWastagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type IngredientUncheckedUpdateWithoutWastagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutWastagesInput = {
    update: XOR<UserUpdateWithoutWastagesInput, UserUncheckedUpdateWithoutWastagesInput>
    create: XOR<UserCreateWithoutWastagesInput, UserUncheckedCreateWithoutWastagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWastagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWastagesInput, UserUncheckedUpdateWithoutWastagesInput>
  }

  export type UserUpdateWithoutWastagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutWastagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerCreateWithoutPaymentLinksInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentLinksInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerRefInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentLinksInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentLinksInput, CustomerUncheckedCreateWithoutPaymentLinksInput>
  }

  export type UserCreateWithoutPaymentLinksInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerCreateNestedManyWithoutCreatorInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientCreateNestedManyWithoutCreatorInput
    recipes?: RecipeCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseCreateNestedManyWithoutCreatorInput
    wastages?: WastageCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPaymentLinksInput = {
    id?: string
    email: string
    password_hash: string
    full_name?: string | null
    role?: string
    phone?: string | null
    business_name?: string | null
    logo_url?: string | null
    subscription_status?: string | null
    plan_type?: string | null
    subscription_source?: string | null
    trial_ends_at?: Date | string | null
    trial_cancelled_at?: Date | string | null
    subscription_ends_at?: Date | string | null
    current_period_end?: Date | string | null
    next_billing_date?: Date | string | null
    cancel_at_period_end?: boolean | null
    cancellation_reason?: string | null
    cancelled_at?: Date | string | null
    is_paid?: boolean
    last_payment_status?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_id?: string | null
    stripe_connect_account_id?: string | null
    payment_account_connected?: boolean | null
    payment_verification_status?: string | null
    fee_consent_accepted?: boolean | null
    fee_percentage?: number | null
    whatsapp_sent_count?: number
    whatsapp_limit?: number
    whatsapp_notifications_enabled?: boolean | null
    whatsapp_number?: string | null
    currency?: string | null
    language?: string | null
    seasonal_mode?: string | null
    seasonal_mode_start?: string | null
    seasonal_mode_end?: string | null
    ramadan_lunch_time?: string | null
    ramadan_dinner_time?: string | null
    ramadan_suhoor_time?: string | null
    ramadan_iftar_time?: string | null
    is_super_admin?: boolean
    special_access_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutCreatorInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutCreatorInput
    tiffinSkips?: TiffinSkipUncheckedCreateNestedManyWithoutCreatorInput
    ingredients?: IngredientUncheckedCreateNestedManyWithoutCreatorInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutCreatorInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutCreatorInput
    purchases?: PurchaseUncheckedCreateNestedManyWithoutCreatorInput
    wastages?: WastageUncheckedCreateNestedManyWithoutCreatorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPaymentLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentLinksInput, UserUncheckedCreateWithoutPaymentLinksInput>
  }

  export type CustomerUpsertWithoutPaymentLinksInput = {
    update: XOR<CustomerUpdateWithoutPaymentLinksInput, CustomerUncheckedUpdateWithoutPaymentLinksInput>
    create: XOR<CustomerCreateWithoutPaymentLinksInput, CustomerUncheckedCreateWithoutPaymentLinksInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentLinksInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentLinksInput, CustomerUncheckedUpdateWithoutPaymentLinksInput>
  }

  export type CustomerUpdateWithoutPaymentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutPaymentLinksInput = {
    update: XOR<UserUpdateWithoutPaymentLinksInput, UserUncheckedUpdateWithoutPaymentLinksInput>
    create: XOR<UserCreateWithoutPaymentLinksInput, UserUncheckedCreateWithoutPaymentLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentLinksInput, UserUncheckedUpdateWithoutPaymentLinksInput>
  }

  export type UserUpdateWithoutPaymentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutCreatorNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    plan_type?: NullableStringFieldUpdateOperationsInput | string | null
    subscription_source?: NullableStringFieldUpdateOperationsInput | string | null
    trial_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_ends_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    current_period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    next_billing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancel_at_period_end?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancellation_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    last_payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_connect_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_account_connected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payment_verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    fee_consent_accepted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fee_percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    whatsapp_sent_count?: IntFieldUpdateOperationsInput | number
    whatsapp_limit?: IntFieldUpdateOperationsInput | number
    whatsapp_notifications_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    whatsapp_number?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_start?: NullableStringFieldUpdateOperationsInput | string | null
    seasonal_mode_end?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_lunch_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_dinner_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_suhoor_time?: NullableStringFieldUpdateOperationsInput | string | null
    ramadan_iftar_time?: NullableStringFieldUpdateOperationsInput | string | null
    is_super_admin?: BoolFieldUpdateOperationsInput | boolean
    special_access_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutCreatorNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutCreatorNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCreatorNestedInput
    ingredients?: IngredientUncheckedUpdateManyWithoutCreatorNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutCreatorNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutCreatorNestedInput
    purchases?: PurchaseUncheckedUpdateManyWithoutCreatorNestedInput
    wastages?: WastageUncheckedUpdateManyWithoutCreatorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CustomerCreateManyCreatorInput = {
    id?: string
    full_name: string
    phone_number?: string | null
    address?: string | null
    area?: string | null
    meal_type?: string | null
    payment_amount?: number | null
    payment_status?: string | null
    due_date?: Date | string | null
    last_payment_date?: Date | string | null
    last_payment_amount?: number | null
    active?: boolean
    status?: string | null
    inactive_reason?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    paid_days?: number | null
    delivered_days?: number | null
    days_remaining?: number | null
    meals_delivered?: number | null
    tiffin_balance?: number | null
    roti_quantity?: number | null
    rice_type?: string | null
    special_notes?: string | null
    dietary_preference?: string | null
    skip_weekends?: boolean | null
    pause_start?: Date | string | null
    pause_end?: Date | string | null
    pause_start_date?: string | null
    pause_resume_date?: string | null
    original_end_date?: string | null
    total_pause_days?: number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: boolean | null
    reminder_before_sent?: boolean | null
    reminder_after_sent?: boolean | null
    notes?: string | null
    is_trial?: boolean | null
    trial_end_date?: Date | string | null
    trial_converted?: boolean | null
    is_paused?: boolean | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    portal_token?: string | null
    referral_code?: string | null
    referred_by?: string | null
    family_group_id?: string | null
    kitchen_id?: string | null
    registration_source?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MenuItemCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    category?: string | null
    image_url?: string | null
    meal_type?: string | null
    is_active?: boolean
    day_of_week?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipCreateManyCreatorInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IngredientCreateManyCreatorInput = {
    id?: string
    name: string
    unit?: string | null
    current_stock?: number | null
    min_stock_threshold?: number | null
    cost_per_unit?: number | null
    total_value?: number | null
    is_critical?: boolean
    last_purchase_date?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RecipeCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    meal_type?: string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    total_cost?: number | null
    cost_per_serving?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierCreateManyCreatorInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseCreateManyCreatorInput = {
    id?: string
    ingredient_id?: string | null
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    cost_per_unit?: number | null
    total_cost?: number | null
    supplier_id?: string | null
    supplier_name?: string | null
    purchase_date?: string | null
    expiry_date?: string | null
    bill_image_url?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageCreateManyCreatorInput = {
    id?: string
    ingredient_id: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateManyCreatorInput = {
    id?: string
    user_email: string
    user_name?: string | null
    action_type: string
    entity_type?: string | null
    entity_id?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type PaymentLinkCreateManyCreatorInput = {
    id?: string
    customer_id: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerRefNestedInput
    tiffinSkips?: TiffinSkipUncheckedUpdateManyWithoutCustomerNestedInput
    paymentLinks?: PaymentLinkUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_payment_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    status?: NullableStringFieldUpdateOperationsInput | string | null
    inactive_reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_days?: NullableIntFieldUpdateOperationsInput | number | null
    delivered_days?: NullableIntFieldUpdateOperationsInput | number | null
    days_remaining?: NullableIntFieldUpdateOperationsInput | number | null
    meals_delivered?: NullableIntFieldUpdateOperationsInput | number | null
    tiffin_balance?: NullableIntFieldUpdateOperationsInput | number | null
    roti_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rice_type?: NullableStringFieldUpdateOperationsInput | string | null
    special_notes?: NullableStringFieldUpdateOperationsInput | string | null
    dietary_preference?: NullableStringFieldUpdateOperationsInput | string | null
    skip_weekends?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pause_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pause_start_date?: NullableStringFieldUpdateOperationsInput | string | null
    pause_resume_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_end_date?: NullableStringFieldUpdateOperationsInput | string | null
    total_pause_days?: NullableIntFieldUpdateOperationsInput | number | null
    pause_history?: NullableJsonNullValueInput | InputJsonValue
    notification_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_before_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reminder_after_sent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_trial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_converted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_paused?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    portal_token?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: NullableStringFieldUpdateOperationsInput | string | null
    referred_by?: NullableStringFieldUpdateOperationsInput | string | null
    family_group_id?: NullableStringFieldUpdateOperationsInput | string | null
    kitchen_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customerRef?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    day_of_week?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTiffinSkipsNestedInput
  }

  export type TiffinSkipUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wastages?: WastageUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wastages?: WastageUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    current_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    min_stock_threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_value?: NullableFloatFieldUpdateOperationsInput | number | null
    is_critical?: BoolFieldUpdateOperationsInput | boolean
    last_purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_per_serving?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    cost_per_unit?: NullableFloatFieldUpdateOperationsInput | number | null
    total_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    supplier_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier_name?: NullableStringFieldUpdateOperationsInput | string | null
    purchase_date?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_date?: NullableStringFieldUpdateOperationsInput | string | null
    bill_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ingredient?: IngredientUpdateOneRequiredWithoutWastagesNestedInput
  }

  export type WastageUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_email?: StringFieldUpdateOperationsInput | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentLinksNestedInput
  }

  export type PaymentLinkUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyCustomerRefInput = {
    id?: string
    customer_name?: string | null
    meal_type?: string | null
    delivery_date?: string | null
    order_date?: string | null
    delivery_status?: string | null
    status?: string
    out_for_delivery_time?: string | null
    delivery_photo?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TiffinSkipCreateManyCustomerInput = {
    id?: string
    customer_name?: string | null
    skip_date: string
    meal_type?: string | null
    reason?: string | null
    status?: string
    carry_forward_applied?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentLinkCreateManyCustomerInput = {
    id?: string
    customer_name?: string | null
    amount?: number | null
    currency?: string | null
    description?: string | null
    status?: string
    stripe_checkout_session_id?: string | null
    stripe_payment_intent_id?: string | null
    checkout_url?: string | null
    expires_at?: Date | string | null
    paid_at?: Date | string | null
    platform_fee_amount?: number | null
    net_amount?: number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrderUpdateWithoutCustomerRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutCustomerRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_status?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    out_for_delivery_time?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTiffinSkipsNestedInput
  }

  export type TiffinSkipUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiffinSkipUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    skip_date?: StringFieldUpdateOperationsInput | string
    meal_type?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    carry_forward_applied?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutPaymentLinksNestedInput
  }

  export type PaymentLinkUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentLinkUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    stripe_checkout_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_url?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platform_fee_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    net_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    payment_metadata?: NullableJsonNullValueInput | InputJsonValue
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageCreateManyIngredientInput = {
    id?: string
    ingredient_name?: string | null
    quantity?: number | null
    unit?: string | null
    reason?: string | null
    cost_value?: number | null
    wastage_date?: string | null
    notes?: string | null
    is_deleted?: boolean
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type WastageUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutWastagesNestedInput
  }

  export type WastageUncheckedUpdateWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WastageUncheckedUpdateManyWithoutIngredientInput = {
    id?: StringFieldUpdateOperationsInput | string
    ingredient_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cost_value?: NullableFloatFieldUpdateOperationsInput | number | null
    wastage_date?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientCountOutputTypeDefaultArgs instead
     */
    export type IngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuItemDefaultArgs instead
     */
    export type MenuItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TiffinSkipDefaultArgs instead
     */
    export type TiffinSkipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TiffinSkipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientDefaultArgs instead
     */
    export type IngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WastageDefaultArgs instead
     */
    export type WastageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WastageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentHistoryDefaultArgs instead
     */
    export type PaymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentLinkDefaultArgs instead
     */
    export type PaymentLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsumptionLogDefaultArgs instead
     */
    export type ConsumptionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsumptionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealRatingDefaultArgs instead
     */
    export type MealRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FamilyGroupDefaultArgs instead
     */
    export type FamilyGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FamilyGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverDefaultArgs instead
     */
    export type DriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryBatchDefaultArgs instead
     */
    export type DeliveryBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryItemDefaultArgs instead
     */
    export type DeliveryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContainerDefaultArgs instead
     */
    export type ContainerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContainerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContainerLogDefaultArgs instead
     */
    export type ContainerLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContainerLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KitchenDefaultArgs instead
     */
    export type KitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KitchenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrepItemDefaultArgs instead
     */
    export type PrepItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrepItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMessageDefaultArgs instead
     */
    export type ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}